==============================================================================
------------------------------------------------------------------------------
                                                                     *mini.nvim*
*mini.txt*  Collection of minimal, independent and fast Lua modules

Author:  Evgeni Chasnovski
License: MIT

|mini.nvim| is a collection of minimal, independent, and fast Lua modules
dedicated to improve Neovim (version 0.5 and higher) experience. Each
module can be considered as a separate sub-plugin.

Table of contents:
  General overview.................................................|mini.nvim|
  Plugin colorscheme..............................................|minischeme|
  Smart autochdir.............................................|mini.autochdir|
  Base16 colorscheme creation....................................|mini.base16|
  Remove buffers..............................................|mini.bufremove|
  Comment.......................................................|mini.comment|
  Completion and signature help..............................|mini.completion|
  Highlight word under cursor................................|mini.cursorword|
  Generate help files...............................................|mini.doc|
  Fuzzy matching..................................................|mini.fuzzy|
  Visualize and operate on indent scope.....................|mini.indentscope|
  Jump cursor to a single character................................|mini.jump|
  Jump within visible lines......................................|mini.jump2d|
  Miscellaneous functions..........................................|mini.misc|
  Autopairs.......................................................|mini.pairs|
  Session management...........................................|mini.sessions|
  Start screen..................................................|mini.starter|
  Statusline.................................................|mini.statusline|
  Surround.....................................................|mini.surround|
  Tabline.......................................................|mini.tabline|
  Trailspace (highlight and remove)..........................|mini.trailspace|

# General principles~

- <Design>. Each module is designed to solve a particular problem targeting
  balance between feature-richness (handling as many edge-cases as
  possible) and simplicity of implementation/support. Granted, not all of
  them ended up with the same balance, but it is the goal nevertheless.
- <Independence>. Modules are independent of each other and can be run
  without external dependencies. Although some of them may need
  dependencies for full experience.
- <Structure>. Each module is a submodule for a placeholder "mini" module. So,
  for example, "surround" module should be referred to as "mini.surround".
  As later will be explained, this plugin can also be referred to
  as "MiniSurround".
- <Setup>:
    - Each module (if needed) should be setup separately with
      `require(<name of module>).setup({})`
      (possibly replace {} with your config table or omit to use defaults).
      You can supply only values which differ from defaults, which will be
      used for the rest ones.
    - Call to module's `setup()` always creates a global Lua object with
      coherent camel-case name: `require('mini.surround').setup()` creates
      `_G.MiniSurround`. This allows for a simpler usage of plugin
      functionality: instead of `require('mini.surround')` use
      `MiniSurround` (or manually `:lua MiniSurround.*` in command line);
      available from `v:lua` like `v:lua.MiniSurround`. Considering this,
      "module" and "Lua object" names can be used interchangeably:
      'mini.surround' and 'MiniSurround' will mean the same thing.
    - Each supplied `config` table (after extending with default values) is
      stored in `config` field of global object. Like `MiniSurround.config`.
    - Values of `config`, which affect runtime activity, can be changed on
      the fly to have effect. For example, `MiniSurround.config.n_lines`
      can be changed during runtime; but changing
      `MiniSurround.config.mappings` won't have any effect (as mappings are
      created once during `setup()`).
- <Disabling>. Each module's core functionality can be disabled globally or
  buffer-locally by creating appropriate global or buffer-scoped variables
  equal to |v:true|. See |mini.nvim-disabling-recipes| for common recipes.
- <Highlight groups>. Appearance of module's output is controlled by
  certain highlight group (see |highlight-groups|). To customize them, use
  |highlight| command. Note: currently not many Neovim themes support this
  plugin's highlight groups; fixing this situation is highly appreciated.
  To see a more calibrated look, use |MiniBase16| or plugin's colorscheme
  `minischeme`.
- <Stability>. Each module upon release is considered to be relatively
  stable: both in terms of setup and functionality. Any
  non-bugfix backward-incompatible change will be released gradually as
  much as possible.

# List of modules~

- |MiniBase16| - fast implementation of base16 theme for manually supplied
  palette. Has unique palette generator which needs only background and
  foreground colors.
- |MiniBufremove| - buffer removing (unshow, delete, wipeout) while saving
  window layout.
- |MiniComment| - fast and familiar per-line code commenting.
- |MiniCompletion| - async (with customizable 'debounce' delay) 'two-stage
  chain completion': first builtin LSP, then configurable fallback. Also
  has functionality for completion item info and function signature (both
  in floating window appearing after customizable delay).
- |MiniCursorword| - automatic highlighting of word under cursor (displayed
  after customizable delay). Current word under cursor can be highlighted
  differently.
- |MiniDoc| - generation of help files from EmmyLua-like annotations.
  Allows flexible customization of output via hook functions. Used for
  documenting this plugin.
- |MiniFuzzy| - functions for fast and simple fuzzy matching. It has
  not only functions to perform fuzzy matching of one string to others, but
  also a sorter for |telescope.nvim|.
- |MiniIndentscope| - Visualize and operate on indent scope. Supports
  customization of debounce delay, animation style, and different
  granularity of options for scope computing algorithm.
- |MiniJump| - minimal and fast module for smarter jumping to a single
  character.
- |MiniJump2d| - minimal and fast Lua plugin for jumping (moving cursor)
  within visible lines via iterative label filtering. Supports custom jump
  targets (spots), labels, hooks, allowed windows and lines, and more.
- |MiniMisc| - collection of miscellaneous useful functions. Like `put()`
  and `put_text()` which print Lua objects to command line and current
  buffer respectively.
- |MiniPairs| - autopairs plugin which has minimal defaults and
  functionality to do per-key expression mappings.
- |MiniSessions| - session management (read, write, delete) which works
  using |mksession|. Implements both global (from configured directory) and
  local (from current directory) sessions.
- |MiniStarter| - minimal, fast, and flexible start screen. Displayed items
  are fully customizable both in terms of what they do and how they look
  (with reasonable defaults). Item selection can be done using prefix query
  with instant visual feedback.
- |MiniStatusline| - minimal and fast statusline. Has ability to use custom
  content supplied with concise function (using module's provided section
  functions) along with builtin default. For full experience needs [Nerd
  font](https://www.nerdfonts.com/),
  [gitsigns.nvim](https://github.com/lewis6991/gitsigns.nvim) plugin, and
  [nvim-web-devicons](https://github.com/kyazdani42/nvim-web-devicons)
  plugin (but works without any them).
- |MiniSurround| - fast surround plugin. Add, delete, replace, find,
  highlight surrounding (like pair of parenthesis, quotes, etc.). Has
  special "function call", "tag", and "interactive" surroundings. Supports
  dot-repeatability, textobject, motions.
- |MiniTabline| - minimal tabline which always shows listed (see 'buflisted')
  buffers. Allows showing extra information section in case of multiple vim
  tabpages. For full experience needs
  [nvim-web-devicons](https://github.com/kyazdani42/nvim-web-devicons).
- |MiniTrailspace| - automatic highlighting of trailing whitespace with
  functionality to remove it.

------------------------------------------------------------------------------
                                                   *mini.nvim-disabling-recipes*
Common recipes for disabling functionality

Each module's core functionality can be disabled globally or buffer-locally
by creating appropriate global or buffer-scoped variables equal to
|v:true|. Functionality is disabled if at least one of `g:` or `b:`
variables is equal to `v:true`.

Variable names have the same structure: `{g,b}:mini*_disable` where `*` is
module's lowercase name. For example, `g:minicursorword_disable` disables
|mini.cursorword| globally and `b:minicursorword_disable` - for
corresponding buffer. Note: in this section disabling 'mini.cursorword' is
used as example; everything holds for other module variables.

Considering high number of different scenarios and customization intentions,
writing exact rules for disabling module's functionality is left to user.

# Manual disabling~

- Disable globally:
  Lua       - `:lua vim.g.minicursorword_disable=true`
  Vimscript - `:let g:minicursorword_disable=v:true`
- Disable for current buffer:
  Lua       - `:lua vim.b.minicursorword_disable=true`
  Vimscript - `:let b:minicursorword_disable=v:true`
- Toggle (disable if enabled, enable if disabled):
  Globally   - `:lua vim.g.minicursorword_disable = not vim.g.minicursorword_disable`
  For buffer - `:lua vim.b.minicursorword_disable = not vim.b.minicursorword_disable`

# Automated disabling~

- Disable for a certain |filetype| (for example, "markdown"):
  `autocmd Filetype markdown lua vim.b.minicursorword_disable = true`
- Enable only for certain filetypes (for example, "lua" and "python"):
  `au FileType * if index(['lua', 'python'], &ft) < 0 | let b:minicursorword_disable=v:true | endif`
- Disable in Insert mode (use similar pattern for Terminal mode or indeed
  any other mode change with |ModeChanged| starting from Neovim 0.7.0):
  `au InsertEnter * lua vim.b.minicursorword_disable = true`
  `au InsertLeave * lua vim.b.minicursorword_disable = false`
- Disable in Terminal buffer:
  `au TermOpen * lua vim.b.minicursorword_disable = true`

------------------------------------------------------------------------------
                                                                    *minischeme*
# Plugin colorscheme~

This plugin comes with an official colorscheme named `minischeme`. This is
a |MiniBase16| theme created with faster version of the following Lua code: >
  require('mini.base16').setup({
    palette = palette, name = 'minischeme', use_cterm = true
  })
where `palette` is:
- For dark 'background':
    `require('mini.base16').mini_palette('#112641', '#e2e98f', 75)`
- For light 'background':
    `require('mini.base16').mini_palette('#e2e5ca', '#002a83', 75)`

Activate it as a regular |colorscheme|.


==============================================================================
------------------------------------------------------------------------------
                                                                *mini.autochdir*
                                                                 *MiniAutochdir*
Automatically change directory to a project root.
Main inspiration is a "mattn/vim-findroot" and "airblade/vim-rooter" plugin.

Features:
  Automatically change directory to a project root defined in
  |MiniAutochdir.config|. The patterns are written in the glob pattern.

General overview of how to find a project root:
- Check whether the designated file or the directory
  exists in current directory.
- If not, move to the parent directory to find a project root.

# Setup~
This module doesn't need setup, but it can be done to improve usability.
Setup with `require('mini.autochdir').setup({})` (replace `{}` with your
`config` table). It will create global Lua table `MiniAutochdir` which
you can use for scripting or manually (with `:lua MiniAutochdir.*`).

# Example usage~
- Modify default root_pattern to find a project root: >
  require('mini.autochdir').setup({ root_pattern = { '.git' }})
- At the time changing a buffer, it also changes CWD.

# Disabling~
To disable, set `g:miniautochdir_disable` (globally) or `b:miniautochdir_disable`
(for a buffer) to `v:true`. Considering high number of different scenarios
and customization intentions, writing exact rules for disabling module's
functionality is left to user. See |mini.nvim-disabling-recipes| for common
recipes.

# Notice~
https://github.com/mattn/vim-findroot is an OSS project licensed
under the MIT License.


------------------------------------------------------------------------------
                                                         *MiniAutochdir.setup()*
                        `MiniAutochdir.setup`({config})
Module setup

Parameters~
{config} `(table)` Module config table. See |MiniAutochdir.config|.

Usage~
`require('mini.autochdir').setup({})` (replace `{}` with your `config` table)

------------------------------------------------------------------------------
                                                          *MiniAutochdir.config*
                             `MiniAutochdir.config`
Module config

Default values:
>
  MiniAutochdir.config = {
    -- Array of glob root_pattern to find a project root.
    root_pattern = {
      '.svn',
      '.hg',
      '.bzr',
      '*.adc',
      'angular.json',
      'bower.json',
      'build',
      'BUILD.bazel',
      'build.boot',
      'build.gradle',
      'build.sbt',
      'build.sc',
      '*.cabal',
      'cabal.config',
      'cabal.project',
      'Cargo.toml',
      'compile_commands.json',
      'composer.json',
      '.csproj',
      'deno.json',
      'deno.jsonc',
      'deps.edn',
      'Dockerfile',
      'dub.json',
      'dub.sdl',
      'dune-project',
      'dune-workspace',
      'elm.json',
      'ember-cli-build.js',
      'erlang.mk',
      'esy.json',
      'flake.nix',
      '.flowconfig',
      '.fortls',
      'Gemfile',
      '.git',
      '.golangci.yaml',
      'go.mod',
      'go.work',
      '*.gpr',
      '.graphql.config.*',
      'graphql.config.*',
      '.graphqlrc*',
      '.hhconfig',
      'hie-bios',
      'hiera.yaml',
      'hie.yaml',
      '*.hxml',
      'jsconfig.json',
      'jsonnetfile.json',
      'lakefile.lean',
      'leanpkg.toml',
      'lean-toolchain',
      '.luacheckrc',
      '.luarc.json',
      'Makefile',
      'manifests',
      '.marksman.toml',
      'meson.build',
      'mix.exs',
      'node_modules',
      'ols.json',
      '*.opam',
      'package.json',
      'Package.swift',
      'package.yaml',
      'pom.xml',
      'postcss.config.js',
      'postcss.config.ts',
      'project.clj',
      'project.godot',
      'psalm.xml',
      'psalm.xml.dist',
      'psc-package.json',
      'pubspec.yaml',
      '.puppet-lint.rc',
      'pyproject.toml',
      'rebar.config',
      'requirements.txt',
      'robotidy.toml',
      'rust-project.json',
      'selene.toml',
      'settings.gradle',
      'sfdx-project.json',
      'shadow-cljs.edn',
      'shard.yml',
      'shell.nix',
      '.sln',
      'spago.dhall',
      'stack.yaml',
      'Steepfile',
      '.stylelintrc',
      '.stylua.toml',
      '.svlangserver',
      'tailwind.config.js',
      'tailwind.config.ts',
      '.terraform',
      '.tflint.hcl',
      'tlconfig.lua',
      '*.toml',
      'tsconfig.json',
      'v.mod',
      'vue.config.js',
      '.zk',
      'zls.json',
    },
  }
<

------------------------------------------------------------------------------
                                                      *MiniAutochdir.findroot()*
                           `MiniAutochdir.findroot`()
Find a project root from the directory of current buffer.

Return~
`(...)` this function returns nothing.


==============================================================================
------------------------------------------------------------------------------
                                                                   *mini.base16*
                                                                    *MiniBase16*
Minimal and fast Lua module which implements
[base16](http://chriskempson.com/projects/base16/) color scheme (with
Copyright (C) 2012 Chris Kempson) adapated for modern Neovim 0.5 Lua
plugins. Extra features:
- Configurable automatic support of cterm colors (see |highlight-cterm|).
- Opinionated palette generator based only on background and foreground
  colors.

# Setup~

This module needs a setup with `require('mini.base16').setup({})` (replace
`{}` with your `config` table). It will create global Lua table
`MiniBase16` which you can use for scripting or manually (with
`:lua MiniBase16.*`).

See |MiniBase16.config| for `config` structure and default values.

Example:
>
  require('mini.base16').setup({
    palette = {
      base00 = '#112641',
      base01 = '#3a475e',
      base02 = '#606b81',
      base03 = '#8691a7',
      base04 = '#d5dc81',
      base05 = '#e2e98f',
      base06 = '#eff69c',
      base07 = '#fcffaa',
      base08 = '#ffcfa0',
      base09 = '#cc7e46',
      base0A = '#46a436',
      base0B = '#9ff895',
      base0C = '#ca6ecf',
      base0D = '#42f7ff',
      base0E = '#ffc4ff',
      base0F = '#00a5c5',
    },
    use_cterm = true,
  })
<
# Notes~

1. This module is used to create plugin's colorscheme (see |minischeme|).
2. Using `setup()` doesn't actually create a |colorscheme|. It basically
   creates a coordinated set of |highlight|s. To create your own theme:
    - Put "myscheme.lua" file (name after your chosen theme name) inside
      any "colors" directory reachable from 'runtimepath' ("colors" inside
      your Neovim config directory is usually enough).
    - Inside "myscheme.lua" call `require('mini.base16').setup()` with your
      palette and only after that set |g:colors_name| to "myscheme".

------------------------------------------------------------------------------
                                                            *MiniBase16.setup()*
                          `MiniBase16.setup`({config})
Module setup

Setup is done by applying base16 palette to enable colorscheme. Highlight
groups make an extended set from original
[base16-vim](https://github.com/chriskempson/base16-vim/) plugin. It is a
good idea to have `config.palette` respect the original [styling
principles](https://github.com/chriskempson/base16/blob/master/styling.md).

By default only 'gui highlighting' (see |highlight-gui| and
|termguicolors|) is supported. To support 'cterm highlighting' (see
|highlight-cterm|) supply `config.use_cterm` argument in one of the formats:
- `true` to auto-generate from `palette` (as closest colors).
- Table with similar structure to `palette` but having terminal colors
  (integers from 0 to 255) instead of hex strings.

Parameters~
{config} `(table)` Module config table. See |MiniBase16.config|.

Usage~
`require('mini.base16').setup({})` (replace `{}` with your `config`
  table; `config.palette` should be a table with colors)

------------------------------------------------------------------------------
                                                             *MiniBase16.config*
                              `MiniBase16.config`
Module config

Default values:
>
  MiniBase16.config = {
    -- Table with names from `base00` to `base0F` and values being strings of
    -- HEX colors with format "#RRGGBB". NOTE: this should be explicitly
    -- supplied in `setup()`.
    palette = nil,

    -- Whether to support cterm colors. Can be boolean, `nil` (same as
    -- `false`), or table with cterm colors. See `setup()` documentation for
    -- more information.
    use_cterm = nil,
  }
<

------------------------------------------------------------------------------
                                                     *MiniBase16.mini_palette()*
     `MiniBase16.mini_palette`({background}, {foreground}, {accent_chroma})
Create 'mini' palette

Create base16 palette based on the HEX (string '#RRGGBB') colors of main
background and foreground with optional setting of accent chroma (see
details).

# Algorithm design~

- Main operating color space is
  [CIELCh(uv)](https://en.wikipedia.org/wiki/CIELUV#Cylindrical_representation_(CIELCh))
  which is a cylindrical representation of a perceptually uniform CIELUV
  color space. It defines color by three values: lightness L (values from 0
  to 100), chroma (positive values), and hue (circular values from 0 to 360
  degress). Useful converting tool: https://www.easyrgb.com/en/convert.php
- There are four important lightness values: background, foreground, focus
  (around the middle of background and foreground, leaning towards
  foreground), and edge (extreme lightness closest to foreground).
- First four colors have the same chroma and hue as `background` but
  lightness progresses from background towards focus.
- Second four colors have the same chroma and hue as `foreground` but
  lightness progresses from foreground towards edge in such a way that
  'base05' color is main foreground color.
- The rest eight colors are accent colors which are created in pairs
    - Each pair has same hue from set of hues 'most different' to
      background and foreground hues (if respective chorma is positive).
    - All colors have the same chroma equal to `accent_chroma` (if not
      provided, chroma of foreground is used, as they will appear next
      to each other). Note: this means that in case of low foreground
      chroma, it is a good idea to set `accent_chroma` manually.
      Values from 30 (low chorma) to 80 (high chroma) are common.
    - Within pair there is base lightness (equal to foreground
      lightness) and alternative (equal to focus lightness). Base
      lightness goes to colors which will be used more frequently in
      code: base08 (variables), base0B (strings), base0D (functions),
      base0E (keywords).
  How exactly accent colors are mapped to base16 palette is a result of
  trial and error. One rule of thumb was: colors within one hue pair should
  be more often seen next to each other. This is because it is easier to
  distinguish them and seems to be more visually appealing. That is why
  `base0D` and `base0F` have same hues because they usually represent
  functions and delimiter (brackets included).

Parameters~
{background} `(string)` Background HEX color (formatted as `#RRGGBB`).
{foreground} `(string)` Foreground HEX color (formatted as `#RRGGBB`).
{accent_chroma} `(number)` Optional positive number (usually between 0
  and 100). Default: chroma of foreground color.

Return~
`(table)` Table with base16 palette.

Usage~
`local palette = require('mini.base16').mini_palette('#112641', '#e2e98f', 75)`
`require('mini.base16').setup({palette = palette})`

------------------------------------------------------------------------------
                                     *MiniBase16.rgb_palette_to_cterm_palette()*
              `MiniBase16.rgb_palette_to_cterm_palette`({palette})
Converts palette with RGB colors to terminal colors

Useful for caching `use_cterm` variable to increase speed.

Parameters~
{palette} `(table)` Table with base16 palette (same as in
  `MiniBase16.config.palette`).

Return~
`(table)` Table with base16 palette using |highlight-cterm|.


==============================================================================
------------------------------------------------------------------------------
                                                                *mini.bufremove*
                                                                 *MiniBufremove*
Lua module for minimal buffer removing (unshow, delete, wipeout), which
saves window layout (opposite to builtin Neovim's commands). This is mostly
a Lua implementation of
[bclose.vim](https://vim.fandom.com/wiki/Deleting_a_buffer_without_closing_the_window).
Other alternatives:
- [vim-bbye](https://github.com/moll/vim-bbye)
- [vim-sayonara](https://github.com/mhinz/vim-sayonara)

# Setup~

This module doesn't need setup, but it can be done to improve usability.
Setup with `require('mini.bufremove').setup({})` (replace `{}` with your
`config` table). It will create global Lua table `MiniBufremove` which you
can use for scripting or manually (with `:lua MiniBufremove.*`).

See |MiniBufremove.config| for `config` structure and default values.

# Notes~

1. Which buffer to show in window(s) after its current buffer is removed is
   decided by the algorithm:
   - If alternate buffer (see |CTRL-^|) is listed (see |buflisted()|), use it.
   - If previous listed buffer (see |bprevious|) is different, use it.
   - Otherwise create a scratch one with `nvim_create_buf(true, true)` and use
     it.

# Disabling~

To disable core functionality, set `g:minibufremove_disable` (globally) or
`b:minibufremove_disable` (for a buffer) to `v:true`. Considering high
number of different scenarios and customization intentions, writing exact
rules for disabling module's functionality is left to user. See
|mini.nvim-disabling-recipes| for common recipes.

------------------------------------------------------------------------------
                                                         *MiniBufremove.setup()*
                        `MiniBufremove.setup`({config})
Module setup

Parameters~
{config} `(table)` Module config table. See |MiniBufremove.config|.

Usage~
`require('mini.bufremove').setup({})` (replace `{}` with your `config` table)

------------------------------------------------------------------------------
                                                          *MiniBufremove.config*
                             `MiniBufremove.config`
Module config

Default values:
>
  MiniBufremove.config = {
    -- Whether to set Vim's settings for buffers (allow hidden buffers)
    set_vim_settings = true,
  }
<

------------------------------------------------------------------------------
                                                        *MiniBufremove.delete()*
                   `MiniBufremove.delete`({buf_id}, {force})
Delete buffer `buf_id` with |:bdelete| after unshowing it

Parameters~
{buf_id} `(number)` Buffer identifier (see |bufnr()|) to use. Default:
  0 for current.
{force} `(boolean)` Whether to ignore unsaved changes (using `!` version of
  command). Default: `false`.

Return~
`(boolean)` Whether operation was successful.

------------------------------------------------------------------------------
                                                       *MiniBufremove.wipeout()*
                   `MiniBufremove.wipeout`({buf_id}, {force})
Wipeout buffer `buf_id` with |:bwipeout| after unshowing it

Parameters~
{buf_id} `(number)` Buffer identifier (see |bufnr()|) to use. Default:
  0 for current.
{force} `(boolean)` Whether to ignore unsaved changes (using `!` version of
  command). Default: `false`.

Return~
`(boolean)` Whether operation was successful.

------------------------------------------------------------------------------
                                                        *MiniBufremove.unshow()*
                        `MiniBufremove.unshow`({buf_id})
Stop showing buffer `buf_id` in all windows

Parameters~
{buf_id} `(number)` Buffer identifier (see |bufnr()|) to use. Default:
  0 for current.

Return~
`(boolean)` Whether operation was successful.

------------------------------------------------------------------------------
                                              *MiniBufremove.unshow_in_window()*
                   `MiniBufremove.unshow_in_window`({win_id})
Stop showing current buffer of window `win_id`

Parameters~
{win_id} `(number)` Window identifier (see |win_getid()|) to use.
  Default: 0 for current.

Return~
`(boolean)` Whether operation was successful.


==============================================================================
------------------------------------------------------------------------------
                                                                  *mini.comment*
                                                                   *MiniComment*
Minimal and fast Lua module for code commenting. This is basically a
reimplementation of "tpope/vim-commentary". Commenting in Normal mode
respects |count| and is dot-repeatable. Comment structure is inferred
from 'commentstring'. Handles both tab and space indenting (but not when
they are mixed). Allows custom hooks before and after successful commeting.

What it doesn't do:
- Block and sub-line comments. This will only support per-line commenting.
- Configurable (from module) comment structure. Modify |commentstring|
  instead. To enhance support for commenting in multi-language files, see
  "JoosepAlviste/nvim-ts-context-commentstring" plugin along with `hooks`
  option of this module (see |MiniComment.config|).
- Handle indentation with mixed tab and space.
- Preserve trailing whitespace in empty lines.

# Setup~

This module needs a setup with `require('mini.comment').setup({})` (replace
`{}` with your `config` table). It will create global Lua table
`MiniComment` which you can use for scripting or manually (with
`:lua MiniComment.*`).

See |MiniComment.config| for `config` structure and default values.

# Disabling~

To disable core functionality, set `g:minicomment_disable` (globally) or
`b:minicomment_disable` (for a buffer) to `v:true`. Considering high number
of different scenarios and customization intentions, writing exact rules
for disabling module's functionality is left to user. See
|mini.nvim-disabling-recipes| for common recipes.

------------------------------------------------------------------------------
                                                           *MiniComment.setup()*
                         `MiniComment.setup`({config})
Module setup

Parameters~
{config} `(table)` Module config table. See |MiniComment.config|.

Usage~
`require('mini.comment').setup({})` (replace `{}` with your `config` table)

------------------------------------------------------------------------------
                                                            *MiniComment.config*
                              `MiniComment.config`
Module config

Default values:
>
  MiniComment.config = {
    -- Module mappings. Use `''` (empty string) to disable one.
    mappings = {
      -- Toggle comment (like `gcip` - comment inner paragraph) for both
      -- Normal and Visual modes
      comment = 'gc',

      -- Toggle comment on current line
      comment_line = 'gcc',

      -- Define 'comment' textobject (like `dgc` - delete whole comment block)
      textobject = 'gc',
    },
    -- Hook functions to be executed at certain stage of commenting
    hooks = {
      -- Before successful commenting. Does nothing by default.
      pre = function() end,
      -- After successful commenting. Does nothing by default.
      post = function() end,
    },
  }
<

------------------------------------------------------------------------------
                                                        *MiniComment.operator()*
                         `MiniComment.operator`({mode})
Main function to be mapped

It is meant to be used in expression mappings (see |map-<expr>|) to enable
dot-repeatability and commenting on range. There is no need to do this
manually, everything is done inside |MiniComment.setup()|.

It has a somewhat unintuitive logic (because of how expression mapping with
dot-repeatability works): it should be called without arguments inside
expression mapping and with argument when action should be performed.

Parameters~
{mode} `(string)` Optional string with 'operatorfunc' mode (see |g@|).

Return~
`(string)` 'g@' if called without argument, '' otherwise (but after
  performing action).

------------------------------------------------------------------------------
                                                    *MiniComment.toggle_lines()*
              `MiniComment.toggle_lines`({line_start}, {line_end})
Toggle comments between two line numbers

It uncomments if lines are comment (every line is a comment) and comments
otherwise. It respects indentation and doesn't insert trailing
whitespace. Toggle commenting not in visual mode is also dot-repeatable
and respects |count|.

Before successful commenting it executes `MiniComment.config.hooks.pre`.
After successful commenting it executes `MiniComment.config.hooks.post`.

# Notes~

1. Currently call to this function will remove marks inside written range.
   Use |lockmarks| to preserve marks.

Parameters~
{line_start} `(number)` Start line number (inclusive from 1 to number of lines).
{line_end} `(number)` End line number (inclusive from 1 to number of lines).

------------------------------------------------------------------------------
                                                      *MiniComment.textobject()*
                           `MiniComment.textobject`()
Comment textobject

This selects all commented lines adjacent to cursor line (if it itself is
commented). Designed to be used with operator mode mappings (see |mapmode-o|).

Before successful textobject usage it executes `MiniComment.config.hooks.pre`.
After successful textobject usage it executes `MiniComment.config.hooks.post`.


==============================================================================
------------------------------------------------------------------------------
                                                               *mini.completion*
                                                                *MiniCompletion*
Custom somewhat minimal autocompletion Lua plugin. Key design ideas:
- Have an async (with customizable 'debounce' delay) 'two-stage chain
  completion': first try to get completion items from LSP client (if set
  up) and if no result, fallback to custom action.
- Managing completion is done as much with Neovim's built-in tools as
  possible.

Features:
- Two-stage chain completion:
    - First stage is an LSP completion implemented via
      |MiniCompletion.completefunc_lsp()|. It should be set up as either
      |completefunc| or |omnifunc|. It tries to get completion items from
      LSP client (via 'textDocument/completion' request). Custom
      preprocessing of response items is possible (with
      `MiniCompletion.config.lsp_completion.process_items`), for example
      with fuzzy matching. By default items which are not snippets and
      directly start with completed word are kept and sorted according to
      LSP specification. Supports `additionalTextEdits`, like auto-import
      and others (see 'Notes').
    - If first stage is not set up or resulted into no candidates, fallback
      action is executed. The most tested actions are Neovim's built-in
      insert completion (see |ins-completion|).
- Automatic display in floating window of completion item info (via
  'completionItem/resolve' request) and signature help (with highlighting
  of active parameter if LSP server provides such information). After
  opening, window for signature help is fixed and is closed when there is
  nothing to show, text is different or
  when leaving Insert mode.
- Automatic actions are done after some configurable amount of delay. This
  reduces computational load and allows fast typing (completion and
  signature help) and item selection (item info)
- Autoactions are triggered on Neovim's built-in events.
- User can force two-stage completion via
  |MiniCompletion.complete_twostage()| (by default is mapped to
  `<C-Space>`) or fallback completion via
  |MiniCompletion.complete_fallback()| (maped to `<M-Space>`).

What it doesn't do:
- Snippet expansion.
- Many configurable sources.
- Automatic mapping of `<CR>`, `<Tab>`, etc., as those tend to have highly
  variable user expectations. See 'Helpful key mappings' for suggestions.

# Setup~

This module needs a setup with `require('mini.completion').setup({})`
(replace `{}` with your `config` table). It will create global Lua table
`MiniCompletion` which you can use for scripting or manually (with
`:lua MiniCompletion.*`).

See |MiniCompletion.config| for `config` structure and default values.

# Notes~

- More appropriate, albeit slightly advanced, LSP completion setup is to set
  it not on every `BufEnter` event (default), but on every attach of LSP
  client. To do that:
    - Use in initial config:
    `lsp_completion = {source_func = 'omnifunc', auto_setup = false}`.
    - In `on_attach()` of every LSP client set 'omnifunc' option to exactly
      `v:lua.MiniCompletion.completefunc_lsp`.
- If you have trouble using custom (overriden) |vim.ui.input| (like from
  'stevearc/dressing.nvim'), make automated disable of 'mini.completion'
  for input buffer. For example, currently for 'dressing.nvim' it can be
  with `au FileType DressingInput lua vim.b.minicompletion_disable = true`.
- Support of `additionalTextEdits` tries to handle both types of servers:
    - When `additionalTextEdits` are supplied in response to
      'textDocument/completion' request (like currently in 'pyright').
    - When `additionalTextEdits` are supplied in response to
      'completionItem/resolve' request (like currently in
      'typescript-language-server'). In this case to apply edits user needs
      to trigger such request, i.e. select completion item and wait for
      `MiniCompletion.config.delay.info` time plus server response time.

# Comparisons~

- 'nvim-cmp':
    - More complex design which allows multiple sources each in form of
      separate plugin. `MiniCompletion` has two built in: LSP and fallback.
    - Supports snippet expansion.
    - Doesn't have customizable delays for basic actions.
    - Doesn't allow fallback action.
    - Doesn't provide signature help.

# Helpful key mappings~

To use `<Tab>` and `<S-Tab>` for navigation through completion list, make
these key mappings:
`vim.api.nvim_set_keymap('i', '<Tab>',   [[pumvisible() ? "\<C-n>" : "\<Tab>"]],   { noremap = true, expr = true })`
`vim.api.nvim_set_keymap('i', '<S-Tab>', [[pumvisible() ? "\<C-p>" : "\<S-Tab>"]], { noremap = true, expr = true })`

To get more consistent behavior of `<CR>`, you can use this template in
your 'init.lua' to make customized mapping: >
  local keys = {
    ['cr']        = vim.api.nvim_replace_termcodes('<CR>', true, true, true),
    ['ctrl-y']    = vim.api.nvim_replace_termcodes('<C-y>', true, true, true),
    ['ctrl-y_cr'] = vim.api.nvim_replace_termcodes('<C-y><CR>', true, true, true),
  }

  _G.cr_action = function()
    if vim.fn.pumvisible() ~= 0 then
      -- If popup is visible, confirm selected item or add new line otherwise
      local item_selected = vim.fn.complete_info()['selected'] ~= -1
      return item_selected and keys['ctrl-y'] or keys['ctrl-y_cr']
    else
      -- If popup is not visible, use plain `<CR>`. You might want to customize
      -- according to other plugins. For example, to use 'mini.pairs', replace
      -- next line with `return require('mini.pairs').cr()`
      return keys['cr']
    end
  end

  vim.api.nvim_set_keymap('i', '<CR>', 'v:lua._G.cr_action()', { noremap = true, expr = true })
<
# Highlight groups~

* `MiniCompletionActiveParameter` - highlighting of signature active parameter.
  By default displayed as plain underline.

To change any highlight group, modify it directly with |:highlight|.

# Disabling~

To disable, set `g:minicompletion_disable` (globally) or
`b:minicompletion_disable` (for a buffer) to `v:true`. Considering high
number of different scenarios and customization intentions, writing exact
rules for disabling module's functionality is left to user. See
|mini.nvim-disabling-recipes| for common recipes.

------------------------------------------------------------------------------
                                                        *MiniCompletion.setup()*
                        `MiniCompletion.setup`({config})
Module setup

Parameters~
{config} `(table)` Module config table. See |MiniCompletion.config|.

Usage~
`require('mini.completion').setup({})` (replace `{}` with your `config` table)

------------------------------------------------------------------------------
                                                         *MiniCompletion.config*
                            `MiniCompletion.config`
Module config

Default values:
>
  MiniCompletion.config = {
    -- Delay (debounce type, in ms) between certain Neovim event and action.
    -- This can be used to (virtually) disable certain automatic actions by
    -- setting very high delay time (like 10^7).
    delay = { completion = 100, info = 100, signature = 50 },

    -- Maximum dimensions of floating windows for certain actions. Action
    -- entry should be a table with 'height' and 'width' fields.
    window_dimensions = {
      info = { height = 25, width = 80 },
      signature = { height = 25, width = 80 },
    },

    -- Way of how module does LSP completion
    lsp_completion = {
      -- `source_func` should be one of 'completefunc' or 'omnifunc'.
      source_func = 'completefunc',

      -- `auto_setup` should be boolean indicating if LSP completion is set up
      -- on every `BufEnter` event.
      auto_setup = true,

      -- `process_items` should be a function which takes LSP
      -- 'textDocument/completion' response items and word to complete. Its
      -- output should be a table of the same nature as input items. The most
      -- common use-cases are custom filtering and sorting. You can use
      -- default `process_items` as `MiniCompletion.default_process_items()`.
      process_items = --<function: filters out snippets; sorts by LSP specs>,
    },

    -- Fallback action. It will always be run in Insert mode. To use Neovim's
    -- built-in completion (see `:h ins-completion`), supply its mapping as
    -- string. Example: to use 'whole lines' completion, supply '<C-x><C-l>'.
    fallback_action = --<function: like `<C-n>` completion>,

    -- Module mappings. Use `''` (empty string) to disable one. Some of them
    -- might conflict with system mappings.
    mappings = {
      force_twostep = '<C-Space>', -- Force two-step completion
      force_fallback = '<A-Space>', -- Force fallback completion
    },

    -- Whether to set Vim's settings for better experience (modifies
    -- `shortmess` and `completeopt`)
    set_vim_settings = true,
  }
<

------------------------------------------------------------------------------
                                              *MiniCompletion.auto_completion()*
                       `MiniCompletion.auto_completion`()
Auto completion

Designed to be used with |autocmd|. No need to use it directly, everything
is setup in |MiniCompletion.setup|.

------------------------------------------------------------------------------
                                            *MiniCompletion.complete_twostage()*
            `MiniCompletion.complete_twostage`({fallback}, {force})
Run two-stage completion

Parameters~
{fallback} `(boolean)` Whether to use fallback completion.
{force} `(boolean)` Whether to force update of completion popup.

------------------------------------------------------------------------------
                                            *MiniCompletion.complete_fallback()*
                      `MiniCompletion.complete_fallback`()
Run fallback completion

------------------------------------------------------------------------------
                                                    *MiniCompletion.auto_info()*
                          `MiniCompletion.auto_info`()
Auto completion entry information

Designed to be used with |autocmd|. No need to use it directly, everything
is setup in |MiniCompletion.setup|.

------------------------------------------------------------------------------
                                               *MiniCompletion.auto_signature()*
                       `MiniCompletion.auto_signature`()
Auto function signature

Designed to be used with |autocmd|. No need to use it directly, everything
is setup in |MiniCompletion.setup|.

------------------------------------------------------------------------------
                                                         *MiniCompletion.stop()*
                        `MiniCompletion.stop`({actions})
Stop actions

This stops currently active (because of module delay or LSP answer delay)
actions.

Designed to be used with |autocmd|. No need to use it directly, everything
is setup in |MiniCompletion.setup|.

Parameters~
{actions} `(table)` Array containing any of 'completion', 'info', or
  'signature' string.

------------------------------------------------------------------------------
                                            *MiniCompletion.on_text_changed_i()*
                      `MiniCompletion.on_text_changed_i`()
Act on every |TextChangedI|

------------------------------------------------------------------------------
                                            *MiniCompletion.on_text_changed_p()*
                      `MiniCompletion.on_text_changed_p`()
Act on every |TextChangedP|

------------------------------------------------------------------------------
                                             *MiniCompletion.completefunc_lsp()*
             `MiniCompletion.completefunc_lsp`({findstart}, {base})
Module's |complete-function|

This is the main function which enables two-stage completion. It should be
set as one of |completefunc| or |omnifunc|.

No need to use it directly, everything is setup in |MiniCompletion.setup|.

------------------------------------------------------------------------------
                                        *MiniCompletion.default_process_items()*
            `MiniCompletion.default_process_items`({items}, {base})
Default `MiniCompletion.config.lsp_completion.process_items`


==============================================================================
------------------------------------------------------------------------------
                                                               *mini.cursorword*
                                                                *MiniCursorword*
Minimal and fast module for autohighlighting word under cursor with
customizable delay. Current word under cursor can be highlighted
differently. Highlighting is triggered only if current cursor character is
a |[:keyword:]|. "Word under cursor" is meant as in Vim's |<cword>|:
something user would get as 'iw' text object. Highlighting stops in insert
and terminal modes.

# Setup~

This module needs a setup with `require('mini.cursorword').setup({})`
(replace `{}` with your `config` table). It will create global Lua table
`MiniCursorword` which you can use for scripting or manually (with
`:lua MiniCursorword.*`).

See |MiniCursorword.config| for `config` structure and default values.

# Highlight groups~

* `MiniCursorword` - highlight group of cursor word. Default: plain underline.
* `MiniCursorwordCurrent` - highlight group of a current word under
  cursor. It will be displayed on top of `MiniCursorword`
  (so `:hi clear MiniCursorwordCurrent` will lead to showing
  `MiniCursorword` highlight group). Note: To not highlight it, use
  `:hi! MiniCursorwordCurrent gui=nocombine guifg=NONE guibg=NONE` .

To change any highlight group, modify it directly with |:highlight|.

# Disabling~

To disable core functionality, set `g:minicursorword_disable` (globally) or
`b:minicursorword_disable` (for a buffer) to `v:true`. Considering high
number of different scenarios and customization intentions, writing exact
rules for disabling module's functionality is left to user. See
|mini.nvim-disabling-recipes| for common recipes. Note: after disabling
there might be highlighting left; it will be removed after next
highlighting update.

Module-specific disabling:
- Don't show highlighting if cursor is on the word that is in a blocklist
  of current filetype. In this example, blocklist for "lua" is "local" and
  "require" words, for "javascript" - "import":
>
  _G.cursorword_blocklist = function()
    local curword = vim.fn.expand('<cword>')
    local filetype = vim.api.nvim_buf_get_option(0, 'filetype')

    -- Add any disabling global or filetype-specific logic here
    local blocklist = {}
    if filetype == 'lua' then
      blocklist = { 'local', 'require' }
    elseif filetype == 'javascript' then
      blocklist = { 'import' }
    end

    vim.b.minicursorword_disable = vim.tbl_contains(blocklist, curword)
  end

  -- Make sure to add this autocommand *before* calling module's `setup()`.
  vim.cmd('au CursorMoved * lua _G.cursorword_blocklist()')

------------------------------------------------------------------------------
                                                        *MiniCursorword.setup()*
                        `MiniCursorword.setup`({config})
Module setup

Parameters~
{config} `(table)` Module config table. See |MiniCursorword.config|.

Usage~
`require('mini.cursorword').setup({})` (replace `{}` with your `config` table)

------------------------------------------------------------------------------
                                                         *MiniCursorword.config*
                            `MiniCursorword.config`
Module config

Default values:
>
  MiniCursorword.config = {
    -- Delay (in ms) between when cursor moved and when highlighting appeared
    delay = 100,
  }
<

------------------------------------------------------------------------------
                                               *MiniCursorword.auto_highlight()*
                       `MiniCursorword.auto_highlight`()
Auto highlight word under cursor

Designed to be used with |autocmd|. No need to use it directly,
everything is setup in |MiniCursorword.setup|.

------------------------------------------------------------------------------
                                             *MiniCursorword.auto_unhighlight()*
                      `MiniCursorword.auto_unhighlight`()
Auto unhighlight word under cursor

Designed to be used with |autocmd|. No need to use it directly, everything
is setup in |MiniCursorword.setup|.


==============================================================================
------------------------------------------------------------------------------
                                                                      *mini.doc*
                                                                       *MiniDoc*
Generation of help files from EmmyLua-like annotations

Key design ideas:
- Keep documentation next to code by writing EmmyLua-like annotation
  comments. They will be parsed as is, so formatting should follow built-in
  guide in |help-writing|. However, custom hooks are allowed at many
  generation stages for more granular management of output help file.
- Generation is done by processing a set of ordered files line by line.
  Each line can either be considered as a part of documentation block (if
  it matches certain configurable pattern) or not (considered to be an
  "afterline" of documentation block). See |MiniDoc.generate()| for more
  details.
- Processing is done by using nested data structures (section, block, file,
  doc) describing certain parts of help file. See |MiniDoc-data-structures|
  for more details.
- Project specific script can be written as plain Lua file with
  configuratble path. See |MiniDoc.generate()| for more details.

What it doesn't do:
- It doesn't support markdown or other markup language inside annotations.
- It doesn't use treesitter in favor of Lua string manipulation for basic
  tasks (parsing annotations, formatting, auto-generating tags, etc.). This
  is done to manage complexity and be dependency free.

# Setup~

This module needs a setup with `require('mini.doc').setup({})` (replace
`{}` with your `config` table). It will create global Lua table `MiniDoc`
which you can use for scripting or manually (with `:lua MiniDoc.*`). See
|MiniDoc.config| for available config settings.

# Tips~

- Some settings tips that might make writing annotation comments easier:
    - Set up appropriate 'comments' for `lua` file type to respect
      EmmyLua-like's `---` comment leader. Value `:---,:--` seems to work.
    - Set up appropriate 'formatoptions' (see also |fo-table|). Consider
      adding `j`, `n`, `q`, and `r` flags.
    - Set up appropriate 'formatlistpat' to help auto-formatting lists (if
      `n` flag is added to 'formatoptions'). One suggestion (not entirely
      ideal) is a value `^\s*[0-9\-\+\*]\+[\.\)]*\s\+`. This reads as 'at
      least one special character (digit, `-`, `+`, `*`) possibly followed
      by some punctuation (`.` or `)`) followed by at least one space is a
      start of list item'.
- Probably one of the most reliable resources for what is considered to be
  best practice when using this module is this whole plugin. Look at source
  code for the reference.

# Comparisons~

- 'tjdevries/tree-sitter-lua':
    - Its key design is to use treesitter grammar to parse both Lua code
      and annotation comments. This makes it not easy to install,
      customize, and support.
    - It takes more care about automating output formatting (like auto
      indentation and line width fit). This plugin leans more to manual
      formatting with option to supply customized post-processing hooks.

# Disabling~

To disable, set `g:minidoc_disable` (globally) or `b:minidoc_disable` (for
a buffer) to `v:true`. Considering high number of different scenarios and
customization intentions, writing exact rules for disabling module's
functionality is left to user. See |mini.nvim-disabling-recipes| for common
recipes.

------------------------------------------------------------------------------
                                                       *MiniDoc-data-structures*
Data structures

Data structures are basically arrays of other structures accompanied with
some fields (keys with data values) and methods (keys with function
values):
- `Section structure` is an array of string lines describing one aspect
  (determined by section id like '@param', '@return', '@text') of an
  annotation subject. All lines will be used directly in help file.
- `Block structure` is an array of sections describing one annotation
  subject like function, table, concept.
- `File structure` is an array of blocks describing certain file on disk.
  Basically, file is split into consecutive blocks: annotation lines go
  inside block, non-annotation - inside `block_afterlines` element of info.
- `Doc structure` is an array of files describing a final help file. Each
  string line from section (when traversed in depth-first fashion) goes
  directly into output file.

All structures have these keys:
- Fields:
    - `info` - contains additional information about current structure.
      For more details see next section.
    - `parent` - table of parent structure (if exists).
    - `parent_index` - index of this structure in its parent's array. Useful
      for adding to parent another structure near current one.
    - `type` - string with structure type (section, block, file, doc).
- Methods (use them as `x:method(args)`):
    - `insert(self, [index,] child)` - insert `child` to `self` at position
      `index` (optional; if not supplied, child will be appended to end).
      Basically, a `table.insert()`, but adds `parent` and `parent_index`
      fields to `child` while properly updating `self`.
    - `remove(self [,index])` - remove from `self` element at position
      `index`. Basically, a `table.remove()`, but properly updates `self`.
    - `has_descendant(self, predicate)` - whether there is a descendant
      (structure or string) for which `predicate` returns `true`. In case of
      success also returns the first such descendant as second value.
    - `has_lines(self)` - whether structure has any lines (even empty ones)
      to be put in output file. For section structures this is equivalent to
      `#self`, but more useful for higher order structures.
    - `clear_lines(self)` - remove all lines from structure. As a result,
      this structure won't contribute to output help file.

Description of `info` fields per structure type:
- `Section`:
    - `id` - captured section identifier. Can be empty string meaning no
      identifier is captured.
    - `line_begin` - line number inside file at which section begins (-1 if
      not generated from file).
    - `line_end` - line number inside file at which section ends (-1 if not
      generated from file).
- `Block`:
    - `afterlines` - array of strings which were parsed from file after
      this annotation block (up until the next block or end of file).
      Useful for making automated decisions about what is being documented.
    - `line_begin` - line number inside file at which block begins  (-1 if
      not generated from file).
    - `line_end` - line number inside file at which block ends  (-1 if not
      generated from file).
- `File`:
    - `path` - absolute path to a file (`''` if not generated from file).
- `Doc`:
    - `input` - array of input file paths (as in |MiniDoc.generate|).
    - `output` - output path (as in |MiniDoc.generate|).
    - `config` - configuration used (as in |MiniDoc.generate|).

------------------------------------------------------------------------------
                                                               *MiniDoc.setup()*
                           `MiniDoc.setup`({config})
Module setup

Parameters~
{config} `(table)` Module config table. See |MiniDoc.config|.

Usage~
`require('mini.doc').setup({})` (replace `{}` with your `config` table)

------------------------------------------------------------------------------
                                                                *MiniDoc.config*
                                `MiniDoc.config`
Module config

Default values:
>
  MiniDoc.config = {
    -- Function which extracts part of line used to denote annotation.
    -- For more information see 'Notes' in |MiniDoc.config|.
    annotation_extractor = function(l)
      return string.find(l, '^%-%-%-(%S*) ?')
    end,

    -- Identifier of block annotation lines until first captured identifier
    default_section_id = '@text',

    -- Hooks to be applied at certain stage of document life cycle. Should
    -- modify its input in place (and not return new one).
    hooks = {
      -- Applied to block before anything else
      block_pre = --<function: infers header sections (tag and/or signature)>,

      -- Applied to section before anything else
      section_pre = --<function: replaces current aliases>,

      -- Applied if section has specified captured id
      sections = {
        ['@alias'] = --<function: registers alias in MiniDoc.current.aliases>,
        ['@class'] = --<function>,
        ['@diagnostic'] = --<function: ignores any section content>,
        -- For most typical usage see |MiniDoc.afterlines_to_code|
        ['@eval'] = --<function: evaluates lines; replaces with their return>,
        ['@field'] = --<function>,
        ['@overload'] = --<function>,
        ['@param'] = --<function>,
        ['@private'] = --<function: registers block for removal>,
        ['@return'] = --<function>,
        ['@seealso'] = --<function>,
        ['@signature'] = --<function: formats signature of documented object>,
        ['@tag'] = --<function: turns its line in proper tag lines>,
        ['@text'] = --<function: purposefully does nothing>,
        ['@toc'] = --<function: clears all section lines>,
        ['@toc_entry'] = --<function: registers lines for table of contents>,
        ['@type'] = --<function>,
        ['@usage'] = --<function>,
      },

      -- Applied to section after all previous steps
      section_post = --<function: currently does nothing>,

      -- Applied to block after all previous steps
      block_post = --<function: does many things>,

      -- Applied to file after all previous steps
      file = --<function: adds separator>,

      -- Applied to doc after all previous steps
      doc = --<function: adds modeline>,

      -- Applied to after output help file is written. Takes doc as argument.
      write_post = --<function: various convenience actions>,
    },

    -- Path (relative to current directory) to script which handles project
    -- specific help file generation (like custom input files, hooks, etc.).
    script_path = 'scripts/minidoc.lua',
  }
<
# Notes ~

- `annotation_extractor` takes single string line as input. Output
  describes what makes an input to be an annotation (if anything). It
  should be similar to `string.find` with one capture group: start and end
  of annotation indicator (whole part will be removed from help line) with
  third value being string of section id (if input describes first line of
  section; `nil` or empty string otherwise). Output should be `nil` if line
  is not part of annotation.
  Default value means that annotation line should:
    - Start with `---` at first column.
    - Any non-whitespace after `---` will be treated as new section id.
    - Single whitespace at the start of main text will be ignored.
- Hooks are expected to be functions. Their default values might do many
  things which might change over time, so for more information please look
  at source code. Some more information can be found in
  |MiniDoc.default_hooks|.

------------------------------------------------------------------------------
                                                               *MiniDoc.current*
                               `MiniDoc.current`
Table with information about current state of auto-generation

It is reset at the beginning and end of `MiniDoc.generate()`.

At least these keys are supported:
- {aliases} - table with keys being alias name and values - alias
  description and single string (using `\n` to separate lines).
- {eval_section} - input section of `@eval` section hook. Can be used for
  information about current block, etc.
- {toc} - array with table of contents entries. Each entry is a whole
  `@toc_entry` section.

------------------------------------------------------------------------------
                                                         *MiniDoc.default_hooks*
                            `MiniDoc.default_hooks`
Default hooks

This is default value of `MiniDoc.config.hooks`. Use it if only a little
tweak is needed.

Some more insight about their behavior:
- Default inference of documented object metadata (tag and object signature
  at the moment) is done in `block_pre`. Inference is based on string
  pattern matching, so can lead to false results, although works in most
  cases. It intentionally works only if first line after block has no
  indentation and contains all necessary information to determine if
  inference should happen.
- Hooks for sections describing some "variable-like" object ('@class',
  '@field', '@param') automatically enclose first word in '{}'.
- Hooks for sections which supposed to have "type-like" data ('@field',
  '@param', '@return', '@type') automatically enclose *first found*
  "type-like" word and its neighbor characters in '`(<type>)`' (expect
  false positives). Algoritm is far from being 100% correct, but seems to
  work with present allowed type annotation. For allowed types see
  https://github.com/sumneko/lua-language-server/wiki/EmmyLua-Annotations#types-and-type
  or, better yet, look in source code of this module.
- Automated creation of table of contents (TOC) is done in the following way:
    - Put section with `@toc_entry` id in the annotation block. Section's
      lines will be registered as TOC entry.
    - Put `@toc` section where you want to insert rendered table of
      contents. TOC entries will be inserted on the left, references for
      their respective tag section (only first, if present) on the right.
      Render is done in default `doc` hook (because it should be done after
      processing all files).
- The `write_post` hook executes some actions convenient for iterative
  annotations writing:
    - Generate `:helptags` for directory containing output file.
    - Silently reload buffer containing output file (if such exists).
    - Display notification message about result.

------------------------------------------------------------------------------
                                                            *MiniDoc.generate()*
                `MiniDoc.generate`({input}, {output}, {config})
Generate help file

# Algoritm~

- Main parameters for help generation are an array of input file paths and
  path to output help file.
- Parse all inputs:
  - For each file, lines are processed top to bottom in order to create an
    array of documentation blocks. Each line is tested whether it is an
    annotation by applying `MiniDoc.config.annotation_extractor`: if
    anything is extracted, it is considered to be an annotation. Annotation
    line goes to "current block" after removing extracted annotation
    indicator, otherwise - to afterlines of "current block".
  - Each block's annotation lines are processed top to bottom. If line had
    captured section id, it is a first line of "current section" (first
    block lines are allowed to not specify section id; by default it is
    `@text`). All subsequent lines without captured section id go into
    "current section".
- Apply structure hooks (they should modify its input in place, which is
  possible due to 'table nature' of all inputs):
    - Each block is processed by `MiniDoc.config.hooks.block_pre`. This is a
      designated step for auto-generation of sections from descibed
      annotation subject (like sections with id `@tag`, `@type`).
    - Each section is processed by `MiniDoc.config.hooks.section_pre`.
    - Each section is processed by corresponding
      `MiniDoc.config.hooks.sections` function (table key equals to section
      id). This is a step where most of formatting should happen (like
      wrap first word of `@param` section with `{` and `}`, append empty
      line to section, etc.).
    - Each section is processed by `MiniDoc.config.hooks.section_post`.
    - Each block is processed by `MiniDoc.config.hooks.block_post`. This is
      a step for processing block after formatting is done (like add first
      line with `----` delimiter).
    - Each file is processed by `MiniDoc.config.hooks.file`. This is a step
      for adding any file-related data (like add first line with `====`
      delimiter).
    - Doc is processed by `MiniDoc.config.hooks.doc`. This is a step for
      adding any helpfile-related data (maybe like table of contents).
- Collect all strings from sections in depth-first fashion (equivalent to
  nested "for all files -> for all blocks -> for all sections -> for all
  strings -> add string to output") and write them to output file. Strings
  can have `\n` character indicating start of new line.
- Execute `MiniDoc.config.write_post` hook. This is useful for showing some
  feedback and making actions involving newly updated help file (like
  generate tags, etc.).

# Project specific script~

If all arguments have default `nil` values, first there is an attempt to
source project specific script. This is basically a `luafile
<MiniDoc.config.script_path>` with current Lua runtime while caching and
restoring current `MiniDoc.config`. Its successful execution stops any
further generation actions while error means proceeding generation as if no
script was found.

Typical script content might include definition of custom hooks, input and
output files with eventual call to `require('mini.doc').generate()` (with
or without arguments).

Parameters~
{input} `(table)` Array of file paths which will be processed in supplied
  order. Default: all '.lua' files from current directory following by all
  such files in these subdirectories: 'lua/', 'after/', 'colors/'. Note:
  any 'init.lua' file is placed before other files from the same directory.
{output} `(string)` Path for output help file. Default:
  `doc/<current_directory>.txt` (designed to be used for generating help
  file for plugin).
{config} `(table)` Configuration overriding parts of |MiniDoc.config|.

Return~
`(table)` Document structure which was generated and used for output
  help file. In case `MiniDoc.config.script_path` was successfully used,
  this is a return from the latest call of this function.

------------------------------------------------------------------------------
                                                  *MiniDoc.afterlines_to_code()*
                     `MiniDoc.afterlines_to_code`({struct})
Convert afterlines to code

This function is designed to be used together with `@eval` section to
automate documentation of certain values (notable default values of a
table). It processes afterlines based on certain directives and makes
output looking like a code block.

Most common usage is by adding the following section in your annotation:
`@eval return MiniDoc.afterlines_to_code(MiniDoc.current.eval_section)`

# Directives ~
Directives are special comments that are processed using Lua string pattern
capabilities (so beware of false positives). Each directive should be put
on its separate line. Supported directives:
- `--minidoc_afterlines_end` denotes a line at afterlines end. Only all
  lines before it will be considered as afterlines. Useful if there is
  extra code in afterlines which shouldn't be used.
- `--minidoc_replace_start <replacement>` and `--minidoc_replace_end`
  denote lines between them which should be replaced with `<replacement>`.
  Useful for manually changing what should be placed in output like in case
  of replacing function body with something else.

Here is an example. Suppose having these afterlines:
>
  --minidoc_replace_start {
  M.config = {
    --minidoc_replace_end
    param_one = 1,
    --minidoc_replace_start param_fun = --<function>
    param_fun = function(x)
      return x + 1
    end
    --minidoc_replace_end
  }
  --minidoc_afterlines_end

  return M
<

After adding `@eval` section those will be formatted as:
>
  {
    param_one = 1,
    param_fun = --<function>
  }
<
Parameters~
{struct} `(table)` Block or section structure which after lines will be
  converted to code.

Return~
`(string)` Single string (using `\n` to separate lines) describing
  afterlines as code block in help file.


==============================================================================
------------------------------------------------------------------------------
                                                                    *mini.fuzzy*
                                                                     *MiniFuzzy*
Lua module which implements minimal and fast fuzzy matching.

# Setup~

This module doesn't need setup, but it can be done to improve usability.
Setup with `require('mini.fuzzy').setup({})` (replace `{}` with your
`config` table). It will create global Lua table `MiniFuzzy` which you can
use for scripting or manually (with `:lua MiniFuzzy.*`).

See |MiniFuzzy.config| for `config` structure and default values.

# Notes~

1. Currently there is no explicit design to work with multibyte symbols,
   but simple examples should work.
2. Smart case is used: case insensitive if input word (which is usually a
    user input) is all lower ase. Case sensitive otherwise.

------------------------------------------------------------------------------
                                                           *MiniFuzzy-algorithm*
# Algorithm design~

General design uses only width of found match and index of first letter
match. No special characters or positions (like in fzy and fzf) are used.

Given input `word` and target `candidate`:
- The goal is to find matching between `word`'s letters and letters in
  `candidate`, which minimizes certain score. It is assumed that order of
  letters in `word` and those matched in `candidate` should be the same.
- Matching is represented by matched positions: an array `positions` of
  integers with length equal to number of letters in `word`. The following
  should be always true in case of a match: `candidate`'s letter at index
  `positions[i]` is letters[i]` for all valid `i`.
- Matched positions are evaluated based only on two features: their width
  (number of indexes between first and last positions) and first match
  (index of first letter match). There is a global setting `cutoff` for
  which all feature values greater than it can be considered "equally bad".
- Score of matched positions is computed with following explicit formula:
  `cutoff * min(width, cutoff) + min(first, cutoff)`. It is designed to be
  equivalent to first comparing widths (lower is better) and then comparing
  first match (lower is better). For example, if `word = 'time'`:
    - '_time' (width 4) will have a better match than 't_ime' (width 5).
    - 'time_a' (width 4, first 1) will have a better match than 'a_time'
      (width 4, first 3).
- Final matched positions are those which minimize score among all possible
  matched positions of `word` and `candidate`.

------------------------------------------------------------------------------
                                                             *MiniFuzzy.setup()*
                          `MiniFuzzy.setup`({config})
Module setup

Parameters~
{config} `(table)` Module config table. See |MiniFuzzy.config|.

Usage~
`require('mini.fuzzy').setup({})` (replace `{}` with your `config` table)

------------------------------------------------------------------------------
                                                              *MiniFuzzy.config*
                               `MiniFuzzy.config`
Module config

Default values:
>
  MiniFuzzy.config = {
    -- Maximum allowed value of match features (width and first match). All
    -- feature values greater than cutoff can be considered "equally bad".
    cutoff = 100,
  }
<

------------------------------------------------------------------------------
                                                             *MiniFuzzy.match()*
                     `MiniFuzzy.match`({word}, {candidate})
Compute match data of input `word` and `candidate` strings

It tries to find best match for input string `word` (usually user input)
and string `candidate`. Returns table with elements:
- `positions` - array with letter indexes inside `candidate` which
  matched to corresponding letters in `word`. Or `nil` if no match.
- `score` - positive number representing how good the match is (lower is
  better). Or `-1` if no match.

Parameters~
{word} `(string)` Input word (usually user input).
{candidate} `(string)` Target word (usually with which matching is done).

Return~
`(table)` Table with matching information (see function's description).

------------------------------------------------------------------------------
                                                        *MiniFuzzy.filtersort()*
               `MiniFuzzy.filtersort`({word}, {candidate_array})
Filter string array

This leaves only those elements of input array which matched with `word`
and sorts from best to worst matches (based on score and index in original
array, both lower is better).

Parameters~
{word} `(string)` String which will be searched.
{candidate_array} `(table)` Lua array of strings inside which word will be
  searched.

Return~
`(...)` Arrays of matched candidates and their indexes in original input.

------------------------------------------------------------------------------
                                                 *MiniFuzzy.process_lsp_items()*
                 `MiniFuzzy.process_lsp_items`({items}, {base})
Fuzzy matching for |MiniCompletion.lsp_completion.process_items|

Parameters~
{items} `(table)` Lua array with LSP 'textDocument/completion' response items.
{base} `(string)` Word to complete.

------------------------------------------------------------------------------
                                              *MiniFuzzy.get_telescope_sorter()*
                    `MiniFuzzy.get_telescope_sorter`({opts})
Custom getter for `telescope.nvim` sorter

Designed to be used as value for |telescope.defaults.file_sorter| and
|telescope.defaults.generic_sorter| inside `setup()` call.

Parameters~
{opts} `(table)` Options (currently not used).

Usage~
>
  require('telescope').setup({
    defaults = {
      generic_sorter = require('mini.fuzzy').get_telescope_sorter
    }
  })


==============================================================================
------------------------------------------------------------------------------
                                                              *mini.indentscope*
                                                               *MiniIndentscope*
Visualize and operate on indent scope

Indent scope (or just "scope") is a maximum set of consecutive lines which
contains certain reference line (cursor line by default) and every member
has indent not less than certain reference indent ("indent at cursor" by
default: minimum between cursor column and indent of cursor line).

Features:
- Visualize scope with vertical line. It is very fast and done
  automatically in a non-blocking way (other operations can be performed,
  like moving cursor). You can customize debounce delay and animation rule.
- Customization of scope computation options can be done on global level
  (in |MiniIndentscope.config|), for a certain buffer (using
  `vim.b.miniindentscope_options` buffer variable), or within a call (using
  `opts` variable in |MiniIndentscope.get_scope|).
- Customizable notion of a border: which adjacent lines with strictly lower
  indent are recognized as such. This is useful for a certain filetypes
  (for example, Python or plain text).
- Customizable way of line to be considered "border first". This is useful
  if you want to place cursor on function header and get scope of its body.
- There are textobjects and motions to operate on scope. Support |count|
  and dot-repeat (in operator pending mode).

# Setup~

This module needs a setup with `require('mini.indentscope').setup({})`
(replace `{}` with your `config` table). It will create global Lua table
`MiniIndentscope` which you can use for scripting or manually (with `:lua
MiniIndentscope.*`). See |MiniIndentscope.config| for available config
settings.

# Comparisons~

- 'lukas-reineke/indent-blankline.nvim':
    - Its main functionality is about showing static guides of indent levels.
    - Implementation of 'mini.indentscope' is similar to
      'indent-blankline.nvim' (using |extmarks| on first column to be shown
      even on blank lines). They can be used simultaneously, but it will
      lead to one of the visualizations being on top (hiding) of another.

# Highlight groups~

* `MiniIndentscopeSymbol` - symbol showing on every line of scope.
* `MiniIndentscopePrefix` - space before symbol. By default made so as to
  appear as nothing is displayed.

To change any highlight group, modify it directly with |:highlight|.

# Disabling~

To disable autodrawing, set `g:miniindentscope_disable` (globally) or
`b:miniindentscope_disable` (for a buffer) to `v:true`. Considering high
number of different scenarios and customization intentions, writing exact
rules for disabling module's functionality is left to user. See
|mini.nvim-disabling-recipes| for common recipes.

------------------------------------------------------------------------------
                                                       *MiniIndentscope-drawing*
Drawing of scope indicator

Draw of scope indicator is done as iterative animation. It has the
following design:
- Draw indicator on origin line (where cursor is at) immediately. Indicator
  is visualized as `MiniIndentscope.config.symbol` placed to the right of
  scope's border indent. This creates a line from top to bottom scope edges.
- Draw upward and downward concurrently per one line. Progression by one
  line in both direction is considered to be one step of animation.
- Before each step wait certain amount of time, which is decided by
  "animation function". It takes next and total step numbers (both are one
  or bigger) and returns number of milliseconds to wait before drawing next
  step. Comparing to a more popular "easing functions" in animation (input:
  duration since animation start; output: percent of animation done), it is
  a discrete inverse version of its derivative. Such interface proved to be
  more appropriate for kind of task at hand.

Special cases~

- When scope to be drawn intersects (same indent, ranges overlap) currently
  visible one (at process or finished drawing), drawing is done immediately
  without animation. With most common example being typing new text, this
  feels more natural.
- Scope for the whole buffer is not drawn as it is isually redundant.
  Technically, it can be thought as drawn at column 0 (because border
  indent is -1) which is not visible.

------------------------------------------------------------------------------
                                                       *MiniIndentscope.setup()*
                       `MiniIndentscope.setup`({config})
Module setup

Parameters~
{config} `(table)` Module config table. See |MiniIndentscope.config|.

Usage~
`require('mini.indentscope').setup({})` (replace `{}` with your `config` table)

------------------------------------------------------------------------------
                                                        *MiniIndentscope.config*
                            `MiniIndentscope.config`
Module config

Default values:
>
  MiniIndentscope.config = {
    draw = {
      -- Delay (in ms) between event and start of drawing scope indicator
      delay = 100,

      -- Animation rule for scope's first drawing. A function which, given next
      -- and total step numbers, returns wait time (in ms). See
      -- |MiniIndentscope.gen_animation()| for builtin options. To not use
      -- animation, supply `require('mini.indentscope').gen_animation('none')`.
      animation = --<function: implements constant 20ms between steps>,
    },

    -- Module mappings. Use `''` (empty string) to disable one.
    mappings = {
      -- Textobjects
      object_scope = 'ii',
      object_scope_with_border = 'ai',

      -- Motions (jump to respective border line; if not present - body line)
      goto_top = '[i',
      goto_bottom = ']i',
    },

    -- Options which control computation of scope. Buffer local values can be
    -- supplied in buffer variable `vim.b.miniindentscope_options`.
    options = {
      -- Type of scope's border: which line(s) with smaller indent to
      -- categorize as border. Can be one of: 'both', 'top', 'bottom', 'none'.
      border = 'both',

      -- Whether to use cursor column when computing reference indent. Useful to
      -- see incremental scopes with horizontal cursor movements.
      indent_at_cursor = true,

      -- Whether to first check input line to be a border of adjacent scope.
      -- Use it if you want to place cursor on function header to get scope of
      -- its body.
      try_as_border = false,
    },

    -- Which character to use for drawing scope indicator
    symbol = '╎',
  }
<
# Options ~

- Options can be supplied globally (from this `config`), locally to buffer
  (via `vim.b.miniindentscope_options` buffer variable), or locally to call
  (as argument to |MiniIndentscope.get_scope()|).

- Option `border` controls which line(s) with smaller indent to categorize
  as border. This matters for textobjects and motions.
  It also controls how empty lines are treated: they are included in scope
  only if followed by a border. Another way of looking at it is that indent
  of blank line is computed based on value of `border` option.
  Here is an illustration of how `border` works in presense of empty lines:
>
                             |both|bottom|top|none|
  1|function foo()           | 0  |  0   | 0 | 0  |
  2|                         | 4  |  0   | 4 | 0  |
  3|    print('Hello world') | 4  |  4   | 4 | 4  |
  4|                         | 4  |  4   | 2 | 2  |
  5|  end                    | 2  |  2   | 2 | 2  |
<
  Numbers inside a table are indent values of a line computed with certain
  value of `border`. So, for example, a scope with reference line 3 and
  right-most column has body range depending on value of `border` option:
    - `border` is "both":   range is 2-4, border is 1 and 5 with indent 2.
    - `border` is "top":    range is 2-3, border is 1 with indent 0.
    - `border` is "bottom": range is 3-4, border is 5 with indent 0.
    - `border` is "none":   range is 3-3, border is empty with indent `nil`.

- Option `indent_at_cursor` controls if cursor position should affect
  computation of scope. If `true`, reference indent is a minimum of
  reference line's indent and cursor column. In main example, here how
  scope's body range differs depending on cursor column and `indent_at_cursor`
  value (assuming cursor is on line 3 and it is whole buffer):
>
    Column\Option true|false
       1 and 2    2-5 | 2-4
     3 and more   2-4 | 2-4
<
- Option `try_as_border` controls how to act when input line can be
  recognized as a border of some neighbor indent scope. In main example,
  when input line is 1 and can be recognized as border for inner scope,
  value `try_as_border = true` means that inner scope will be returned.
  Similar, for input line 5 inner scope will be returned if it is
  recognized as border.

------------------------------------------------------------------------------
                                                   *MiniIndentscope.get_scope()*
               `MiniIndentscope.get_scope`({line}, {col}, {opts})
Compute indent scope

Indent scope (or just "scope") is a maximum set of consecutive lines which
contains certain reference line (cursor line by default) and every member
has indent not less than certain reference indent ("indent at column" by
default). Here "indent at column" means minimum between input column value
and indent of reference line. When using cursor column, this allows for a
useful interactive view of nested indent scopes by making horizontal
movements within line.

Options controlling actual computation is taken from these places in order:
- Argument `opts`. Use it to ensure independence from other sources.
- Buffer local variable `vim.b.miniindentscope_options`. Useful to define
  behavior inside some autocommand (for example, for a certain filetype).
- Global options from |MiniIndentscope.config|.

Algorithm overview~

- Compute reference "indent at column". Reference line is an input `line`
  which might be modified to one of its neighbors if `try_as_border` option
  is `true`: if it can be viewed as border of some neighbor scope, it will.
- Process upwards and downwards from reference line to search for line with
  indent strictly less than reference one. This is like casting rays up and
  down from reference line and reference indent until meeting "a wall"
  (character to the right of indent or buffer edge). Latest line before
  meeting is a respective end of scope body. It always exists because
  reference line is a such one.
- Based on top and bottom lines with strictly lower indent, construct
  scopes's border. The way it is computed is decided based on `border`
  option (see |MiniIndentscope.config| for more information).
- Compute border indent as maximum indent of border lines (or reference
  indent minus one in case of no border). This is used during drawing
  visual indicator.

Indent computation~

For every line indent is intended to be computed unambiguously:
- For "normal" lines indent is an output of |indent()|.
- Indent is `-1` for imaginary lines 0 and past last line.
- For blank and empty lines indent is computed based on previous
  (|prevnonblank()|) and next (|nextnonblank()|) non-blank lines. The way
  it is computed is decided based on `border` in order to not include blank
  lines at edge of scope's body if there is no border there. See
  |MiniIndentscope.config| for a details example.

Parameters~
{line} `(number)` Input line number (starts from 1). Can be modified to a
  neighbor if `try_as_border` is `true`. Default: cursor line.
{col} `(number)` Column number (starts from 1). Default: if
  `indent_at_cursor` option is `true` - cursor column from `curswant` of
  |getcurpos()| (allows for more natural behavior on empty lines);
  `math.huge` otherwise in order to not incorporate cursor in computation.
{opts} `(table)` Options to override global or buffer local ones (see
  |MiniIndentscope.config|).

Return~
`(table)` Table with scope information:
  - <body> - table with <top> (top line of scope, inclusive), <bottom>
    (bottom line of scope, inclusive), and <indent> (minimum indent withing
    scope) keys. Line numbers start at 1.
  - <border> - table with <top> (line of top border, might be `nil`),
    <bottom> (line of bottom border, might be `nil`), and <indent> (indent
    of border) keys. Line numbers start at 1.
  - <buf_id> - identifier of current buffer.
  - <reference> - table with <line> (reference line), <column> (reference
    column), and <indent> ("indent at column") keys.

------------------------------------------------------------------------------
                                                   *MiniIndentscope.auto_draw()*
                      `MiniIndentscope.auto_draw`({opts})
Auto draw scope indicator based on movement events

Designed to be used with |autocmd|. No need to use it directly, everything
is setup in |MiniIndentscope.setup|.

Parameters~
{opts} `(table)` Options.

------------------------------------------------------------------------------
                                                        *MiniIndentscope.draw()*
                    `MiniIndentscope.draw`({scope}, {opts})
Draw scope manually

Scope is visualized as a vertical line withing scope's body range at column
equal to border indent plus one (or body indent if border is absent).
Numbering starts from one.

Parameters~
{scope} `(table)` Scope. Default: output of |MiniIndentscope.get_scope|
  with default arguments.
{opts} `(table)` Options. Currently supported:
   - <animation_fun> - animation function for drawing. See
     |MiniIndentscope-drawing| and |MiniIndentscope.gen_animation()|.

------------------------------------------------------------------------------
                                                      *MiniIndentscope.undraw()*
                           `MiniIndentscope.undraw`()
Undraw currently visible scope manually

------------------------------------------------------------------------------
                                               *MiniIndentscope.gen_animation()*
               `MiniIndentscope.gen_animation`({easing}, {opts})
Generate builtin animation function

This is a builtin source to generate animation function for usage in
`MiniIndentscope.config.draw.animation`. Most of them are variations of
common easing functions, which provide certain type of progression for
revealing scope visual indicator.

Supported easing types:
- `'none'` - show indicator immediately. Equivalent to animation function
  always returning 0.
- `'linear'` - linear progression.
- Quadratic progression:
    - `'quadraticIn'` - accelerating from zero speed.
    - `'quadraticOut'` - decelerating to zero speed.
    - `'quadraticInOut'` - accelerating halfway, decelerating after.
- Cubic progression:
    - `'cubicIn'` - accelerating from zero speed.
    - `'cubicOut'` - decelerating to zero speed.
    - `'cubicInOut'` - accelerating halfway, decelerating after.
- Quartic progression:
    - `'quarticIn'` - accelerating from zero speed.
    - `'quarticOut'` - decelerating to zero speed.
    - `'quarticInOut'` - accelerating halfway, decelerating after.
- Exponential progression:
    - `'exponentialIn'` - accelerating from zero speed.
    - `'exponentialOut'` - decelerating to zero speed.
    - `'exponentialInOut'` - accelerating halfway, decelerating after.

Customization of duration and other general behavior of output animation
function is done through `opts` argument.

Parameters~
{easing} `(string)` One of supported easing types.
{opts} `(table)` Options that control progression. Possible keys:
  - <duration> `(number)` - duration (in ms) of a unit. Default: 20.
  - <unit> `(string)` - which unit's duration `opts.duration` controls. One
    of "step" (default; ensures average duration of step to be `opts.duration`)
    or "total" (ensures fixed total duration regardless of scope's range).

Return~
`(function)` Animation function (see |MiniIndentscope-drawing|).

Examples~
- Don't use animation: `gen_animation('none')`
- Use quadratic "out" easing with total duration of 1000 ms:
  `gen_animation('quadraticOut', { duration = 1000, unit = 'total' })`

See also~
|MiniIndentscope-drawing| for more information about how drawing is done.

------------------------------------------------------------------------------
                                                 *MiniIndentscope.move_cursor()*
          `MiniIndentscope.move_cursor`({side}, {use_border}, {scope})
Move cursor within scope

Cursor is placed on a first non-blank character of target line.

Parameters~
{side} `(string)` One of "top" or "bottom".
{use_border} `(boolean)` Whether to move to border or withing scope's body.
  If particular border is absent, body is used.
{scope} `(table)` Scope to use. Default: output of |MiniIndentscope.get_scope()|.

------------------------------------------------------------------------------
                                                    *MiniIndentscope.operator()*
             `MiniIndentscope.operator`({side}, {add_to_jumplist})
Function for motion mappings

Move to a certain side of border. Respects |count| and dot-repeat (in
operator-pending mode). Doesn't move cursor for scope that is not shown
(drawing indent less that zero).

Parameters~
{side} `(string)` One of "top" or "bottom".
{add_to_jumplist} `(boolean)` Whether to add movement to jump list. It is
  `true` only for Normal mode mappings.

------------------------------------------------------------------------------
                                                  *MiniIndentscope.textobject()*
                   `MiniIndentscope.textobject`({use_border})
Function for textobject mappings

Respects |count| and dot-repeat (in operator-pending mode). Doesn't work
for scope that is not shown (drawing indent less that zero).

Parameters~
{use_border} `(boolean)` Whether to include border in textobject. When
  `true` and `try_as_border` option is `false`, allows "chaining" calls for
  incremental selection.


==============================================================================
------------------------------------------------------------------------------
                                                                     *mini.jump*
                                                                      *MiniJump*
Minimal and fast module for smarter jumping to a single character. Inspired
by 'rhysd/clever-f.vim'.

Features:
- Extend f, F, t, T to work on multiple lines.
- Repeat jump by pressing f, F, t, T again. It is reset when cursor moved
  as a result of not jumping or timeout after idle time (duration
  customizable).
- Highlight (after customizable delay) of all possible target characters.
- Normal, Visual, and Operator-pending (with full dot-repeat) modes are
  supported.

# Setup~

This module needs a setup with `require('mini.jump').setup({})`
(replace `{}` with your `config` table). It will create global Lua table
`MiniJump` which you can use for scripting or manually (with
`:lua MiniJump.*`).

See |MiniJump.config| for `config` structure and default values.

# Highlight groups~

* `MiniJump` - all possible cursor positions.

To change any highlight group, modify it directly with |:highlight|.

# Disabling~

To disable core functionality, set `g:minijump_disable` (globally) or
`b:minijump_disable` (for a buffer) to `v:true`. Considering high number of
different scenarios and customization intentions, writing exact rules for
disabling module's functionality is left to user. See
|mini.nvim-disabling-recipes| for common recipes.

------------------------------------------------------------------------------
                                                              *MiniJump.setup()*
                           `MiniJump.setup`({config})
Module setup

Parameters~
{config} `(table)` Module config table. See |MiniJump.config|.

Usage~
`require('mini.jump').setup({})` (replace `{}` with your `config` table)

------------------------------------------------------------------------------
                                                               *MiniJump.config*
                               `MiniJump.config`
Module config

Default values:
>
  MiniJump.config = {
    -- Module mappings. Use `''` (empty string) to disable one.
    mappings = {
      forward = 'f',
      backward = 'F',
      forward_till = 't',
      backward_till = 'T',
      repeat_jump = ';',
    },

    -- Delay values (in ms) for different functionalities. Set any of them to
    -- a very big number (like 10^7) to virtually disable.
    delay = {
      -- Delay between jump and highlighting all possible jumps
      highlight = 250,

      -- Delay between jump and automatic stop if idle (no jump is done)
      idle_stop = 10000000,
    },
  }
<

------------------------------------------------------------------------------
                                                                *MiniJump.state*
                                `MiniJump.state`
Data about jumping state

It stores various information used in this module. All elements, except
`jumping`, is about the latest jump. They are used as default values for
similar arguments.

Class~
{JumpingState}

Fields~
{target} `(string)` The string to jump to.
{backward} `(boolean)` Whether to jump backward.
{till} `(boolean)` Whether to jump just before/after the match instead of
  exactly on target. Also ignore matches that have nothing before/after them.
{n_times} `(number)` Number of times to perform consecutive jumps.
{mode} `(string)` Mode of latest jump (output of |mode()| with non-zero argument).
{jumping} `(boolean)` Whether module is currently in "jumping mode": usage of
  |MiniJump.smart_jump| and all mappings won't require target.

Initial values:
>
  MiniJump.state = {
    target = nil,
    backward = false,
    till = false,
    n_times = 1,
    mode = nil,
    jumping = false,
  }
<

------------------------------------------------------------------------------
                                                               *MiniJump.jump()*
            `MiniJump.jump`({target}, {backward}, {till}, {n_times})
Jump to target

Takes a string and jumps to its first occurrence in desired direction.

All default values are taken from |MiniJump.state| to emulate latest jump.

Parameters~
{target} `(string)` The string to jump to.
{backward} `(boolean)` Whether to jump backward.
{till} `(boolean)` Whether to jump just before/after the match instead of
  exactly on target. Also ignore matches that have nothing before/after them.
{n_times} `(number)` Number of times to perform consecutive jumps.

------------------------------------------------------------------------------
                                                         *MiniJump.smart_jump()*
                   `MiniJump.smart_jump`({backward}, {till})
Make smart jump

If the last movement was a jump, perform another jump with the same target.
Otherwise, wait for a target input (via |getchar()|). Respects |v:count|.

All default values are taken from |MiniJump.state| to emulate latest jump.

Parameters~
{backward} `(boolean)` Whether to jump backward.
{till} `(boolean)` Whether to jump just before/after the match instead of
  exactly on target. Also ignore matches that have nothing before/after them.

------------------------------------------------------------------------------
                                                          *MiniJump.expr_jump()*
                    `MiniJump.expr_jump`({backward}, {till})
Make expression jump

Cache information about the jump and return string with command to perform
jump. Designed to be used inside Operator-pending mapping (see
|omap-info|). Always asks for target (via |getchar()|). Respects |v:count|.

All default values are taken from |MiniJump.state| to emulate latest jump.

Parameters~
{backward} `(boolean)` Whether to jump backward.
{till} `(boolean)` Whether to jump just before/after the match instead of
  exactly on target. Also ignore matches that have nothing before/after them.

------------------------------------------------------------------------------
                                                       *MiniJump.stop_jumping()*
                           `MiniJump.stop_jumping`()
Stop jumping

Removes highlights (if any) and forces the next smart jump to prompt for
the target. Automatically called on appropriate Neovim |events|.

------------------------------------------------------------------------------
                                                     *MiniJump.on_cursormoved()*
                          `MiniJump.on_cursormoved`()
Act on |CursorMoved|


==============================================================================
------------------------------------------------------------------------------
                                                                   *mini.jump2d*
                                                                    *MiniJump2d*
Minimal and fast Lua plugin for jumping (moving cursor) within
visible lines via iterative label filtering. Main inspiration is a
"phaazon/hop.nvim" plugin, but this module has a slightly different idea
about how target jump spot is chosen.

Features:
- Make jump by iterative filtering of possible, equally considered jump
  spots until there is only one. Filtering is done by typing a label
  character that is visualized at jump spot.
- Customizable:
    - Way of computing possible jump spots with opinionated default.
    - Characters used to label jump spots during iterative filtering.
    - Action hooks to be executed at certain events during jump.
    - Allowed windows: current and/or not current.
    - Allowed lines: whether to process blank or folded lines, lines
      before/at/after cursor line, etc. Example: user can configure to look
      for spots only inside current window at or after cursor line.
    Example: user can configure to look for word starts only inside current
    window at or after cursor line with 'j' and 'k' labels performing some
    action after jump.
- Works in Visual and Operator-pending (with dot-repeat) modes.
- Preconfigured ways of computing jump spots (see |MiniJump2d.builtin_opts|).
- Works with multibyte characters.

General overview of how jump is intended to be performed:
- Lock eyes on desired location ("spot") recognizable by future jump.
  Should be within visible lines at place where cursor can be placed.
- Initiate jump. Either by custom keybinding or with a call to
  |MiniJump2d.start()| (allows customization options). This will highlight
  all possible jump spots with their labels (letters from "a" to "z" by
  default). For more details, read |MiniJump2d.start()| and |MiniJump2d.config|.
- Type character that appeared over desired location. If its label was
  unique, jump is performed. If it wasn't unique, possible jump spots are
  filtered to those having the same label character.
- Repeat previous step until there is only one possible jump spot or type `<CR>`
  to jump to first available jump spot. Typing anything else stops jumping
   without moving cursor.

# Setup~

This module needs a setup with `require('mini.jump2d').setup({})` (replace
`{}` with your `config` table). It will create global Lua table
`MiniJump2d` which you can use for scripting or manually (with
`:lua MiniJump2d.*`). See |MiniJump2d.config| for available config settings.

# Example usage~

- Modify default jumping to use only current window at or after cursor line: >
  require('mini.jump2d').setup({
    allowed_lines = { cursor_before = false },
    allowed_windows = { not_current = false },
  })
- `lua MiniJump2d.start(MiniJump2d.builtin_opts.line_start)` - jump to word
  start using combination of options supplied in |MiniJump2d.config| and
  |MiniJump2d.builtin_opts.line_start|.
- `lua MiniJump2d.start(MiniJump2d.builtin_opts.single_character)` - jump
  to single character typed after executing this command.
- See more examples in |MiniJump2d.start| and |MiniJump2d.builtin_opts|.

# Comparisons~

- 'phaazon/hop.nvim':
    - Both are fast, customizable, and extensible (user can write their own
      ways to define jump spots).
    - Both have several builtin ways to specify type of jump (word start,
      line start, one character or query based on user input). 'hop.nvim'
      does that by exporting many targeted Neovim commands, while this
      module has preconfigured basic options leaving others to
      customization with Lua code (see |MiniJump2d.builtin_opts|).
    - 'hop.nvim' computes labels (called "hints") differently. Contrary to
      this module deliberately not having preference of one jump spot over
      another, 'hop.nvim' uses specialized algorithm that produces sequence
      of keys in a slightly biased manner: some sequences are intentionally
      shorter than the others (leading to fewer average keystrokes). They
      are put near cursor (by default) and highlighted differently. Final
      order of sequences is based on distance to the cursor.
    - 'hop.nvim' visualizes labels differently. It is designed to show
      whole sequences at once, while this module intentionally shows only
      current one at a time.
    - 'mini.jump2d' has opinionated default algorithm of computing jump
      spots. See |MiniJump2d.default_spotter|.

# Highlight groups~

* `MiniJump2dSpot` - highlighting of jump spots. By default it uses label
  with highest contrast while not being too visually demanding: white on
  black for dark 'background', black on white for light. If it doesn't
  suit your liking, try couple of these alternatives (or choose your own,
  of course):
    - `hi MiniJump2dSpot gui=reverse` - reverse underlying highlighting (more
      colorful while being visible in any colorscheme).
    - `hi MiniJump2dSpot gui=bold,italic` - bold italic.
    - `hi MiniJump2dSpot gui=undercurl guisp=red` - red undercurl.

To change any highlight group, modify it directly with |:highlight|.

# Disabling~

To disable, set `g:minijump2d_disable` (globally) or `b:minijump2d_disable`
(for a buffer) to `v:true`. Considering high number of different scenarios
and customization intentions, writing exact rules for disabling module's
functionality is left to user. See |mini.nvim-disabling-recipes| for common
recipes.

------------------------------------------------------------------------------
                                                            *MiniJump2d.setup()*
                          `MiniJump2d.setup`({config})
Module setup

Parameters~
{config} `(table)` Module config table. See |MiniJump2d.config|.

Usage~
`require('mini.jump2d').setup({})` (replace `{}` with your `config` table)

------------------------------------------------------------------------------
                                                             *MiniJump2d.config*
                              `MiniJump2d.config`
Module config

Default values:
>
  MiniJump2d.config = {
    -- Function producing jump spots (byte indexed) for a particular line.
    -- For more information see |MiniJump2d.start|.
    -- If `nil` (default) - use |MiniJump2d.default_spotter|
    spotter = nil,

    -- Characters used for labels of jump spots (in supplied order)
    labels = 'abcdefghijklmnopqrstuvwxyz',

    -- Which lines are used for computing spots
    allowed_lines = {
      blank = true, -- Blank line (not sent to spotter even if `true`)
      cursor_before = true, -- Lines before cursor line
      cursor_at = true, -- Cursor line
      cursor_after = true, -- Lines after cursor line
      fold = true, -- Start of fold (not sent to spotter even if `true`)
    },

    -- Which windows from current tabpage are used for visible lines
    allowed_windows = {
      current = true,
      not_current = true,
    },

    -- Functions to be executed at certain events
    hooks = {
      before_start = nil, -- Before jump start
      after_jump = nil, -- After jump was actually done
    },

    -- Module mappings. Use `''` (empty string) to disable one.
    mappings = {
      start_jumping = '<CR>',
    },
  }
<
# Options~

## Spotter function~

Actual computation of possible jump spots is done through spotter function.
It should have the following arguments:
- `line_num` is a line number inside buffer.
- `args` - table with additional arguments:
    - {win_id} - identifier of a window where input line number is from.
    - {win_id_init} - identifier of a window which was current when
      `MiniJump2d.start()` was called.

Its output is a list of byte-indexed positions that should be considered as
possible jump spots for this particular line in this particular window.
Note: for a more aligned visualization this list should be (but not
strictly necessary) sorted increasingly.

Note: spotter function is always called with `win_id` window being
"temporary current" (see |nvim_win_call|). This allows using builtin
Vimscript functions that operate only inside current window.

## Allowed lines~

Option `allowed_lines` controls which lines will be used for computing
possible jump spots:
- If `blank` or `fold` is `true`, it is possible to jump to first column of blank
  line (determined by |prevnonblank|) or first folded one (determined by
  |foldclosed|) respectively. Otherwise they are skipped. These lines are
  not processed by spotter function even if the option is `true`.
- If `cursor_before`, (`cursor_at`, `cursor_after`) is `true`, lines before
  (at, after) cursor line of all processed windows are forwarded to spotter
  function. Otherwise, they don't. This allows control of jump "direction".

## Hooks~

Following hook functions can be used to further tweak jumping experience:
- `before_start` - called without arguments first thing when jump starts.
  One of the possible use cases is to ask for user input and update spotter
  function with it.
- `after_jump` - called after jump was actually done. Useful to make
  post-adjustments (like move cursor to first non-whitespace character).

------------------------------------------------------------------------------
                                                            *MiniJump2d.start()*
                           `MiniJump2d.start`({opts})
Start jumping

Compute possible jump spots, visualize them and wait for iterative filtering.

First computation of possible jump spots~

- Process allowed windows (current and/or not current; controlled by
  `allowed_windows` option) by visible lines from top to bottom. For each
  one see if it is allowed (controlled by `allowed_lines` option). If not
  allowed, then do nothing. If allowed and should be processed by
  `spotter`, process it.
- Apply spotter function from `spotter` option for each appropriate line
  and concatenate outputs. This means that eventual order of jump spots
  aligns with lexicographical order within "window id" - "line number" -
  "position in `spotter` output" tuples.
- For each possible jump compute its label: a single character from
  `labels` option used to filter jump spots. Each possible label character
  might be used more than once to label several "consecutive" jump spots.
  It is done in an optimal way under assumption of no preference of one
  spot over another. Basically, it means "use all labels at each step of
  iterative filtering as equally as possible".

Visualization~

Current label for each possible jump spot is shown at that position
overriding everything underneath it.

Iterative filtering~

Labels of possible jump spots are computed in order to use them as equally
as possible.

Example:
- With `abc` as `labels` option, initial labels for 10 possible jumps
  are "aaaabbbccc". As there are 10 spots which should be "coded" with 3
  symbols, at least 2 symbols need 3 steps to filter them out. With current
  implementation those are always the "first ones".
- After typing `a`, it filters first four jump spots and recomputes its
  labels to be "aabc".
- After typing `a` again, it filters first two spots and recomputes its
  labels to be "ab".
- After typing either `a` or `b` it filters single spot and makes jump.

With default 26 labels for most real-world cases 2 steps is enough for
default spotter function. Rarely 3 steps are needed with several windows.

Parameters~
{opts} `(table)` Configuration of jumping, overriding values from
  |MiniJump2d.config|. Has the same structure as |MiniJump2d.config|
  without <mappings> field. Extra allowed fields:
    - <hl_group> - which highlight group to use (default: "MiniJump2dSpot").

Usage~
- Start default jumping:
  `MiniJump2d.start()`
- Jump to word start:
  `MiniJump2d.start(MiniJump2d.builtin_opts.word_start)`
- Jump to single character from user input (follow by typing one character):
  `MiniJump2d.start(MiniJump2d.builtin_opts.single_character)`
- Jump to first character of punctuation group only inside current window
  which is placed at cursor line; visualize with 'hl-Search': >
  MiniJump2d.start({
    spotter = MiniJump2d.gen_pattern_spotter('%p+'),
    allowed_lines = { cursor_before = false, cursor_after = false },
    allowed_windows = { not_current = false },
    hl_group = 'Search'
  })

See also~
|MiniJump2d.config|

------------------------------------------------------------------------------
                                                             *MiniJump2d.stop()*
                              `MiniJump2d.stop`()
Stop jumping

------------------------------------------------------------------------------
                                              *MiniJump2d.gen_pattern_spotter()*
              `MiniJump2d.gen_pattern_spotter`({pattern}, {side})
Generate spotter for Lua pattern

Parameters~
{pattern} `(string)` Lua pattern. Default: `'[^%s%p]+'` which matches group
  of "non-whitespace non-punctuation characters" (basically a way of saying
  "group of alphanumeric characters" that works with multibyte characters).
{side} `(string)` Which side of pattern match should be considered as
  jumping spot. Should be one of 'start' (start of match, default), 'end'
  (inclusive end of match), or 'none' (match for spot is done manually
  inside pattern with plain `()` matching group).

Usage~
- Match any punctuation:
  `MiniJump2d.gen_pattern_spotter('%p')`
- Match first from line start non-whitespace character:
  `MiniJump2d.gen_pattern_spotter('^%s*%S', 'end')`
- Match start of last word:
  `MiniJump2d.gen_pattern_spotter('[^%s%p]+[%s%p]-$', 'start')`
- Match letter followed by another letter (example of manual matching
  inside pattern):
  `MiniJump2d.gen_pattern_spotter('%a()%a', 'none')`

------------------------------------------------------------------------------
                                                    *MiniJump2d.default_spotter*
                          `MiniJump2d.default_spotter`
Default spotter function

Spot is possible for jump if it is one of the following:
- Start or end of non-whitespace character group.
- Alphanumeric character followed or preceeded by punctuation (useful for
  snake case names).
- Start of uppercase character group (useful for camel case names). Usually
  only Lating alphabet is recognized due to Lua patterns shortcomings.

These rules are derived in an attempt to balance between two intentions:
- Allow as much useful jumping spots as possible.
- Make labeled jump spots easily distinguishable.

Usually takes from 2 to 3 keystrokes to get to destination.

------------------------------------------------------------------------------
                                                       *MiniJump2d.builtin_opts*
                           `MiniJump2d.builtin_opts`
Table with builtin `opts` values for |MiniJump2d.start()|

Each element of table is itself a table defining one or several options for
`MiniJump2d.start()`. Read help description to see which options it defines
(like in |MiniJump2d.builtin_opts.line_start|).

Usage~
Using |MiniJump2d.builtin_opts.line_start| as example:
- Command:
  `:lua MiniJump2d.start(MiniJump2d.builtin_opts.line_start)`
- Custom mapping: >
  vim.api.nvim_set_keymap(
    'n', '<CR>',
    '<Cmd>lua MiniJump2d.start(MiniJump2d.builtin_opts.line_start)<CR>', {}
  )
- Inside |MiniJump2d.setup| (make sure to use all defined options): >
  local jump2d = require('mini.jump2d')
  local jump_line_start = jump2d.builtin_opts.line_start
  jump2d.setup({
    spotter = jump_line_start.spotter,
    hooks = { after_jump = jump_line_start.hooks.after_jump }
  })
<

------------------------------------------------------------------------------
                                               *MiniJump2d.builtin_opts.default*
                       `MiniJump2d.builtin_opts.default`
Jump with |MiniJump2d.default_spotter()|

Defines `spotter`.

------------------------------------------------------------------------------
                                            *MiniJump2d.builtin_opts.line_start*
                      `MiniJump2d.builtin_opts.line_start`
Jump to line start

Defines `spotter` and `hooks.after_jump`.

------------------------------------------------------------------------------
                                            *MiniJump2d.builtin_opts.word_start*
                      `MiniJump2d.builtin_opts.word_start`
Jump to word start

Defines `spotter`.

------------------------------------------------------------------------------
                                      *MiniJump2d.builtin_opts.single_character*
                   `MiniJump2d.builtin_opts.single_character`
Jump to single character taken from user input

Defines `spotter`, `allowed_lines.blank`, `allowed_lines.fold`, and
`hooks.before_start`.

------------------------------------------------------------------------------
                                                 *MiniJump2d.builtin_opts.query*
                        `MiniJump2d.builtin_opts.query`
Jump to query taken from user input

Defines `spotter`, `allowed_lines.blank`, `allowed_lines.fold`, and
`hooks.before_start`.


==============================================================================
------------------------------------------------------------------------------
                                                                     *mini.misc*
                                                                      *MiniMisc*
Lua module with miscellaneous useful functions (can be used independently).

# Setup~

This module doesn't need setup, but it can be done to improve usability.
Setup with `require('mini.misc').setup({})` (replace `{}` with your
`config` table). It will create global Lua table `MiniMisc` which you can
use for scripting or manually (with `:lua MiniMisc.*`).

See |MiniMisc.config| for `config` structure and default values.

------------------------------------------------------------------------------
                                                              *MiniMisc.setup()*
                           `MiniMisc.setup`({config})
Module setup

Parameters~
{config} `(table)` Module config table. See |MiniMisc.config|.

Usage~
`require('mini.misc').setup({})` (replace `{}` with your `config` table)

------------------------------------------------------------------------------
                                                               *MiniMisc.config*
                               `MiniMisc.config`
Module config

Default values:
>
  MiniMisc.config = {
    -- Array of fields to make global (to be used as independent variables)
    make_global = { 'put', 'put_text' },
  }
<

------------------------------------------------------------------------------
                                                         *MiniMisc.bench_time()*
                     `MiniMisc.bench_time`({f}, {n}, {...})
Execute `f` several times and time how long it took

Parameters~
{f} `(function)` Function which execution to benchmark.
{n} `(number)` Number of times to execute `f(...)`. Default: 1.
{...} `(any)` Arguments when calling `f`.

Return~
`(...)` Table with durations (in seconds; up to microseconds) and
  output of (last) function execution.

------------------------------------------------------------------------------
                                                   *MiniMisc.get_gutter_width()*
                     `MiniMisc.get_gutter_width`({win_id})
Compute width of gutter (info column on the left of the window)

Parameters~
{win_id} `(number)` Window identifier (see |win_getid()|) for which gutter
  width is computed. Default: 0 for current.

------------------------------------------------------------------------------
                                                                *MiniMisc.put()*
                             `MiniMisc.put`({...})
Print Lua objects in command line

Parameters~
{...} `(any)` Any number of objects to be printed each on separate line.

------------------------------------------------------------------------------
                                                           *MiniMisc.put_text()*
                           `MiniMisc.put_text`({...})
Print Lua objects in current buffer

Parameters~
{...} `(any)` Any number of objects to be printed each on separate line.

------------------------------------------------------------------------------
                                                      *MiniMisc.resize_window()*
                `MiniMisc.resize_window`({win_id}, {text_width})
Resize window to have exact number of editable columns

Parameters~
{win_id} `(number)` Window identifier (see |win_getid()|) to be resized.
  Default: 0 for current.
{text_width} `(number)` Number of editable columns resized window will
  display. Default: first element of 'colorcolumn' or otherwise 'textwidth'
  (using screen width as its default but not more than 79).

------------------------------------------------------------------------------
                                                       *MiniMisc.stat_summary()*
                          `MiniMisc.stat_summary`({t})
Compute summary statistics of numerical array

This might be useful to compute summary of time benchmarking with
|MiniMisc.bench_time|.

Parameters~
{t} `(table)` Array (table suitable for `ipairs`) of numbers.

Return~
`(table)` Table with summary values under following keys (may be
  extended in the future): <maximum>, <mean>, <median>, <minimum>, <n>
  (number of elements), <sd> (sample standard deviation).

------------------------------------------------------------------------------
                                                           *MiniMisc.tbl_head()*
                         `MiniMisc.tbl_head`({t}, {n})
Return "first" elements of table as decided by `pairs`

Note: order of elements might vary.

Parameters~
{t} `(table)` Input table.
{n} `(number)` Maximum number of first elements. Default: 5.

Return~
`(table)` Table with at most `n` first elements of `t` (with same keys).

------------------------------------------------------------------------------
                                                           *MiniMisc.tbl_tail()*
                         `MiniMisc.tbl_tail`({t}, {n})
Return "last" elements of table as decided by `pairs`

This function makes two passes through elements of `t`:
- First to count number of elements.
- Second to construct result.

Note: order of elements might vary.

Parameters~
{t} `(table)` Input table.
{n} `(number)` Maximum number of last elements. Default: 5.

Return~
`(table)` Table with at most `n` last elements of `t` (with same keys).

------------------------------------------------------------------------------
                                                *MiniMisc.use_nested_comments()*
                    `MiniMisc.use_nested_comments`({buf_id})
Add possibility of nested comment leader

This works by parsing 'commentstring' buffer option, extracting
non-whitespace comment leader (symbols on the left of commented line), and
locally modifying 'comments' option (by prepending `n:<leader>`). Does
nothing if 'commentstring' is empty or has comment symbols both in front
and back (like "/*%s*/").

Nested comment leader added with this function is useful for formatting
nested comments. For example, have in Lua "first-level" comments with '--'
and "second-level" comments with '----'. With nested comment leader second
type can be formatted with `gq` in the same way as first one.

Recommended usage is with |autocmd|:
`autocmd BufEnter * lua pcall(require('mini.misc').use_nested_comments)`

Note: for most filetypes 'commentstring' option is added only when buffer
with this filetype is entered, so using non-current `buf_id` can not lead
to desired effect.

Parameters~
{buf_id} `(number)` Buffer identifier (see |bufnr()|) in which function
  will operate. Default: 0 for current.

------------------------------------------------------------------------------
                                                               *MiniMisc.zoom()*
                      `MiniMisc.zoom`({buf_id}, {config})
Zoom in and out of a buffer, making it full screen in a floating window

This function is useful when working with multiple windows but temporarily
needing to zoom into one to see more of the code from that buffer. Call it
again (without arguments) to zoom out.

Parameters~
{buf_id} `(number)` Buffer identifier (see |bufnr()|) to be zoomed.
  Default: 0 for current.
{config} `(table)` Optional config for window (as for |nvim_open_win()|).


==============================================================================
------------------------------------------------------------------------------
                                                                    *mini.pairs*
                                                                     *MiniPairs*
Minimal and fast autopairs Lua module. It provides functionality to work
with 'paired' characters conditional on cursor's neighborhood (two
characters to its left and right). Its usage should be through making
appropriate mappings using |MiniPairs.map| or in |MiniPairs.setup| (for
global mapping), |MiniPairs.map_buf| (for buffer mapping). Pairs get
automatically registered to be recognized by `<BS>` and `<CR>`.

What it doesn't do:
- It doesn't support multiple characters as "open" and "close" symbols. Use
  snippets for that.
- It doesn't support dependency on filetype. Use |i_CTRL-V| to insert
  single symbol or `autocmd` command or 'after/ftplugin' approach to:
    - `lua MiniPairs.map_buf(0, 'i', <*>, <pair_info>)` : make new mapping
      for '<*>' in current buffer.
    - `lua MiniPairs.unmap_buf(0, 'i', <*>, <pair>)`: unmap key `<*>` while
      unregistering `<pair>` pair in current buffer. Note: this reverts
      mapping done by |MiniPairs.map_buf|. If mapping was done with
      |MiniPairs.map|, unmap for buffer in usual Neovim manner:
      `inoremap <buffer> <*> <*>` (this maps `<*>` key to do the same it
      does by default).
    - Disable module for buffer (see 'Disabling' section).

# Setup~

This module needs a setup with `require('mini.pairs').setup({})`
(replace `{}` with your `config` table). It will create global Lua table
`MiniPairs` which you can use for scripting or manually (with
`:lua MiniPairs.*`).

See |MiniPairs.config| for `config` structure and default values.

# Example mappings~

- Register quotes inside `config` of |MiniPairs.setup|: >
  mappings = {
    ['"'] = { register = { cr = true } },
    ["'"] = { register = { cr = true } },
  }
<
- Insert `<>` pair if `<` is typed at line start, don't register for `<CR>`: >
  lua MiniPairs.map('i', '<', { action = 'open', pair = '<>', neigh_pattern = '\r.', register = { cr = false } })
  lua MiniPairs.map('i', '>', { action = 'close', pair = '<>', register = { cr = false } })
<
- Create symmetrical `$$` pair only in Tex files: >
  au FileType tex lua MiniPairs.map_buf(0, 'i', '$', {action = 'closeopen', pair = '$$'})
<
# Notes~

- Make sure to make proper mapping of `<CR>` in order to support completion
  plugin of your choice:
    - For |MiniCompletion| see 'Helpful key mappings' section.
    - For current implementation of "hrsh7th/nvim-cmp" there is no need to
      make custom mapping. You can use default setup, which will confirm
      completion selection if popup is visible and expand pair otherwise.
- Having mapping in terminal mode can conflict with:
    - Autopairing capabilities of interpretators (`ipython`, `radian`).
    - Vim mode of terminal itself.

# Disabling~

To disable, set `g:minipairs_disable` (globally) or `b:minipairs_disable`
(for a buffer) to `v:true`. Considering high number of different scenarios
and customization intentions, writing exact rules for disabling module's
functionality is left to user. See |mini.nvim-disabling-recipes| for common
recipes.

------------------------------------------------------------------------------
                                                             *MiniPairs.setup()*
                          `MiniPairs.setup`({config})
Module setup

Parameters~
{config} `(table)` Module config table. See |MiniPairs.config|.

Usage~
`require('mini.completion').setup({})` (replace `{}` with your `config` table)

------------------------------------------------------------------------------
                                                              *MiniPairs.config*
                               `MiniPairs.config`
Module config

Default values:
>
  MiniPairs.config = {
    -- In which modes mappings from this `config` should be created
    modes = { insert = true, command = false, terminal = false },

    -- Global mappings. Each right hand side should be a pair information, a
    -- table with at least these fields (see more in |MiniPairs.map|):
    -- - <action> - one of "open", "close", "closeopen".
    -- - <pair> - two character string for pair to be used.
    -- By default pair is not inserted after `\`, quotes are not recognized by
    -- `<CR>`, `'` does not insert pair after a letter.
    -- Only parts of tables can be tweaked (others will use these defaults).
    mappings = {
      ['('] = { action = 'open', pair = '()', neigh_pattern = '[^\\].' },
      ['['] = { action = 'open', pair = '[]', neigh_pattern = '[^\\].' },
      ['{'] = { action = 'open', pair = '{}', neigh_pattern = '[^\\].' },

      [')'] = { action = 'close', pair = '()', neigh_pattern = '[^\\].' },
      [']'] = { action = 'close', pair = '[]', neigh_pattern = '[^\\].' },
      ['}'] = { action = 'close', pair = '{}', neigh_pattern = '[^\\].' },

      ['"'] = { action = 'closeopen', pair = '""', neigh_pattern = '[^\\].', register = { cr = false } },
      ["'"] = { action = 'closeopen', pair = "''", neigh_pattern = '[^%a\\].', register = { cr = false } },
      ['`'] = { action = 'closeopen', pair = '``', neigh_pattern = '[^\\].', register = { cr = false } },
    },
  }
<

------------------------------------------------------------------------------
                                                               *MiniPairs.map()*
              `MiniPairs.map`({mode}, {lhs}, {pair_info}, {opts})
Make global mapping

This is a wrapper for |nvim_set_keymap()| but instead of right hand side of
mapping (as string) it expects table with pair information:
- `action` - one of "open" (for |MiniPairs.open|), "close" (for
  |MiniPairs.close|), or "closeopen" (for |MiniPairs.closeopen|).
- `pair` - two character string to be used as argument for action function.
- `neigh_pattern` - optional 'two character' neighborhood pattern to be
  used as argument for action function. Default: '..' (no restriction from
  neighborhood).
- `register` - optional table with information about whether this pair
  should be recognized by `<BS>` (in |MiniPairs.bs|) and/or `<CR>` (in
  |MiniPairs.cr|). Should have boolean elements `bs` and `cr` which are
  both `true` by default (if not overriden explicitly).

Using this function instead of |nvim_set_keymap()| allows automatic
registration of pairs which will be recognized by `<BS>` and `<CR>`.
For Neovim>=0.7 it also infers mapping description from `pair_info`.

Parameters~
{mode} `(string)` `mode` for |nvim_set_keymap()|.
{lhs} `(string)` `lhs` for |nvim_set_keymap()|.
{pair_info} `(table)` Table with pair information.
{opts} `(table)` Optional table `opts` for |nvim_set_keymap()|. Elements
  `expr` and `noremap` won't be recognized (`true` by default).

------------------------------------------------------------------------------
                                                           *MiniPairs.map_buf()*
       `MiniPairs.map_buf`({buffer}, {mode}, {lhs}, {pair_info}, {opts})
Make buffer mapping

This is a wrapper for |nvim_buf_set_keymap()| but instead of string right
hand side of mapping it expects table with pair information similar to one
in |MiniPairs.map|.

Using this function instead of |nvim_buf_set_keymap()| allows automatic
registration of pairs which will be recognized by `<BS>` and `<CR>`.
For Neovim>=0.7 it also infers mapping description from `pair_info`.

Parameters~
{buffer} `(number)` `buffer` for |nvim_buf_set_keymap()|.
{mode} `(string)` `mode` for |nvim_buf_set_keymap()|.
{lhs} `(string)` `lhs` for |nvim_buf_set_keymap()|.
{pair_info} `(table)` Table with pair information.
{opts} `(table)` Optional table `opts` for |nvim_buf_set_keymap()|.
  Elements `expr` and `noremap` won't be recognized (`true` by default).

------------------------------------------------------------------------------
                                                             *MiniPairs.unmap()*
                    `MiniPairs.unmap`({mode}, {lhs}, {pair})
Remove global mapping

A wrapper for |nvim_del_keymap()| which registers supplied `pair`.

Parameters~
{mode} `(string)` `mode` for |nvim_del_keymap()|.
{lhs} `(string)` `lhs` for |nvim_del_keymap()|.
{pair} `(string)` Pair which should be unregistered from both
  `<BS>` and `<CR>`. Should be explicitly supplied to avoid confusion.
  Supply `''` to not unregister pair.

------------------------------------------------------------------------------
                                                         *MiniPairs.unmap_buf()*
             `MiniPairs.unmap_buf`({buffer}, {mode}, {lhs}, {pair})
Remove buffer mapping

Wrapper for |nvim_buf_del_keymap()| which also unregisters supplied `pair`.

Note: this only reverts mapping done by |MiniPairs.map_buf|. If mapping was
done with |MiniPairs.map|, unmap for buffer in usual Neovim manner:
`inoremap <buffer> <*> <*>` (this maps `<*>` key to do the same it does by
default).

Parameters~
{buffer} `(number)` `buffer` for |nvim_buf_del_keymap()|.
{mode} `(string)` `mode` for |nvim_buf_del_keymap()|.
{lhs} `(string)` `lhs` for |nvim_buf_del_keymap()|.
{pair} `(string)` Pair which should be unregistered from both
  `<BS>` and `<CR>`. Should be explicitly supplied to avoid confusion.
  Supply `''` to not unregister pair.

------------------------------------------------------------------------------
                                                              *MiniPairs.open()*
                   `MiniPairs.open`({pair}, {neigh_pattern})
Process "open" symbols

Used as |map-expr| mapping for "open" symbols in asymmetric pair ('(', '[',
etc.). If neighborhood doesn't match supplied pattern, function results
into "open" symbol. Otherwise, it pastes whole pair and moves inside pair
with |<Left>|.

Used inside |MiniPairs.map| and |MiniPairs.map_buf| for an actual mapping.

Parameters~
{pair} `(string)` String with two characters representing pair.
{neigh_pattern} `(string)` Pattern for two neighborhood characters ("\r" line
  start, "\n" - line end).

------------------------------------------------------------------------------
                                                             *MiniPairs.close()*
                   `MiniPairs.close`({pair}, {neigh_pattern})
Process "close" symbols

Used as |map-expr| mapping for "close" symbols in asymmetric pair (')',
']', etc.). If neighborhood doesn't match supplied pattern, function
results into "close" symbol. Otherwise it jumps over symbol to the right of
cursor (with |<Right>|) if it is equal to "close" one and inserts it
otherwise.

Used inside |MiniPairs.map| and |MiniPairs.map_buf| for an actual mapping.

Parameters~
{pair} `(string)` String with two characters representing pair.
{neigh_pattern} `(string)` Pattern for two neighborhood characters ("\r" line
  start, "\n" - line end).

------------------------------------------------------------------------------
                                                         *MiniPairs.closeopen()*
                 `MiniPairs.closeopen`({pair}, {neigh_pattern})
Process "closeopen" symbols

Used as |map-expr| mapping for 'symmetrical' symbols (from pairs '""',
'\'\'', '``').  It tries to perform 'closeopen action': move over right
character (with |<Right>|) if it is equal to second character from pair or
conditionally paste pair otherwise (with |MiniPairs.open()|).

Used inside |MiniPairs.map| and |MiniPairs.map_buf| for an actual mapping.

Parameters~
{pair} `(string)` String with two characters representing pair.
{neigh_pattern} `(string)` Pattern for two neighborhood characters ("\r" line
  start, "\n" - line end).

------------------------------------------------------------------------------
                                                                *MiniPairs.bs()*
                                `MiniPairs.bs`()
Process |<BS>|

Used as |map-expr| mapping for `<BS>`. It removes whole pair (via
`<BS><Del>`) if neighborhood is equal to a whole pair recognized for
current buffer. Pair is recognized for current buffer if it is registered
for global or current buffer mapping. Pair is registered as a result of
calling |MiniPairs.map| or |MiniPairs.map_buf|.

Mapped by default inside |MiniPairs.setup|.

------------------------------------------------------------------------------
                                                                *MiniPairs.cr()*
                                `MiniPairs.cr`()
Process |i_<CR>|

Used as |map-expr| mapping for `<CR>` in insert mode. It puts "close"
symbol on next line (via `<CR><C-o>O`) if neighborhood is equal to a whole
pair recognized for current buffer. Pair is recognized for current buffer
if it is registered for global or current buffer mapping. Pair is
registered as a result of calling |MiniPairs.map| or |MiniPairs.map_buf|.

Mapped by default inside |MiniPairs.setup|.


==============================================================================
------------------------------------------------------------------------------
                                                                 *mini.sessions*
                                                                  *MiniSessions*
Lua module for minimal session management (read, write, delete), which
works using |mksession| (meaning 'sessionoptions' is fully respected).
This is intended as a drop-in Lua replacement for session management part
of [mhinz/vim-startify](https://github.com/mhinz/vim-startify) (works out
of the box with sessions created by it). Implements both global (from
configured directory) and local (from current directory) sessions.

Key design ideas:
- Sessions are represented by readable files (results of applying
  |mksession|). There are two kinds of sessions:
    - Global: any file inside a configurable directory.
    - Local: configurable file inside current working directory (|getcwd|).
- All session files are detected during `MiniSessions.setup()` with session
  names being file names (including their possible extension).
- Store information about detected sessions in separate table
  (|MiniSessions.detected|) and operate only on it. Meaning if this
  information changes, there will be no effect until next detection. So to
  avoid confusion, don't directly use |mksession| and |source| for writing
  and reading sessions files.

Features:
- Autoread default session (local if detected, latest otherwise) if Neovim
  was called without intention to show something else.
- Autowrite current session before quitting Neovim.
- Configurable severity level of all actions.

# Setup~

This module needs a setup with `require('mini.sessions').setup({})`
(replace `{}` with your `config` table). It will create global Lua table
`MiniSessions` which you can use for scripting or manually (with
`:lua MiniSessions.*`).

See |MiniSessions.config| for `config` structure and default values.

# Disabling~

To disable core functionality, set `g:minisessions_disable` (globally) or
`b:minisessions_disable` (for a buffer) to `v:true`. Considering high
number of different scenarios and customization intentions, writing exact
rules for disabling module's functionality is left to user. See
|mini.nvim-disabling-recipes| for common recipes.

------------------------------------------------------------------------------
                                                          *MiniSessions.setup()*
                         `MiniSessions.setup`({config})
Module setup

Parameters~
{config} `(table)` Module config table. See |MiniSessions.config|.

Usage~
`require('mini.sessions').setup({})` (replace `{}` with your `config` table)

------------------------------------------------------------------------------
                                                           *MiniSessions.config*
                             `MiniSessions.config`
Module config

Default values:
>
  MiniSessions.config = {
    -- Whether to read latest session if Neovim opened without file arguments
    autoread = false,

    -- Whether to write current session before quitting Neovim
    autowrite = true,

    -- Directory where global sessions are stored (use `''` to disable)
    directory = --<"session" subdir of user data directory from |stdpath()|>,

    -- File for local session (use `''` to disable)
    file = 'Session.vim',

    -- Whether to force possibly harmful actions (meaning depends on function)
    force = { read = false, write = true, delete = false },

    -- Hook functions for actions. Default `nil` means 'do nothing'.
    hooks = {
      -- Before successful action
      pre = { read = nil, write = nil, delete = nil },
      -- After successful action
      post = { read = nil, write = nil, delete = nil },
    },

    -- Whether to print session path after action
    verbose = { read = false, write = true, delete = true },
  }
<

------------------------------------------------------------------------------
                                                         *MiniSessions.detected*
                            `MiniSessions.detected`
Table of detected sessions. Keys represent session name. Values are tables
with session information that currently has these fields (but subject to
change):
- <modify_time> `(number)` modification time (see |getftime|) of session file.
- <name> `(string)` name of session (should be equal to table key).
- <path> `(string)` full path to session file.
- <type> `(string)` type of session ('global' or 'local').

------------------------------------------------------------------------------
                                                           *MiniSessions.read()*
                  `MiniSessions.read`({session_name}, {opts})
Read detected session

What it does:
- Delete all current buffers with |bwipeout|. This is needed to correctly
  restore buffers from target session. If `force` is not `true`, checks
  beforehand for unsaved listed buffers and stops if there is any.
- Source session with supplied name.

Parameters~
{session_name} `(string)` Name of detected session file to read. Default:
  `nil` for default session: local (if detected) or latest session (see
  |MiniSessions.get_latest|).
{opts} `(table)` Table with options. Current allowed keys:
  - <force> (whether to delete unsaved buffers; default:
    `MiniSessions.config.force.read`).
  - <verbose> (whether to print session path after action; default
    `MiniSessions.config.verbose.read`).
  - <hooks> (a table with <pre> and <post> function hooks to be executed
    before and after successful read; overrides
    `MiniSessions.config.hooks.pre.read` and
    `MiniSessions.config.hooks.post.read`).

------------------------------------------------------------------------------
                                                          *MiniSessions.write()*
                  `MiniSessions.write`({session_name}, {opts})
Write session

What it does:
- Check if file for supplied session name already exists. If it does and
  `force` is not `true`, then stop.
- Write session with |mksession| to a file named `session_name`. Its
  directory is determined based on type of session:
    - It is at location |v:this_session| if `session_name` is `nil` and
      there is current session.
    - It is current working directory (|getcwd|) if `session_name` is equal
      to `MiniSessions.config.file` (represents local session).
    - It is `MiniSessions.config.directory` otherwise (represents global
      session).
- Update |MiniSessions.detected|.

Parameters~
{session_name} `(string)` Name of session file to write. Default: `nil` for
  current session (|v:this_session|).
{opts} `(table)` Table with options. Current allowed keys:
  - <force> (whether to ignore existence of session file; default:
    `MiniSessions.config.force.write`).
  - <verbose> (whether to print session path after action; default
    `MiniSessions.config.verbose.write`).
  - <hooks> (a table with <pre> and <post> function hooks to be executed
    before and after successful write; overrides
    `MiniSessions.config.hooks.pre.write` and
    `MiniSessions.config.hooks.post.write`).

------------------------------------------------------------------------------
                                                         *MiniSessions.delete()*
                 `MiniSessions.delete`({session_name}, {opts})
Delete detected session

What it does:
- Check if session name is a current one. If yes and `force` is not `true`,
  then stop.
- Delete session.
- Update |MiniSessions.detected|.

Parameters~
{session_name} `(string)` Name of detected session file to delete. Default:
  `nil` for name of current session (taken from |v:this_session|).
{opts} `(table)` Table with options. Current allowed keys:
  - <force> (whether to allow deletion of current session; default:
    `MiniSessions.config.force.delete`).
  - <verbose> (whether to print session path after action; default
    `MiniSessions.config.verbose.delete`).
  - <hooks> (a table with <pre> and <post> function hooks to be executed
    before and after successful delete; overrides
    `MiniSessions.config.hooks.pre.delete` and
    `MiniSessions.config.hooks.post.delete`).

------------------------------------------------------------------------------
                                                         *MiniSessions.select()*
                    `MiniSessions.select`({action}, {opts})
Select session interactively and perform action

Note: this uses |vim.ui.select| function, which is present in Neovim
starting from 0.6 version. For more user-friendly experience, override it
(for example, with external plugins like "stevearc/dressing.nvim").

Parameters~
{action} `(string)` Action to perform. Should be one of "read" (default),
  "write", or "delete".
{opts} `(table)` Options for specified action.

------------------------------------------------------------------------------
                                                     *MiniSessions.get_latest()*
                          `MiniSessions.get_latest`()
Get name of latest detected session

Latest session is the session with the latest modification time determined
by |getftime|.

Return~
`(string|nil)` Name of latest session or `nil` if there is no sessions.

------------------------------------------------------------------------------
                                                    *MiniSessions.on_vimenter()*
                          `MiniSessions.on_vimenter`()
Act on |VimEnter|


==============================================================================
------------------------------------------------------------------------------
                                                                  *mini.starter*
                                                                   *MiniStarter*
Lua module for minimal, fast, and flexible start screen. Displayed items
are fully customizable both in terms of what they do and how they look
(with reasonable defaults). Item selection can be done using prefix query
with instant visual feedback. This is mostly inspired by
[mhinz/vim-startify](https://github.com/mhinz/vim-startify).

Key design ideas:
- All available actions are defined inside items. Each item should have the
  following info:
    - <action> - function or string for |vim.cmd| which is executed when
      item is chosen. Empty string result in placeholder "inactive" item.
    - <name> - string which will be displayed and used for choosing.
    - <section> - string representing to which section item belongs.
  There are pre-configured whole sections in |MiniStarter.sections|.
- Configure what items are displayed by supplying an array which can be
  normalized to an array of items. Read about how supplied items are
  normalized in |MiniStarter.refresh|.
- Modify the final look by supplying content hooks: functions which take
  buffer content as input (see |MiniStarter.content| for more information)
  and return buffer content as output. There are pre-configured content
  hook generators in |MiniStarter.gen_hook|.
- Choosing an item can be done in two ways:
    - Type prefix query to filter item by matching its name (ignoring
      case). Displayed information is updated after every typed character.
      For every item its unique prefix is highlighted.
    - Use Up/Down arrows and hit Enter.

What is doesn't do:
- It doesn't support fuzzy query for items. And probably will never do.

# Setup~

This module needs a setup with `require('mini.starter').setup({})`
(replace `{}` with your `config` table). It will create global Lua table
`MiniStarter` which you can use for scripting or manually (with
`:lua MiniStarter.*`).

See |MiniStarter.config| for `config` structure and default values. For
some configuration examples (including one similar to 'vim-startify' and
'dashboard-nvim'), see |MiniStarter-example-config|.

# Highlight groups~

* `MiniStarterCurrent` - current item.
* `MiniStarterFooter` - footer units.
* `MiniStarterHeader` - header units.
* `MiniStarterInactive` - inactive item.
* `MiniStarterItem` - item name.
* `MiniStarterItemBullet` - units from |MiniStarter.gen_hook.adding_bullet|.
* `MiniStarterItemPrefix` - unique query for item.
* `MiniStarterSection` - section units.
* `MiniStarterQuery` - current query in active items.

To change any highlight group, modify it directly with |:highlight|.

# Disabling~

To disable core functionality, set `g:ministarter_disable` (globally) or
`b:ministarter_disable` (for a buffer) to `v:true`. Considering high number
of different scenarios and customization intentions, writing exact rules
for disabling module's functionality is left to user. See
|mini.nvim-disabling-recipes| for common recipes.

------------------------------------------------------------------------------
                                                    *MiniStarter-example-config*
Example configurations

Configuration similar to 'mhinz/vim-startify':
>
  local starter = require('mini.starter')
  starter.setup({
    evaluate_single = true,
    items = {
      starter.sections.builtin_actions(),
      starter.sections.recent_files(10, false),
      starter.sections.recent_files(10, true),
      -- Use this if you set up 'mini.sessions'
      starter.sections.sessions(5, true)
    },
    content_hooks = {
      starter.gen_hook.adding_bullet(),
      starter.gen_hook.indexing('all', { 'Builtin actions' }),
      starter.gen_hook.padding(3, 2),
    },
  })
<
Configuration similar to 'glepnir/dashboard-nvim':
>
  local starter = require('mini.starter')
  starter.setup({
    items = {
      starter.sections.telescope(),
    },
    content_hooks = {
      starter.gen_hook.adding_bullet(),
      starter.gen_hook.aligning('center', 'center'),
    },
  })
<
Elaborated configuration showing capabilities of custom items,
header/footer, and content hooks:
>
  local my_items = {
    { name = 'Echo random number', action = 'lua print(math.random())', section = 'Section 1' },
    function()
      return {
        { name = 'Item #1 from function', action = [[echo 'Item #1']], section = 'From function' },
        { name = 'Placeholder (always incative) item', action = '', section = 'From function' },
        function()
          return {
            name = 'Item #1 from double function',
            action = [[echo 'Double function']],
            section = 'From double function',
          }
        end,
      }
    end,
    { name = [[Another item in 'Section 1']], action = 'lua print(math.random() + 10)', section = 'Section 1' },
  }

  local footer_n_seconds = (function()
    local timer = vim.loop.new_timer()
    local n_seconds = 0
    timer:start(0, 1000, vim.schedule_wrap(function()
      if vim.api.nvim_buf_get_option(0, 'filetype') ~= 'starter' then
        timer:stop()
        return
      end
      n_seconds = n_seconds + 1
      MiniStarter.refresh()
    end))

    return function()
      return 'Number of seconds since opening: ' .. n_seconds
    end
  end)()

  local hook_top_pad_10 = function(content)
    -- Pad from top
    for _ = 1, 10 do
      -- Insert at start a line with single content unit
      table.insert(content, 1, { { type = 'empty', string = '' } })
    end
    return content
  end

  local starter = require('mini.starter')
  starter.setup({
    items = my_items,
    footer = footer_n_seconds,
    content_hooks = { hook_top_pad_10 },
  })
<

------------------------------------------------------------------------------
                                                         *MiniStarter-lifecycle*
# Lifecycle of Starter buffer~

- Open with |MiniStarter.open()|. It includes creating buffer with
  appropriate options, mappings, behavior; call to |MiniStarter.refresh()|;
  issue `MiniStarterOpened` |User| event.
- Wait for user to choose an item. This is done using following logic:
    - Typing any character from `MiniStarter.config.query_updaters` leads
      to updating query. Read more in |MiniStarter.add_to_query|.
    - <BS> deletes latest character from query.
    - <Down>/<Up>, <C-n>/<C-p>, <M-j>/<M-k> move current item.
    - <CR> executes action of current item.
    - <C-c> closes Starter buffer.
- Evaluate current item when appropriate (after `<CR>` or when there is a
  single item and `MiniStarter.config.evaluate_single` is `true`). This
  executes item's `action`.

------------------------------------------------------------------------------
                                                           *MiniStarter.setup()*
                         `MiniStarter.setup`({config})
Module setup

Parameters~
{config} `(table)` Module config table. See |MiniStarter.config|.

Usage~
`require('mini.starter').setup({})` (replace `{}` with your `config` table)

------------------------------------------------------------------------------
                                                            *MiniStarter.config*
                              `MiniStarter.config`
Module config

Default values:
>
  MiniStarter.config = {
    -- Whether to open starter buffer on VimEnter. Not opened if Neovim was
    -- started with intent to show something else.
    autoopen = true,

    -- Whether to evaluate action of single active item
    evaluate_single = false,

    -- Items to be displayed. Should be an array with the following elements:
    -- - Item: table with <action>, <name>, and <section> keys.
    -- - Function: should return one of these three categories.
    -- - Array: elements of these three types (i.e. item, array, function).
    -- If `nil` (default), default items will be used (see |mini.starter|).
    items = nil,

    -- Header to be displayed before items. Converted to single string via
    -- `tostring` (use `\n` to display several lines). If function, it is
    -- evaluated first. If `nil` (default), polite greeting will be used.
    header = nil,

    -- Footer to be displayed after items. Converted to single string via
    -- `tostring` (use `\n` to display several lines). If function, it is
    -- evaluated first. If `nil` (default), default usage help will be shown.
    footer = nil,

    -- Array  of functions to be applied consecutively to initial content.
    -- Each function should take and return content for 'Starter' buffer (see
    -- |mini.starter| and |MiniStarter.content| for more details).
    content_hooks = nil,

    -- Characters to update query. Each character will have special buffer
    -- mapping overriding your global ones. Be careful to not add `:` as it
    -- allows you to go into command mode.
    query_updaters = 'abcdefghijklmnopqrstuvwxyz0123456789_-.',
  }
<

------------------------------------------------------------------------------
                                                           *MiniStarter.content*
                             `MiniStarter.content`
Final content of Starter buffer

Generally, buffer content is a table in the form of "2d array" (or rather
"2d list" because number of elements can differ):
- Each element represents content line: an array with content units to be
  displayed in one buffer line.
- Each content unit is a table with at least the following elements:
    - "type" - string with type of content. Something like "item",
      "section", "header", "footer", "empty", etc.
    - "string" - which string should be displayed. May be an empty string.
    - "hl" - which highlighting should be applied to content string. May be
      `nil` for no highlighting.

See |MiniStarter.content_to_lines| for converting content to buffer lines
and |MiniStarter.content_to_items| - to list of parsed items.

Notes:
- Content units with type "item" also have `item` element with all
  information about an item it represents. Those elements are used directly
  to create an array of items used for query.

------------------------------------------------------------------------------
                                                     *MiniStarter.on_vimenter()*
                          `MiniStarter.on_vimenter`()
Act on |VimEnter|.

------------------------------------------------------------------------------
                                                            *MiniStarter.open()*
                          `MiniStarter.open`({buf_id})
Open Starter buffer

- Create buffer if necessary and move into it.
- Set buffer options. Note that settings are done with |noautocmd| to
  achieve a massive speedup.
- Set buffer mappings. Besides basic mappings (described inside "Lifecycle
  of Starter buffer" of |mini.starter|), map every character from
  `MiniStarter.config.query_updaters` to add itself to query with
  |MiniStarter.add_to_query|.
- Populate buffer with |MiniStarter.refresh|.
- Issue custom `MiniStarterOpened` event to allow acting upon opening
  Starter buffer. Use it with
  `autocmd User MiniStarterOpened <your command>`.

Parameters~
{buf_id} `(number)` Identifier of existing valid buffer (see |bufnr()|) to
  open inside. Default: create a new one.

------------------------------------------------------------------------------
                                                         *MiniStarter.refresh()*
                            `MiniStarter.refresh`()
Refresh Starter buffer

- Normalize `MiniStarter.config.items`:
    - Flatten: recursively (in depth-first fashion) parse its elements. If
      function is found, execute it and continue with parsing its output
      (this allows deferring item collection up until it is actually
      needed).  If proper item is found (table with fields `action`,
      `name`, `section`), add it to output.
    - Sort: order first by section and then by item id (both in order of
      appearance).
- Normalize `MiniStarter.config.header` and `MiniStarter.config.footer` to
  be multiple lines by splitting at `\n`. If function - evaluate it first.
- Make initial buffer content (see |MiniStarter.content| for a description
  of what a buffer content is). It consist from content lines with single
  content unit:
    - First lines contain strings of normalized header.
    - Body is for normalized items. Section names have own lines preceded
      by empty line.
    - Last lines contain separate strings of normalized footer.
- Sequentially apply hooks from `MiniStarter.config.content_hooks` to
  content. Output of one hook serves as input to the next.
- Gather final items from content with |MiniStarter.content_to_items|.
- Convert content to buffer lines with |MiniStarter.content_to_lines| and
  add them to buffer.
- Add highlighting of content units.
- Position cursor.
- Make current query. This results into some items being marked as
  "inactive" and updating highlighting of current query on "active" items.

Note: this function is executed on every |VimResized| to allow more
responsive behavior.

------------------------------------------------------------------------------
                                                           *MiniStarter.close()*
                             `MiniStarter.close`()
Close Starter buffer

------------------------------------------------------------------------------
                                                          *MiniStarter.sections*
                             `MiniStarter.sections`
Table of pre-configured sections

------------------------------------------------------------------------------
                                        *MiniStarter.sections.builtin_actions()*
                    `MiniStarter.sections.builtin_actions`()
Section with builtin actions

Return~
`(table)` Array of items.

------------------------------------------------------------------------------
                                               *MiniStarter.sections.sessions()*
                 `MiniStarter.sections.sessions`({n}, {recent})
Section with |MiniSessions| sessions

Sessions are taken from |MiniSessions.detected|. Notes:
- If it shows "'mini.sessions' is not set up", it means that you didn't
  call `require('mini.sessions').setup()`.
- If it shows "There are no detected sessions in 'mini.sessions'", it means
  that there are no sessions at the current sessions directory. Either
  create session or supply different directory where session files are
  stored (see |MiniSessions.setup|).
- Local session (if detected) is always displayed first.

Parameters~
{n} `(number)` Number of returned items. Default: 5.
{recent} `(boolean)` Whether to use recent sessions (instead of
  alphabetically by name). Default: true.

Return~
`(function)` Function which returns array of items.

------------------------------------------------------------------------------
                                           *MiniStarter.sections.recent_files()*
      `MiniStarter.sections.recent_files`({n}, {current_dir}, {show_path})
Section with most recently used files

Files are taken from |vim.v.oldfiles|.

Parameters~
{n} `(number)` Number of returned items. Default: 5.
{current_dir} `(boolean)` Whether to return files only from current working
  directory. Default: `false`.
{show_path} `(boolean)` Whether to append file name with its full path.
  Default: `true`.

Return~
`(function)` Function which returns array of items.

------------------------------------------------------------------------------
                                              *MiniStarter.sections.telescope()*
                       `MiniStarter.sections.telescope`()
Section with basic Telescope pickers relevant to start screen

Return~
`(function)` Function which returns array of items.

------------------------------------------------------------------------------
                                                          *MiniStarter.gen_hook*
                             `MiniStarter.gen_hook`
Table with pre-configured content hook generators

Each element is a function which returns content hook. So to use them
inside |MiniStarter.setup|, call them.

------------------------------------------------------------------------------
                                                *MiniStarter.gen_hook.padding()*
                 `MiniStarter.gen_hook.padding`({left}, {top})
Hook generator for padding

Output is a content hook which adds constant padding from left and top.
This allows tweaking the screen position of buffer content.

Parameters~
{left} `(number)` Number of empty spaces to add to start of each content
  line. Default: 0.
{top} `(number)` Number of empty lines to add to start of content.
  Default: 0.

Return~
`(function)` Content hook.

------------------------------------------------------------------------------
                                          *MiniStarter.gen_hook.adding_bullet()*
         `MiniStarter.gen_hook.adding_bullet`({bullet}, {place_cursor})
Hook generator for adding bullet to items

Output is a content hook which adds supplied string to be displayed to the
left of item.

Parameters~
{bullet} `(string)` String to be placed to the left of item name.
  Default: "░ ".
{place_cursor} `(boolean)` Whether to place cursor on the first character
  of bullet when corresponding item becomes current. Default: true.

Return~
`(function)` Content hook.

------------------------------------------------------------------------------
                                               *MiniStarter.gen_hook.indexing()*
        `MiniStarter.gen_hook.indexing`({grouping}, {exclude_sections})
Hook generator for indexing items

Output is a content hook which adds unique index to the start of item's
name. It results into shortening queries required to choose an item (at
expense of clarity).

Parameters~
{grouping} `(string)` One of "all" (number indexing across all sections) or
  "section" (letter-number indexing within each section). Default: "all".
{exclude_sections} `(table)` Array of section names (values of `section`
  element of item) for which index won't be added. Default: `{}`.

Return~
`(function)` Content hook.

------------------------------------------------------------------------------
                                               *MiniStarter.gen_hook.aligning()*
           `MiniStarter.gen_hook.aligning`({horizontal}, {vertical})
Hook generator for aligning content

Output is a content hook which independently aligns content horizontally
and vertically. Basically, this computes left and top pads for
|MiniStarter.gen_hook.padding| such that output lines would appear aligned
in certain way.

Parameters~
{horizontal} `(string)` One of "left", "center", "right". Default: "left".
{vertical} `(string)` One of "top", "center", "bottom". Default: "top".

Return~
`(function)` Content hook.

------------------------------------------------------------------------------
                                                  *MiniStarter.content_coords()*
              `MiniStarter.content_coords`({content}, {predicate})
Helper to iterate through content

Basically, this traverses content "2d array" (in depth-first fashion; top
to bottom, left to right) and returns "coordinates" of units for which
`predicate` is true-ish.

Parameters~
{content} `(table)` Content "2d array".
{predicate} `(function|string|nil)` Predictate to filter units. If it is:
   - Function, then it is evaluated with unit as input.
   - String, then it checks unit to have this type (allows easy getting of
     units with some type).
   - `nil`, all units are kept.

Return~
`(table)` Array of resulting units' coordinates. Each coordinate is a
  table with <line> and <unit> keys. To retrieve actual unit from coordinate
  `c`, use `content[c.line][c.unit]`.

------------------------------------------------------------------------------
                                                *MiniStarter.content_to_lines()*
                   `MiniStarter.content_to_lines`({content})
Convert content to buffer lines

One buffer line is made by concatenating `string` element of units within
same content line.

Parameters~
{content} `(table)` Content "2d array".

Return~
`(table)` Array of strings for each buffer line.

------------------------------------------------------------------------------
                                                *MiniStarter.content_to_items()*
                   `MiniStarter.content_to_items`({content})
Convert content to items

Parse content (in depth-first fashion) and retrieve each item from `item`
element of content units with type "item". This also:
- Computes some helper information about how item will be actually
  displayed (after |MiniStarter.content_to_lines|) and minimum number of
  prefix characters needed for a particular item to be queried single.
- Modifies item's `name` element taking it from corresponing `string`
  element of content unit. This allows modifying item's `name` at the stage
  of content hooks (like, for example, in |MiniStarter.gen_hook.indexing|).

Parameters~
{content} `(table)` Content "2d array".

Return~
`(table)` Array of items.

------------------------------------------------------------------------------
                                               *MiniStarter.eval_current_item()*
                       `MiniStarter.eval_current_item`()
Evaluate current item

------------------------------------------------------------------------------
                                             *MiniStarter.update_current_item()*
                 `MiniStarter.update_current_item`({direction})
Update current item

This makes next (with respect to `direction`) active item to be current.

Parameters~
{direction} `(string)` One of "next" or "previous".

------------------------------------------------------------------------------
                                                    *MiniStarter.add_to_query()*
                       `MiniStarter.add_to_query`({char})
Add character to current query

- Update current query by appending `char` to its end (only if it results
  into at least one active item) or delete latest character if `char` is `nil`.
- Recompute status of items: "active" if its name starts with new query,
  "inactive" otherwise.
- Update highlighting: whole strings for "inactive" items, current query
  for "active" items.

Parameters~
{char} `(string)` Single character to be added to query. If `nil`, deletes
  latest character from query.

------------------------------------------------------------------------------
                                                       *MiniStarter.set_query()*
                        `MiniStarter.set_query`({query})
Set current query

Parameters~
{query} `(string|nil)` Query to be set (only if it results into at least one
  active item). Default: `nil` for setting query to empty string, which
  essentially resets query.

------------------------------------------------------------------------------
                                                  *MiniStarter.on_cursormoved()*
                         `MiniStarter.on_cursormoved`()
Act on |CursorMoved| by repositioning cursor in fixed place.


==============================================================================
------------------------------------------------------------------------------
                                                               *mini.statusline*
                                                                *MiniStatusline*
Minimal and fast statusline module with opinionated default look.
Special features: change color depending on current mode and compact
version of sections activated when window width is small enough.

Features:
- Built-in active mode indicator with colors.
- Sections can hide information when window is too narrow (specific window
  width is configurable per section).
- Define own custom statusline structure for active and inactive windows.
  This is done with a function which should return string appropriate for
  |statusline|. Its code should be similar to default one with structure:
    - Compute string data for every section you want to be displayed.
    - Combine them in groups with |MiniStatusline.combine_groups()|.

# Dependencies~

Suggested dependencies (provide extra functionality, statusline will work
without them):
- Nerd font (to support extra icons).
- Plugin 'lewis6991/gitsigns.nvim' for Git information in
  |MiniStatusline.section_git|. If missing, no section will be shown.
- Plugin 'kyazdani42/nvim-web-devicons' for filetype icons in
  `MiniStatusline.section_fileinfo`. If missing, no icons will be shown.

# Setup~

This module needs a setup with `require('mini.statusline').setup({})`
(replace `{}` with your `config` table). It will create global Lua table
`MiniStatusline` which you can use for scripting or manually (with
`:lua MiniStatusline.*`).

See |MiniStatusline.config| for `config` structure and default values. For
some content examples, see |MiniStatusline-example-content|.

# Highlight groups~

Highlight depending on mode (second output from |MiniStatusline.section_mode|):
* `MiniStatuslineModeNormal` - Normal mode.
* `MiniStatuslineModeInsert` - Insert mode.
* `MiniStatuslineModeVisual` - Visual mode.
* `MiniStatuslineModeReplace` - Replace mode.
* `MiniStatuslineModeCommand` - Command mode.
* `MiniStatuslineModeOther` - other modes (like Terminal, etc.).

Highlight used in default statusline:
* `MiniStatuslineDevinfo` - for "dev info" group
  (|MiniStatusline.section_git| and |MiniStatusline.section_diagnostics|).
* `MiniStatuslineFilename` - for |MiniStatusline.section_filename| section.
* `MiniStatuslineFileinfo` - for |MiniStatusline.section_fileinfo| section.

Other groups:
* `MiniStatuslineInactive` - highliting in not focused window.

To change any highlight group, modify it directly with |:highlight|.

# Disabling~

To disable (show empty statusline), set `g:ministatusline_disable`
(globally) or `b:ministatusline_disable` (for a buffer) to `v:true`.
Considering high number of different scenarios and customization
intentions, writing exact rules for disabling module's functionality is
left to user. See |mini.nvim-disabling-recipes| for common recipes.

------------------------------------------------------------------------------
                                                *MiniStatusline-example-content*
Example content

# Default content~

This function is used as default value for active content:
>
  function()
    local mode, mode_hl = MiniStatusline.section_mode({ trunc_width = 120 })
    local git           = MiniStatusline.section_git({ trunc_width = 75 })
    local diagnostics   = MiniStatusline.section_diagnostics({ trunc_width = 75 })
    local filename      = MiniStatusline.section_filename({ trunc_width = 140 })
    local fileinfo      = MiniStatusline.section_fileinfo({ trunc_width = 120 })
    local location      = MiniStatusline.section_location({ trunc_width = 75 })

    return MiniStatusline.combine_groups({
      { hl = mode_hl,                  strings = { mode } },
      { hl = 'MiniStatuslineDevinfo',  strings = { git, diagnostics } },
      '%<', -- Mark general truncate point
      { hl = 'MiniStatuslineFilename', strings = { filename } },
      '%=', -- End left alignment
      { hl = 'MiniStatuslineFileinfo', strings = { fileinfo } },
      { hl = mode_hl,                  strings = { location } },
    })
  end
<
# Show boolean options~

To compute section string for boolean option use variation of this code
snippet inside content function (you can modify option itself, truncation
width, short and long displayed names):
>
  local spell = vim.wo.spell and (MiniStatusline.is_truncated(120) and 'S' or 'SPELL') or ''
<
Here `x and y or z` is a common Lua way of doing ternary operator: if `x`
is `true`-ish then return `y`, if not - return `z`.

------------------------------------------------------------------------------
                                                        *MiniStatusline.setup()*
                        `MiniStatusline.setup`({config})
Module setup

Parameters~
{config} `(table)` Module config table. See |MiniStatusline.config|.

Usage~
`require('mini.statusline').setup({})` (replace `{}` with your `config` table)

------------------------------------------------------------------------------
                                                         *MiniStatusline.config*
                            `MiniStatusline.config`
Module config

Default values:
>
  MiniStatusline.config = {
    -- Content of statusline as functions which return statusline string. See
    -- `:h statusline` and code of default contents (used instead of `nil`).
    content = {
      -- Content for active window
      active = nil,
      -- Content for inactive window(s)
      inactive = nil,
    },

    -- Whether to set Vim's settings for statusline (make it always shown with
    -- 'laststatus' set to 2). To use global statusline in Neovim>=0.7.0, set
    -- this to `false` and 'laststatus' to 3.
    set_vim_settings = true,
  }
<

------------------------------------------------------------------------------
                                                       *MiniStatusline.active()*
                           `MiniStatusline.active`()
Compute content for active window

------------------------------------------------------------------------------
                                                     *MiniStatusline.inactive()*
                          `MiniStatusline.inactive`()
Compute content for inactive window

------------------------------------------------------------------------------
                                               *MiniStatusline.combine_groups()*
                   `MiniStatusline.combine_groups`({groups})
Combine groups of sections

Each group can be either a string or a table with fields `hl` (group's
highlight group) and `strings` (strings representing sections).

General idea of this function is as follows;
- String group is used as is (useful for special strings like `%<` or `%=`).
- Each table group has own highlighting in `hl` field (if missing, the
  previous one is used) and string parts in `strings` field. Non-empty
  strings from `strings` are separated by one space. Non-empty groups are
  separated by two spaces (one for each highlighting).

Parameters~
{groups} `(string|table)` Array of groups.

Return~
`(string)` String suitable for 'statusline'.

------------------------------------------------------------------------------
                                                 *MiniStatusline.is_truncated()*
                  `MiniStatusline.is_truncated`({trunc_width})
Decide whether to truncate

This basically computes window width and compares it to `trunc_width`: if
window is smaller then truncate; otherwise don't. Don't truncate by
default.

Use this to manually decide if section needs truncation or not.

Parameters~
{trunc_width} `(number)` Truncation width. If `nil`, output is `false`.

Return~
`(boolean)` Whether to truncate.

------------------------------------------------------------------------------
                                                 *MiniStatusline.section_mode()*
                     `MiniStatusline.section_mode`({args})
Section for Vim |mode()|

Short output is returned if window width is lower than `args.trunc_width`.

Parameters~
{args} `(table)` Section arguments.

Return~
`(...)` Section string and mode's highlight group.

------------------------------------------------------------------------------
                                                  *MiniStatusline.section_git()*
                      `MiniStatusline.section_git`({args})
Section for Git information

Normal output contains name of `HEAD` (via |b:gitsigns_head|) and chunk
information (via |b:gitsigns_status|). Short output - only name of `HEAD`.
Note: requires 'lewis6991/gitsigns' plugin.

Short output is returned if window width is lower than `args.trunc_width`.

Parameters~
{args} `(table)` Section arguments. Use `args.icon` to supply your own icon.

Return~
`(string)` Section string.

------------------------------------------------------------------------------
                                          *MiniStatusline.section_diagnostics()*
                  `MiniStatusline.section_diagnostics`({args})
Section for Neovim's builtin diagnostics

Shows nothing if there is no attached LSP clients or for short output.
Otherwise uses builtin Neovim capabilities to compute and show number of
errors ('E'), warnings ('W'), information ('I'), and hints ('H').

Short output is returned if window width is lower than `args.trunc_width`.

Parameters~
{args} `(table)` Section arguments. Use `args.icon` to supply your own icon.

Return~
`(string)` Section string.

------------------------------------------------------------------------------
                                             *MiniStatusline.section_filename()*
                   `MiniStatusline.section_filename`({args})
Section for file name

Show full file name or relative in short output.

Short output is returned if window width is lower than `args.trunc_width`.

Parameters~
{args} `(table)` Section arguments.

Return~
`(string)` Section string.

------------------------------------------------------------------------------
                                             *MiniStatusline.section_fileinfo()*
                   `MiniStatusline.section_fileinfo`({args})
Section for file information

Short output contains only extension and is returned if window width is
lower than `args.trunc_width`.

Parameters~
{args} `(table)` Section arguments.

Return~
`(string)` Section string.

------------------------------------------------------------------------------
                                             *MiniStatusline.section_location()*
                   `MiniStatusline.section_location`({args})
Section for location inside buffer

Show location inside buffer in the form:
- Normal: '<cursor line>|<total lines>│<cursor column>|<total columns>'.
- Short: '<cursor line>│<cursor column>'.

Short output is returned if window width is lower than `args.trunc_width`.

Parameters~
{args} `(table)` Section arguments.

Return~
`(string)` Section string.

------------------------------------------------------------------------------
                                          *MiniStatusline.section_searchcount()*
                  `MiniStatusline.section_searchcount`({args})
Section for current search count

Show the current status of |searchcount()|. Empty output is returned if
window width is lower than `args.trunc_width`, search highlighting is not
on (see |v:hlsearch|), or if number of search result is 0.

`args.options` is forwarded to |searchcount()|.  By default it recomputes
data on every call which can be computationally expensive (although still
usually same order of magnitude as 0.1 ms). To prevent this, supply
`args.options = {recompute = false}`.

Parameters~
{args} `(table)` Section arguments.

Return~
`(string)` Section string.


==============================================================================
------------------------------------------------------------------------------
                                                                 *mini.surround*
                                                                  *MiniSurround*
Custom somewhat minimal and fast surrounding Lua plugin. This is mostly
a reimplementation of the core features of 'machakann/vim-sandwich' with a
couple more on top (find surrounding, highlight surrounding). Can be
configured to have experience similar to 'tpope/vim-surround'.

Features:
- Actions (all of them are dot-repeatable out of the box):
    - Add surrounding with `sa` (in visual mode or on motion).
    - Delete surrounding with `sd`.
    - Replace surrounding with `sr`.
    - Find surrounding with `sf` or `sF` (move cursor right or left).
    - Highlight surrounding with `sh`.
    - Change number of neighbor lines with `sn` (see |MiniSurround-algorithm|).
- Surrounding is identified by a single character as both "input" (in
  `delete` and `replace` start, `find`, and `highlight`) and "output" (in
  `add` and `replace` end):
    - 'f' - function call (string of alphanumeric symbols or '_' or '.'
      followed by balanced '()'). In "input" finds function call, in
      "output" prompts user to enter function name.
    - 'i' - interactive. Prompts user to enter left and right parts.
    - 't' - tag. In "input" finds tab with same identifier, in "output"
      prompts user to enter tag name.
    - All symbols in brackets '()', '[]', '{}', '<>". In "input' represents
      balanced brackets, in "output" - left and right parts of brackets.
    - All other alphanumeric, punctuation, or space characters represent
      surrounding with identical left and right parts.

Known issues which won't be resolved:
- Search for surrounding is done using Lua patterns (regex-like approach).
  So certain amount of false positives should be expected.
- When searching for "input" surrounding, there is no distinction if it is
  inside string or comment. So in this case there will be not proper match
  for a function call: 'f(a = ")", b = 1)'.
- Tags are searched using regex-like methods, so issues are inevitable.
  Overall it is pretty good, but certain cases won't work. Like self-nested
  tags won't match correctly on both ends: '<a><a></a></a>'.

# Setup~

This module needs a setup with `require('mini.surround').setup({})`
(replace `{}` with your `config` table). It will create global Lua table
`MiniSurround` which you can use for scripting or manually (with
`:lua MiniSurround.*`).

See |MiniSurround.config| for `config` structure and default values. It
also has example setup providing experience similar to 'tpope/vim-surround'.

# Example usage~

- `saiw)` - add (`sa`) for inner word (`iw`) parenthesis (`)`).
- `saiwi[[<CR>]]<CR>` - add (`sa`) for inner word (`iw`) interactive
  surrounding (`i`): `[[` for left and `]]` for right.
- `sdf` - delete (`sd`) surrounding function call (`f`).
- `sr)tdiv<CR>` - replace (`sr`) surrounding parenthesis (`)`) with tag
  (`t`) with identifier 'div' (`div<CR>` in command line prompt).
- `sff` - find right (`sf`) part of surrounding function call (`f`).
- `sh}` - highlight (`sh`) for a brief period of time surrounding curly
  brackets (`}`)

# Highlight groups~

* `MiniSurround` - highlighting of requested surrounding.

To change any highlight group, modify it directly with |:highlight|.

# Disabling~

To disable, set `g:minisurround_disable` (globally) or
`b:minisurround_disable` (for a buffer) to `v:true`. Considering high
number of different scenarios and customization intentions, writing exact
rules for disabling module's functionality is left to user. See
|mini.nvim-disabling-recipes| for common recipes.

------------------------------------------------------------------------------
                                                        *MiniSurround-algorithm*
Algorithm design

- Adding "output" surrounding has a fairly straightforward algorithm:
    - Determine places for left and right parts (via `<>`/`[]` marks or by
      finding some other surrounding).
    - Determine left and right parts of surrounding via using custom and
      builtin surroundings (via `output` field of surrounding info see
      |MiniSurround.config|).
    - Properly add.
- Finding "input" surrounding is a lot more complicated and is a reason why
  this implementation is only somewhat minimal. In a nutshell, current
  algorithm `searches in the neighborhood lines based on a certain pattern
  and search method a best match`. More detailed:
    - Extract neighborhood of cursor line: no more than
      `MiniSurround.config.n_lines` before, cursor line itself, no more than
      `MiniSurround.config.n_lines` after. Note: actual search is done
      firstly on cursor line (i.e. with `n_lines = 0`), as it is the most
      frequent usage and only then searches in wholeneighborhood.
    - Convert it to "1d neighborhood" by concatenating with '\n' delimiter.
      Compute location of current cursor position in this line.
    - Given Lua pattern for an "input" surrounding (`input.find` field of
      surrounding info; see |MiniSurround.config|), search for best match.
      That is:
        - Match with span covering cursor position. If several, try to pick
          one with smallest width.
        - If no covering match, pick one of "previous" (nearest
          non-covering to the left) or "next" (nearest non-covering to the
          right) matches, depending on `config.search_method` (see
          |MiniSurround.config| for more details).
      This computation is an iterative procedure, duration of which heavily
      depends on the length of "1d neighborhood" and frequency of pattern
      matching. If no match is found, there is no surrounding. Note: with
      current approach smallest width of covering match is ensured by
      checking match on covering substrings. This may have unwanted
      consequences when using complex Lua patterns (like `%f[]` at the
      pattern end, for example).
    - Compute parts of "1d neighborhood" that represent left and right part
      of found surrounding. This is done by using pattern from
      `input.extract` field of surrounding info; see |MiniSurround.config|.
      Note: pattern is used on a matched substring, so using `^` and `$` at
      start and end of pattern means start and end of substring.
    - Convert "1d offsets" of found parts to their positions in buffer.

------------------------------------------------------------------------------
                                                          *MiniSurround.setup()*
                         `MiniSurround.setup`({config})
Module setup

Parameters~
{config} `(table)` Module config table. See |MiniSurround.config|.

Usage~
`require('mini.surround').setup({})` (replace `{}` with your `config` table)

------------------------------------------------------------------------------
                                                           *MiniSurround.config*
                             `MiniSurround.config`
Module config

Default values:
>
  MiniSurround.config = {
    -- Add custom surroundings to be used on top of builtin ones. For more
    -- information with examples, see `:h MiniSurround.config`.
    custom_surroundings = nil,

    -- Duration (in ms) of highlight when calling `MiniSurround.highlight()`
    highlight_duration = 500,

    -- Module mappings. Use `''` (empty string) to disable one.
    mappings = {
      add = 'sa', -- Add surrounding in Normal and Visual modes
      delete = 'sd', -- Delete surrounding
      find = 'sf', -- Find surrounding (to the right)
      find_left = 'sF', -- Find surrounding (to the left)
      highlight = 'sh', -- Highlight surrounding
      replace = 'sr', -- Replace surrounding
      update_n_lines = 'sn', -- Update `n_lines`
    },

    -- Number of lines within which surrounding is searched
    n_lines = 20,

    -- How to search for surrounding (first inside current line, then inside
    -- neighborhood). One of 'cover', 'cover_or_next', 'cover_or_prev',
    -- 'cover_or_nearest'. For more details, see `:h MiniSurround.config`.
    search_method = 'cover',
  }
<
# Setup similar to 'tpope/vim-surround'~

This module is primarily designed after 'machakann/vim-sandwich'. To get
behavior closest to 'tpope/vim-surround' (but not identical), use this setup:
>
  require('mini.surround').setup({
    custom_surroundings = {
      ['('] = { output = { left = '( ', right = ' )' } },
      ['['] = { output = { left = '[ ', right = ' ]' } },
      ['{'] = { output = { left = '{ ', right = ' }' } },
      ['<'] = { output = { left = '< ', right = ' >' } },
    },
    mappings = {
      add = 'ys',
      delete = 'ds',
      find = '',
      find_left = '',
      highlight = '',
      replace = 'cs',
      update_n_lines = '',
    },
    search_method = 'cover_or_next',
  })

  -- Remap adding surrounding to Visual mode selection
  vim.api.nvim_set_keymap('x', 'S', [[:<C-u>lua MiniSurround.add('visual')<CR>]], { noremap = true })

  -- Make special mapping for "add surrounding for line"
  vim.api.nvim_set_keymap('n', 'yss', 'ys_', { noremap = false })
<
# Options~

## Custom surroundings~

User can define own surroundings by supplying `config.custom_surroundings`.
It should be a table with keys being single character surrounding identifier
and values - surround info or function returning it. Surround info itself
is a table with keys:
- <input> - defines how to find and extract surrounding for "input"
  operations (like `delete`). A table with fields <find> (Lua pattern
  applied for search in neighborhood) and <extract> (Lua pattern applied
  for extracting left and right parts; should have two matches).
- <output> - defines what to add on left and right for "output" operations
  (like `add`). A table with <left> (plain text string) and <right> (plain
  text string) fields.

Example of surround info for builtin `(` identifier:>
  {
    input = { find = '%b()', extract = '^(.).*(.)$' },
    output = { left = '(', right = ')' }
  }
<
General recommendations:
- In `config.custom_surroundings` only some data can be defined (like only
  `input.find`). Other fields will be taken from builtin surroundings.
- Function returning table with surround info instead of table itself is
  helpful when user input is needed (like asking for function name). Use
  |input()| or |MiniSurround.user_inpu()|. Return `nil` to stop any current
  surround operation.
- In input patterns try to use lazy quantifier instead of greedy ones (`.-`
  instead of `.*` or `.+`). That is because the underlying algorithm of
  finding smallest covering is better designed for lazy quantifier.
- Usage of frontier pattern `%f[]` not at the end of pattern can be useful
  to extend match to the left. Like `%f[%w]%w+%b()` matches simplified
  function call while capturing whole function name instead of last symbol.
- Usage of frontier pattern at the end of match is currently problematic
  because output "smallest width" match is computed by checking the match
  on substrings. And frontier pattern matches at the end of substring for
  appropriate last character. So `%f[%w]%w+%f[%W]` won't match whole word.

Present builtin surroundings by their single character identifier:
- `(` and `)` - balanced pair of `()`.
- `[` and `]` - balanced pair of `[]`.
- `{` and `}` - balanced pair of `{}`.
- `<` and `>` - balanced pair of `<>`.
- `f` - function call. Maximum set of allowed symbols (alphanumeric, `_`
  and `.`) followed by balanced pair of `()`.
- `i` - interactive, prompts user to enter left and right parts.
- `t` - HTML tags.
- Any other non-recognized identifier represents surrounding with identical
  left and right parts equal to identifier (like `_`, etc.).

Example of using `config.custom_surroundings`:
>
  require('mini.surround').setup({
    custom_surroundings = {
      -- Make `)` insert parts with spaces. `input` pattern stays the same.
      [')'] = { output = { left = '( ', right = ' )' } },

      -- Modify `f` (function call) to find functions with only alphanumeric
      -- characters in its name.
      f = { input = { find = '%f[%w]%w+%b()' } },

      -- Create custom surrouding for Lua's block string `[[...]]`
      s = {
        input = { find = '%[%[.-%]%]', extract = '^(..).*(..)$' },
        output = { left = '[[', right = ']]' },
      },

      -- Use function to compute surrounding info
      ['*'] = {
        input = function()
          local n_star = MiniSurround.user_input('Number of * to find: ')
          local many_star = string.rep('%*', tonumber(n_star) or 1)
          local find = string.format('%s.-%s', many_star, many_star)
          local extract = string.format('^(%s).*(%s)$', many_star, many_star)
          return { find = find, extract = extract }
        end,
        output = function()
          local n_star = MiniSurround.user_input('Number of * to output: ')
          local many_star = string.rep('*', tonumber(n_star) or 1)
          return { left = many_star, right = many_star }
        end,
      },
    },
  })
<
## Search method~

Value of `config.search_method` defines how best match search for "input"
surrounding is done when there is no covering match (with span covering
cursor position) found within searched neighborhood. Based on its value,
one of "previous", "next", or neither match is used as output.
Its possible values are:
- `'cover'` (default) - don't use either "previous" or "next"; report that
  there is no surrounding found.
- `'cover_or_prev'` - use previous.
- `'cover_or_next'` - use next.
- `'cover_or_nearest'` - use nearest to current cursor position. Distance
  is computed based on "1d neighborhood" using nearest part of
  surroundings. Next is used in case of a tie.

Note: search is first performed on the cursor line and only after failure -
on the whole neighborhood defined by `config.n_lines`. This means that with
`config.search_method` not equal to `'cover'`, "previous" or "next"
surrounding will end up as search result if they present on current line
although covering match might be found in bigger, whole neighborhood. This
design is based on observation that most of the time operation involving
surrounding is done withtin cursor line.

Here is an example of how replacing `)` with `]` surrounding is done based
on a value of `'config.search_method'` when cursor is inside `bbb` word:
- `search_method = 'cover'`:         `(a) bbb (c)` -> `(a) bbb (c)` (with message)
- `search_method = 'cover_or_prev'`: `(a) bbb (c)` -> `[a] bbb (c)`
- `search_method = 'cover_or_next'`: `(a) bbb (c)` -> `(a) bbb [c]`
- `search_method = 'cover_or_nearest'`: depends on cursor position.
  For first `b` - as in `cover_or_prev` (as previous match is nearer), for
  second and third - as in `cover_or_next` (as next match is nearer).

------------------------------------------------------------------------------
                                                       *MiniSurround.operator()*
                    `MiniSurround.operator`({task}, {cache})
Surround operator

Main function to be used in expression mappings. No need to use it
directly, everything is setup in |MiniSurround.setup|.

Parameters~
{task} `(string)` Name of surround task.
{cache} `(table)` Task cache.

------------------------------------------------------------------------------
                                                            *MiniSurround.add()*
                           `MiniSurround.add`({mode})
Add surrounding

No need to use it directly, everything is setup in |MiniSurround.setup|.

Parameters~
{mode} `(string)` Mapping mode (normal by default).

------------------------------------------------------------------------------
                                                         *MiniSurround.delete()*
                            `MiniSurround.delete`()
Delete surrounding

No need to use it directly, everything is setup in |MiniSurround.setup|.

------------------------------------------------------------------------------
                                                        *MiniSurround.replace()*
                            `MiniSurround.replace`()
Replace surrounding

No need to use it directly, everything is setup in |MiniSurround.setup|.

------------------------------------------------------------------------------
                                                           *MiniSurround.find()*
                             `MiniSurround.find`()
Find surrounding

No need to use it directly, everything is setup in |MiniSurround.setup|.

------------------------------------------------------------------------------
                                                      *MiniSurround.highlight()*
                           `MiniSurround.highlight`()
Highlight surrounding

No need to use it directly, everything is setup in |MiniSurround.setup|.

------------------------------------------------------------------------------
                                                 *MiniSurround.update_n_lines()*
                        `MiniSurround.update_n_lines`()
Update `MiniSurround.config.n_lines`

Convenient wrapper for updating `MiniSurround.config.n_lines` in case the
default one is not appropriate.

------------------------------------------------------------------------------
                                                     *MiniSurround.user_input()*
                  `MiniSurround.user_input`({prompt}, {text})
Ask user for input

This is mainly a wrapper for |input()| which allows empty string as input,
cancelling with `<Esc>` and `<C-c>`, and slightly modifies prompt. Use it
to ask for input inside function custom surrounding (see |MiniSurround.config|).


==============================================================================
------------------------------------------------------------------------------
                                                                  *mini.tabline*
                                                                   *MiniTabline*
Minimal and fast tabline module. General idea: show all listed buffers in
readable way with minimal total width. Also allow showing extra information
section in case of multiple vim tabpages. Inspired by
[ap/vim-buftabline](https://github.com/ap/vim-buftabline).

Features:
- Buffers are listed in the order of their identifier (see |bufnr()|).
- Different highlight groups for "states" of buffer affecting 'buffer tabs':
- Buffer names are made unique by extending paths to files or appending
  unique identifier to buffers without name.
- Current buffer is displayed "optimally centered" (in center of screen
  while maximizing the total number of buffers shown) when there are many
  buffers open.
- 'Buffer tabs' are clickable if Neovim allows it.

What it doesn't do:
- Custom buffer order is not supported.

# Dependencies~

Suggested dependencies (provide extra functionality, tabline will work
without them):
- Plugin 'kyazdani42/nvim-web-devicons' for filetype icons near the buffer
  name. If missing, no icons will be shown.

# Setup~

This module needs a setup with `require('mini.tabline').setup({})`
(replace `{}` with your `config` table). It will create global Lua table
`MiniTabline` which you can use for scripting or manually (with
`:lua MiniTabline.*`).

See |MiniTabline.config| for `config` structure and default values.

# Highlight groups~

* `MiniTablineCurrent` - buffer is current (has cursor in it).
* `MiniTablineVisible` - buffer is visible (displayed in some window).
* `MiniTablineHidden` - buffer is hidden (not displayed).
* `MiniTablineModifiedCurrent` - buffer is modified and current.
* `MiniTablineModifiedVisible` - buffer is modified and visible.
* `MiniTablineModifiedHidden` - buffer is modified and hidden.
* `MiniTablineFill` - unused right space of tabline.
* `MiniTablineTabpagesection` - section with tabpage information.

To change any highlight group, modify it directly with |:highlight|.

# Disabling~

To disable (show empty tabline), set `g:minitabline_disable` (globally) or
`b:minitabline_disable` (for a buffer) to `v:true`. Considering high number
of different scenarios and customization intentions, writing exact rules
for disabling module's functionality is left to user. See
|mini.nvim-disabling-recipes| for common recipes. Note: after disabling,
tabline is not updated right away, but rather after dedicated event (see
|events| and `MiniTabline` |augroup|).

------------------------------------------------------------------------------
                                                           *MiniTabline.setup()*
                         `MiniTabline.setup`({config})
Module setup

Parameters~
{config} `(table)` Module config table. See |MiniTabline.config|.

Usage~
`require('mini.tabline').setup({})` (replace `{}` with your `config` table)

------------------------------------------------------------------------------
                                                            *MiniTabline.config*
                              `MiniTabline.config`
Module config

Default values:
>
  MiniTabline.config = {
    -- Whether to show file icons (requires 'kyazdani42/nvim-web-devicons')
    show_icons = true,

    -- Whether to set Vim's settings for tabline (make it always shown and
    -- allow hidden buffers)
    set_vim_settings = true,

    -- Where to show tabpage section in case of multiple vim tabpages.
    -- One of 'left', 'right', 'none'.
    tabpage_section = 'left',
  }
<

------------------------------------------------------------------------------
                                             *MiniTabline.make_tabline_string()*
                      `MiniTabline.make_tabline_string`()
Make string for |tabline|


==============================================================================
------------------------------------------------------------------------------
                                                               *mini.trailspace*
                                                                *MiniTrailspace*
Minimal and fast module for working with trailing whitespace.

Features:
- Highlighting is done only in modifiable buffer by default; only in Normal
  mode; stops in Insert mode and when leaving window.
- Trim all trailing whitespace with |MiniTrailspace.trim()| function.

# Setup~

This module needs a setup with `require('mini.trailspace').setup({})`
(replace `{}` with your `config` table). It will create global Lua table
`MiniTrailspace` which you can use for scripting or manually (with
`:lua MiniTrailspace.*`).

See |MiniTrailspace.config| for `config` structure and default values.

# Highlight groups~

* `MiniTrailspace` - highlight group for trailing space.

To change any highlight group, modify it directly with |:highlight|.

# Disabling~

To disable, set `g:minitrailspace_disable` (globally) or
`b:minitrailspace_disable` (for a buffer) to `v:true`. Considering high
number of different scenarios and customization intentions, writing exact
rules for disabling module's functionality is left to user. See
|mini.nvim-disabling-recipes| for common recipes. Note: after disabling
there might be highlighting left; it will be removed after next
highlighting update (see |events| and `MiniTrailspace` |augroup|).

------------------------------------------------------------------------------
                                                        *MiniTrailspace.setup()*
                        `MiniTrailspace.setup`({config})
Module setup

Parameters~
{config} `(table)` Module config table. See |MiniTrailspace.config|.

Usage~
`require('mini.trailspace').setup({})` (replace `{}` with your `config` table)

------------------------------------------------------------------------------
                                                         *MiniTrailspace.config*
                            `MiniTrailspace.config`
Module config

Default values:
>
  MiniTrailspace.config = {
    -- Highlight only in normal buffers (ones with empty 'buftype'). This is
    -- useful to not show trailing whitespace where it usually doesn't matter.
    only_in_normal_buffers = true,
  }
<

------------------------------------------------------------------------------
                                                    *MiniTrailspace.highlight()*
                          `MiniTrailspace.highlight`()
Highlight trailing whitespace in current window

------------------------------------------------------------------------------
                                                  *MiniTrailspace.unhighlight()*
                         `MiniTrailspace.unhighlight`()
Unhighlight trailing whitespace in current window

------------------------------------------------------------------------------
                                                         *MiniTrailspace.trim()*
                            `MiniTrailspace.trim`()
Trim trailing whitespace

------------------------------------------------------------------------------
                                          *MiniTrailspace.track_normal_buffer()*
                     `MiniTrailspace.track_normal_buffer`()
Track normal buffer

Designed to be used with |autocmd|. No need to use it directly.


 vim:tw=78:ts=8:noet:ft=help:norl: