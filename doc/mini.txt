==============================================================================
------------------------------------------------------------------------------
                                                                     *mini.nvim*
*mini.txt*  Collection of minimal, independent and fast Lua modules

Author:  Evgeni Chasnovski
License: MIT

|mini.nvim| is a collection of minimal, independent, and fast Lua modules
dedicated to improve Neovim (version 0.5 and higher) experience. Each
module can be considered as a separate sub-plugin.

Table of contents:
  General overview.................................................|mini.nvim|
  Plugin colorscheme..............................................|minischeme|
  Extended a/i textobjects...........................................|mini.ai|
  Base16 colorscheme creation....................................|mini.base16|
  Remove buffers..............................................|mini.bufremove|
  Comment.......................................................|mini.comment|
  Completion and signature help..............................|mini.completion|
  Highlight word under cursor................................|mini.cursorword|
  Generate help files...............................................|mini.doc|
  Fuzzy matching..................................................|mini.fuzzy|
  Visualize and operate on indent scope.....................|mini.indentscope|
  Jump cursor to a single character................................|mini.jump|
  Jump within visible lines......................................|mini.jump2d|
  Miscellaneous functions..........................................|mini.misc|
  Autopairs.......................................................|mini.pairs|
  Session management...........................................|mini.sessions|
  Start screen..................................................|mini.starter|
  Statusline.................................................|mini.statusline|
  Surround.....................................................|mini.surround|
  Tabline.......................................................|mini.tabline|
  Test Neovim plugins..............................................|mini.test|
  Trailspace (highlight and remove)..........................|mini.trailspace|

# General principles~

- <Design>. Each module is designed to solve a particular problem targeting
  balance between feature-richness (handling as many edge-cases as
  possible) and simplicity of implementation/support. Granted, not all of
  them ended up with the same balance, but it is the goal nevertheless.
- <Independence>. Modules are independent of each other and can be run
  without external dependencies. Although some of them may need
  dependencies for full experience.
- <Structure>. Each module is a submodule for a placeholder "mini" module. So,
  for example, "surround" module should be referred to as "mini.surround".
  As later will be explained, this plugin can also be referred to
  as "MiniSurround".
- <Setup>:
    - Each module (if needed) should be setup separately with
      `require(<name of module>).setup({})`
      (possibly replace {} with your config table or omit to use defaults).
      You can supply only values which differ from defaults, which will be
      used for the rest ones.
    - Call to module's `setup()` always creates a global Lua object with
      coherent camel-case name: `require('mini.surround').setup()` creates
      `_G.MiniSurround`. This allows for a simpler usage of plugin
      functionality: instead of `require('mini.surround')` use
      `MiniSurround` (or manually `:lua MiniSurround.*` in command line);
      available from `v:lua` like `v:lua.MiniSurround`. Considering this,
      "module" and "Lua object" names can be used interchangeably:
      'mini.surround' and 'MiniSurround' will mean the same thing.
    - Each supplied `config` table (after extending with default values) is
      stored in `config` field of global object. Like `MiniSurround.config`.
    - Values of `config`, which affect runtime activity, can be changed on
      the fly to have effect. For example, `MiniSurround.config.n_lines`
      can be changed during runtime; but changing
      `MiniSurround.config.mappings` won't have any effect (as mappings are
      created once during `setup()`).
- <Buffer local configuration>. Each module can be additionally configured
  to use certain runtime config settings locally to buffer. See
  |mini.nvim-buffer-local-config| for more information.
- <Disabling>. Each module's core functionality can be disabled globally or
  buffer-locally by creating appropriate global or buffer-scoped variables
  equal to |v:true|. See |mini.nvim-disabling-recipes| for common recipes.
- <Highlight groups>. Appearance of module's output is controlled by
  certain highlight group (see |highlight-groups|). To customize them, use
  |highlight| command. Note: currently not many Neovim themes support this
  plugin's highlight groups; fixing this situation is highly appreciated.
  To see a more calibrated look, use |MiniBase16| or plugin's colorscheme
  `minischeme`.
- <Stability>. Each module upon release is considered to be relatively
  stable: both in terms of setup and functionality. Any
  non-bugfix backward-incompatible change will be released gradually as
  much as possible.

# List of modules~

- |MiniAi| - Extend and create `a`/`i` textobjects (like in `di(` or
  `va"`). It enhances some builtin |text-objects| (like |a(|, |a)|, |a'|,
  and more), creates new ones (like `a*`, `a<Space>`, `af`, `a?`, and
  more), and allows user to create their own. Supports dot-repeat,
  `v:count`, different search methods, consecutive application, and
  customization via Lua patterns or functions. Has builtins for brackets,
  quotes, function call, argument, tag, user prompt, and any
  punctuation/digit/whitespace character.
- |MiniBase16| - fast implementation of base16 theme for manually supplied
  palette. Has unique palette generator which needs only background and
  foreground colors.
- |MiniBufremove| - buffer removing (unshow, delete, wipeout) while saving
  window layout.
- |MiniComment| - fast and familiar per-line code commenting.
- |MiniCompletion| - async (with customizable 'debounce' delay) 'two-stage
  chain completion': first builtin LSP, then configurable fallback. Also
  has functionality for completion item info and function signature (both
  in floating window appearing after customizable delay).
- |MiniCursorword| - automatic highlighting of word under cursor (displayed
  after customizable delay). Current word under cursor can be highlighted
  differently.
- |MiniDoc| - generation of help files from EmmyLua-like annotations.
  Allows flexible customization of output via hook functions. Used for
  documenting this plugin.
- |MiniFuzzy| - functions for fast and simple fuzzy matching. It has
  not only functions to perform fuzzy matching of one string to others, but
  also a sorter for |telescope.nvim|.
- |MiniIndentscope| - Visualize and operate on indent scope. Supports
  customization of debounce delay, animation style, and different
  granularity of options for scope computing algorithm.
- |MiniJump| - minimal and fast module for smarter jumping to a single
  character.
- |MiniJump2d| - minimal and fast Lua plugin for jumping (moving cursor)
  within visible lines via iterative label filtering. Supports custom jump
  targets (spots), labels, hooks, allowed windows and lines, and more.
- |MiniMisc| - collection of miscellaneous useful functions. Like `put()`
  and `put_text()` which print Lua objects to command line and current
  buffer respectively.
- |MiniPairs| - autopairs plugin which has minimal defaults and
  functionality to do per-key expression mappings.
- |MiniSessions| - session management (read, write, delete) which works
  using |mksession|. Implements both global (from configured directory) and
  local (from current directory) sessions.
- |MiniStarter| - minimal, fast, and flexible start screen. Displayed items
  are fully customizable both in terms of what they do and how they look
  (with reasonable defaults). Item selection can be done using prefix query
  with instant visual feedback.
- |MiniStatusline| - minimal and fast statusline. Has ability to use custom
  content supplied with concise function (using module's provided section
  functions) along with builtin default. For full experience needs [Nerd
  font](https://www.nerdfonts.com/),
  [gitsigns.nvim](https://github.com/lewis6991/gitsigns.nvim) plugin, and
  [nvim-web-devicons](https://github.com/kyazdani42/nvim-web-devicons)
  plugin (but works without any them).
- |MiniSurround| - fast surround plugin. Add, delete, replace, find,
  highlight surrounding (like pair of parenthesis, quotes, etc.). Has
  special "function call", "tag", and "interactive" surroundings. Supports
  dot-repeatability, textobject, motions.
- |MiniTest| - framework for writing extensive Neovim plugin tests.
  Supports hierarchical tests, hooks, parametrization, filtering (like from
  current file or cursor position), screen tests, "busted-style" emulation,
  customizable reporters, and more. Designed to be used with provided
  wrapper for managing child Neovim processes.
- |MiniTabline| - minimal tabline which always shows listed (see 'buflisted')
  buffers. Allows showing extra information section in case of multiple vim
  tabpages. For full experience needs
  [nvim-web-devicons](https://github.com/kyazdani42/nvim-web-devicons).
- |MiniTrailspace| - automatic highlighting of trailing whitespace with
  functionality to remove it.

------------------------------------------------------------------------------
                                                   *mini.nvim-disabling-recipes*
Common recipes for disabling functionality

Each module's core functionality can be disabled globally or buffer-locally
by creating appropriate global or buffer-scoped variables equal to
|v:true|. Functionality is disabled if at least one of `g:` or `b:`
variables is equal to `v:true`.

Variable names have the same structure: `{g,b}:mini*_disable` where `*` is
module's lowercase name. For example, `g:minicursorword_disable` disables
|mini.cursorword| globally and `b:minicursorword_disable` - for
corresponding buffer. Note: in this section disabling 'mini.cursorword' is
used as example; everything holds for other module variables.

Considering high number of different scenarios and customization intentions,
writing exact rules for disabling module's functionality is left to user.

# Manual disabling~

- Disable globally:
  Lua       - `:lua vim.g.minicursorword_disable=true`
  Vimscript - `:let g:minicursorword_disable=v:true`
- Disable for current buffer:
  Lua       - `:lua vim.b.minicursorword_disable=true`
  Vimscript - `:let b:minicursorword_disable=v:true`
- Toggle (disable if enabled, enable if disabled):
  Globally   - `:lua vim.g.minicursorword_disable = not vim.g.minicursorword_disable`
  For buffer - `:lua vim.b.minicursorword_disable = not vim.b.minicursorword_disable`

# Automated disabling~

- Disable for a certain |filetype| (for example, "markdown"):
  `autocmd Filetype markdown lua vim.b.minicursorword_disable = true`
- Enable only for certain filetypes (for example, "lua" and "python"):
  `au FileType * if index(['lua', 'python'], &ft) < 0 | let b:minicursorword_disable=v:true | endif`
- Disable in Insert mode (use similar pattern for Terminal mode or indeed
  any other mode change with |ModeChanged| starting from Neovim 0.7.0):
  `au InsertEnter * lua vim.b.minicursorword_disable = true`
  `au InsertLeave * lua vim.b.minicursorword_disable = false`
- Disable in Terminal buffer:
  `au TermOpen * lua vim.b.minicursorword_disable = true`

------------------------------------------------------------------------------
                                                 *mini.nvim-buffer-local-config*
Buffer local config

Each module can be additionally configured locally to buffer by creating
appropriate buffer-scoped variable with values you want to override. It
will affect only runtime options and not those used once during setup (like
`mappings` or `set_vim_settings`).

Variable names have the same structure: `b:mini*_config` where `*` is
module's lowercase name. For example, `b:minicursorword_config` can store
information about how |mini.cursorword| will act inside current buffer. Its
value should be a table with same structure as module's `config`.
Continuing example, `vim.b.minicursorword_config = { delay = 500 }` will
use delay 500 inside current buffer.

Considering high number of different scenarios and customization intentions,
writing exact rules for module's buffer local configuration is left to
user. It is done in similar fashion to |mini.nvim-disabling-recipes|.

Note: using function values inside buffer variables requires Neovim>=0.7.

------------------------------------------------------------------------------
                                                                    *minischeme*
# Plugin colorscheme~

This plugin comes with an official colorscheme named `minischeme`. This is
a |MiniBase16| theme created with faster version of the following Lua code: >
  require('mini.base16').setup({
    palette = palette, name = 'minischeme', use_cterm = true
  })
where `palette` is:
- For dark 'background':
    `require('mini.base16').mini_palette('#112641', '#e2e98f', 75)`
- For light 'background':
    `require('mini.base16').mini_palette('#e2e5ca', '#002a83', 75)`

Activate it as a regular |colorscheme|.


==============================================================================
------------------------------------------------------------------------------
                                                                       *mini.ai*
                                                                        *MiniAi*
Module for extending and creating `a`/`i` textobjects. It enhances some builtin
|text-objects| (like |a(|, |a)|, |a'|, and more), creates new ones
(like `a*`, `a<Space>`, `af`, `a?`, and more), and allows user to create their own.

Features:
- Customizable creation of `a`/`i` textobjects using Lua patterns and functions.
  Supports:
    - Dot-repeat.
    - |v:count|.
    - Different search methods (see |MiniAi.config|).
    - Consecutive application (update selection without leaving Visual mode).
    - Aliases for multiple textobjects.
- Comprehensive builtin textobjects (see more in |MiniAi-textobject-builtin|):
    - Balanced brackets (with and without whitespace) plus alias.
    - Balanced quotes plus alias.
    - Function call.
    - Argument.
    - Tag.
    - Derived from user prompt.
    - Default for punctuation, digit, or whitespace single character.
- Motions for jumping to left/right edge of textobject.

This module works by defining mappings for both `a` and `i` in Visual and
Operator-pending mode. After typing, they wait for single character user input
treated as textobject identifier and apply resolved textobject specification
(fall back to other mappings if can't find proper textobject id). For more
information see |MiniAi-textobject-specification| and |MiniAi-algorithm|.

Known issues which won't be resolved:
- Search for builtin textobjects is done mostly using Lua patterns
  (regex-like approach). Certain amount of false positives is to be expected.
- During search for builtin textobjects there is no distinction if it is
  inside string or comment. For example, in the following case there will
  be wrong match for a function call: `f(a = ")", b = 1)`.

General rule of thumb: any instrument using available parser for document
structure (like treesitter) will usually provide more precise results. This
module has builtins mostly for plain text textobjects which are useful
most of the times (like "inside brackets", "around quotes/underscore", etc.).
For advanced use cases define function specification for custom textobjects.

What it doesn't (and probably won't) do:
- Have special operators to specially handle whitespace (like `I` and `A`
  in 'targets.vim'). Whitespace handling is assumed to be done inside
  textobject specification (like `i(` and `i)` handle whitespace differently).
- Have "last" and "next" textobject modifiers (like `il` and `in` in
  'targets.vim'). Either set and use appropriate `config.search_method` or
  move to the next place and then use textobject. For a quicker movements,
  see |mini.jump| and |mini.jump2d|.

# Setup~

This module needs a setup with `require('mini.ai').setup({})` (replace
`{}` with your `config` table). It will create global Lua table `MiniAi`
which you can use for scripting or manually (with `:lua MiniAi.*`).

See |MiniAi.config| for available config settings.

You can override runtime config settings (like `config.custom_textobjects`)
locally to buffer inside `vim.b.miniai_config` which should have same structure
as `MiniAi.config`. See |mini.nvim-buffer-local-config| for more details.

# Comparisons~

- 'wellle/targets.vim':
    - Has limited support for creating own textobjects: it is constrained
      to pre-defined detection rules. 'mini.ai' allows creating own rules
      via Lua patterns and functions (see |MiniAi-textobject-specification|).
    - Doesn't provide any programmatical API for getting information about
      textobjects. 'mini.ai' does it via |MiniAi.find_textobject()|.
    - Has no implementation of "moving to edge of textobject". 'mini.ai'
      does it via |MiniAi.move_cursor()| and `g[` and `g]` default mappings.
    - Has elaborate ways to control searching of the next textobject.
      'mini.ai' relies on handful of 'config.search_method'.
    - Implements `A`, `I` operators. 'mini.ai' does not by design: it is
      assumed to be a property of textobject, not operator.
    - Implements `il`, `al`, `in`, `an` operators. 'mini.ai' does not by
      design: search method is controlled via `config.search_method` and
      |v:count| is supported for `a` and `i` textobjects.
    - Doesn't implement "function call" and "user prompt" textobjects.
      'mini.ai' does (with `f` and `?` identifiers).
    - Has limited support for "argument" textobject. Although it works in
      most situations, it often misdetects commas as argument separator
      (like if it is inside quotes or `{}`). 'mini.ai' deals with these cases.

# Disabling~

To disable, set `g:miniai_disable` (globally) or `b:miniai_disable`
(for a buffer) to `v:true`. Considering high number of different scenarios
and customization intentions, writing exact rules for disabling module's
functionality is left to user. See |mini.nvim-disabling-recipes| for common
recipes.

------------------------------------------------------------------------------
                                                     *MiniAi-textobject-builtin*
Builtin textobjects~

This table describes all builtin textobjects along with what they
represent. Explanation:
- `Key` represents the textobject identifier: single character which should
  be typed after `a`/`i`.
- `Name` is a description of textobject.
- `Example line` contains a string for which examples are constructed. The
  `*` denotes the cursor position.
- `a`/`i` describe inclusive region representing `a` and `i` textobjects.
  Use numbers in separators for easier navigation.
- `2a`/`2i` describe either `2a`/`2i` (support for |v:count|) textobjects
  or `a`/`i` textobject followed by another `a`/`i` textobject (consecutive
  application leads to incremental selection).

Example: typing `va)` with cursor on `*` leads to selection from column 2
to column 12. Another typing `a)` changes selection to [1; 13]. Also, besides
visual selection, any |operator| can be used or `g[`/`g]` motions to move
to left/right edge of `a` textobject.
>
 |Key|     Name      |   Example line   |   a    |   i    |   2a   |   2i   |
 |---|---------------|-1234567890123456-|--------|--------|--------|--------|
 | ( |  Balanced ()  | (( *a (bb) ))    |        |        |        |        |
 | [ |  Balanced []  | [[ *a [bb] ]]    | [2;12] | [4;10] | [1;13] | [2;12] |
 | { |  Balanced {}  | {{ *a {bb} }}    |        |        |        |        |
 | < |  Balanced <>  | << *a <bb> >>    |        |        |        |        |
 |---|---------------|-1234567890123456-|--------|--------|--------|--------|
 | ) |  Balanced ()  | (( *a (bb) ))    |        |        |        |        |
 | ] |  Balanced []  | [[ *a [bb] ]]    |        |        |        |        |
 | } |  Balanced {}  | {{ *a {bb} }}    | [2;12] | [3;11] | [1;13] | [2;12] |
 | > |  Balanced <>  | << *a <bb> >>    |        |        |        |        |
 | b |  Alias for    | [( *a {bb} )]    |        |        |        |        |
 |   |  ), ], or }   |                  |        |        |        |        |
 |---|---------------|-1234567890123456-|--------|--------|--------|--------|
 | " |  Balanced "   | "*a" " bb "      |        |        |        |        |
 | ' |  Balanced '   | '*a' ' bb '      |        |        |        |        |
 | ` |  Balanced `   | `*a` ` bb `      | [1;4]  | [2;3]  | [6;11] | [7;10] |
 | q |  Alias for    | '*a' " bb "      |        |        |        |        |
 |   |  ", ', or `   |                  |        |        |        |        |
 |---|---------------|-1234567890123456-|--------|--------|--------|--------|
 | ? |  User prompt  | e*e o e o o      | [3;5]  | [4;4]  | [7;9]  | [8;8]  |
 |   |(typed e and o)|                  |        |        |        |        |
 |---|---------------|-1234567890123456-|--------|--------|--------|--------|
 | t |      Tag      | <x>*</x><y>b</y> | [1;8]  | [4;4]  | [9;16] |[12;12] |
 |---|---------------|-1234567890123456-|--------|--------|--------|--------|
 | f | Function call | f(a, g(*b, c) )  | [6;13] | [8;12] | [1;15] | [3;14] |
 |---|---------------|-1234567890123456-|--------|--------|--------|--------|
 | a |   Argument    | f(*a, g(b, c) )  | [3;5]  | [3;4]  | [5;14] | [7;13] |
 |---|---------------|-1234567890123456-|--------|--------|--------|--------|
 |   |    Default    |                  |        |        |        |        |
 |   |   (digits,    | aa_*b__cc___     | [4;7]  | [4;5]  | [8;12] | [8;9]  |
 |   | punctuation,  | (example for _)  |        |        |        |        |
 |   | or whitespace)|                  |        |        |        |        |
 |---|---------------|-1234567890123456-|--------|--------|--------|--------|
<
Notes:
- All examples assume default `config.search_method`.
- Open brackets differ from close brackets by how they treat inner edge
  whitespace for `i` textobject: open ignores it, close - includes.
- Default textobject is activated for identifiers from digits (0, ..., 9),
  punctuation (like `_`, `*`, `,`, etc.), whitespace (space, tab, etc.).
  They are designed to be treated as separators, so include only right edge
  in `a` textobject. To include both edges, use custom textobjects
  (see |MiniAi-textobject-specification| and |MiniAi.config|).

------------------------------------------------------------------------------
                                                               *MiniAi-glossary*
- REGION - table representing region in a buffer. Fields: <from> and
  <to> for inclusive start and end positions (<to> might be `nil` to
  describe empty region). Each position is also a table with line <line>
  and column <col> (both start at 1). Examples:
  - `{ from = { line = 1, col = 1 }, to = { line = 2, col = 1 } }`
  - `{ from = { line = 10, col = 10 } }` - empty region.
- PATTERN - string describing Lua pattern.
- SPAN - interval inside a string (end-exclusive). Like [1, 5). Equal
  `from` and `to` edges describe empty span at that point.
- SPAN `A = [a1, a2)` COVERS `B = [b1, b2)` if every element of
  `B` is within `A` (`a1 <= b < a2`).
  It also is described as B IS NESTED INSIDE A.
- NESTED PATTERN - array of patterns aimed to describe nested spans.
- SPAN MATCHES NESTED PATTERN if there is a sequence of consecutively
  nested spans each matching corresponding pattern within substring of
  previous span (or input string for first span). Example:
    Nested patterns: `{ '%b()', '^. .* .$' }` (balanced `()` with inner space)
    Input string: `( ( () ( ) ) )`
                  `123456789012345`
  Here are all matching spans [1, 15) and [3, 13). Both [5, 7) and [8, 10)
  match first pattern but not second. All other combinations of `(` and `)`
  don't match first pattern (not balanced).
- COMPOSED PATTERN: array with each element describing possible pattern
  (or array of them) at that place. Composed pattern basically defines all
  possible combinations of nested pattern (their cartesian product).
  Examples:
    1. Composed pattern: `{ { '%b()', '%b[]' }, '^. .* .$' }`
       Composed pattern expanded into equivalent array of nested patterns:
        `{ '%b()', '^. .* .$' }` and `{ '%b[]', '^. .* .$' }`
       Description: either balanced `()` or balanced `[]` but both with
       inner edge space.
    2. Composed pattern:
       `{ { { '%b()', '^. .* .$' }, { '%b[]', '^.[^ ].*[^ ].$' } }, '.....' }`
       Composed pattern expanded into equivalent array of nested patterns:
       `{ '%b()', '^. .* .$', '.....' }` and
       `{ '%b[]', '^.[^ ].*[^ ].$', '.....' }`
       Description: either "balanced `()` with inner edge space" or
       "balanced `[]` with no inner edge space", both with 5 or more characters.
- SPAN MATCHES COMPOSED PATTERN if it matches at least one nested pattern
  from expanded composed pattern.

------------------------------------------------------------------------------
                                               *MiniAi-textobject-specification*
Textobject specification has a structure of composed pattern (see
|MiniAi-glossary|) with two differences:
- Last pattern(s) should have even number of empty capture groups denoting
  how the last string should be processed to extract `a` or `i` textobject:
    - Zero captures mean that whole string represents both `a` and `i`.
      Example: `xxx` will define textobject matching string `xxx` literally.
    - Two captures represent `i` textobject inside of them. `a` - whole string.
      Example: `x()x()x` defines `a` textobject to be `xxx`, `i` - middle `x`.
    - Four captures define `a` textobject inside captures 1 and 4, `i` -
      inside captures 2 and 3. Example: `x()()x()x()` defines `a`
      textobject to be last `xx`, `i` - middle `x`.
- Allows functions in certain places (enables more complex textobjects in
  exchange of increase in configuration complexity and computations):
    - If specification itself is a function, it will be called with the same
      arguments as |MiniAi.find_textobject()| and should return either a
      composed pattern or output region itself (useful for incorporating
      other instruments, like treesitter).
      Examples:
        - Simplified variant of textobject for function call with name
          taken from user prompt:
>
          function()
            local left_edge = vim.pesc(vim.fn.input('Function name: '))
            return { string.format('%s+%%b()', left_edge), '^.-%(().*()%)$' }
          end
<
        - Return all buffer:
>
          function()
            local from = { line = 1, col = 1 }
            local to = {
              line = vim.fn.line('$'),
              col = math.max(vim.fn.getline('$'):len(), 1)
            }
            return { from = from, to = to }
          end
<
    - If there is a function instead of assumed string pattern, it is
      expected to have signature `(line, init)` and behave like
      `pattern:find()`. It should return two numbers representing
      span in `line` next after or at `init` (`nil` if there is no such span).
      !IMPORTANT NOTE!: it means that output's `from` shouldn't be strictly
      to the left of `init` (it will lead to infinite loop). Not allowed as
      last item (as it should be pattern with captures).
      Example of matching only balanced parenthesis with big enough width:
>
        {
          '%b()',
          function(s, init)
            if init > 1 or s:len() < 5 then return end
            return 1, s:len()
          end,
          '^.().*().$'
        }
>
More examples:
- Textobject with `a` variant including both edges (assume `x` placeholder):
    - Balanced pair (like quotes): `{ '%bxx', '^.().*().$' }` . In string
      "xaxbxcx" it will consecutively match "xax" and "xcx". Examples:
        - With `|` edges: `{ '%b||', '^.().*().$' }`

    - Not balanced pair: `{ 'x().-()x' }` . In string "xaxbxcx" it will
      consecutively match "xax", "xbx", and "xcx". Examples:
        - With `|` edges: `{ '|().-()|' }`

    - Greedy pair, left and right edges consist from as many same
      characters as there is: `{ '%f[x]x+()[^x]-()x+%f[^x]' }`. Examples:
        - LaTeX code block: `{ '%f[%$]%$+()[^%$]-()%$+%f[^%$]' }`
        - Markdown `*` emphasis: `{ '%f[%*]%*+()[^%*]-()%*+%f[^%*]' }`
        - Markdown `_` emphasis: `{ '%f[_]_+()[^_]-()_+%f[^_]' }`

- Pair of balanced brackets from set (used for builtin `b` identifier):
  `{ { '%b()', '%b[]', '%b{}' }, '^.().*().$' }`

- Function call, but name consists only from alphanumeric and "_":
  `{ '%f[%w_][%w_]+%b()', '^.-%(().*()%)$' }`

- Imitate word ignoring digits and punctuation (supports only Latin alphabet):
  `{ '()()%f[%w]%w+()[ \t]*()' }`

- Word with camel case support (also supports only Latin alphabet):
  `{`
    `{`
      `'%u[%l%d]+%f[^%l%d]',`
      `'%f[%S][%l%d]+%f[^%l%d]',`
      `'%f[%P][%l%d]+%f[^%l%d]',`
      `'^[%l%d]+%f[^%l%d]',`
    `},`
    `'^().*()$'`
  `}`

- Number: `{ '%f[%d]%d+' }`

- Date in 'YYYY-MM-DD' format: `{ '()%d%d%d%d%-%d%d%-%d%d()' }`

- Lua block string: `{ '%[%[().-()%]%]' }`

------------------------------------------------------------------------------
                                                              *MiniAi-algorithm*
Algorithm design

Search for the textobjects relies on these principles:
- It uses same input data as described in |MiniAi.find_textobject()|,
  i.e. whether it is `a` or `i` textobject, its identifier, reference region, etc.
- Textobject specification is constructed based on textobject identifier
  (see |MiniAi-textobject-specification|).
- General search is done by converting some 2d buffer region (neighborhood
  of reference region) into 1d string (each line is appended with `\n`).
  Then search for a best span matching textobject specification is done
  inside string (see |MiniAi-glossary|). After that, span is converted back
  into 2d region. Note: first search is done inside reference region lines,
  and only after that - inside its neighborhood within `config.n_lines`
  (see |MiniAi.config|).
- The best matching span is done by iterating over all spans matching
  textobject specification and comparing them with "current best".
  Comparison also depends on reference region (tighter covering is better,
  otherwise closer is better) and search method (if span is even considered).
- Extract span based on extraction pattern (last item in nested pattern).
- If task is to perform a consecutive search (`opts.n_times` is greater than 1),
  steps are repeated with current best match becoming reference region.
  One such additional step is also done if final region is equal to
  reference region (this enables consecutive application).

Notes:
- Iteration over all matched spans is done in depth-first fashion with
  respect to nested pattern.
- It is guaranteed that span is compared only once.
- For the sake of increasing functionality, during iteration over all
  matching spans, some Lua patterns in composed pattern are handled
  specially.
    - `%bxx` (`xx` is two identical characters). It denotes balanced pair
      of identical characters and results into "paired" matches. For
      example, `%b""` for `"aa" "bb"` would match `"aa"` and `"bb"`, but
      not middle `" "`.
    - `x.-y` (`x` and `y` are different strings). It results only in matches with
      smallest width. For example, `e.-o` for `e e o o` will result only in
      middle `e o`. Note: it has some implications for when parts have
      quantifiers (like `+`, etc.), which usually can be resolved with
      frontier pattern `%f[]` (see examples in |MiniAi-textobject-specification|).

------------------------------------------------------------------------------
                                                                *MiniAi.setup()*
                            `MiniAi.setup`({config})
Module setup

Parameters~
{config} `(table|nil)` Module config table. See |MiniAi.config|.

Usage~
`require('mini.ai').setup({})` (replace `{}` with your `config` table)

------------------------------------------------------------------------------
                                                                 *MiniAi.config*
                                `MiniAi.config`
Module config

Default values:
>
  MiniAi.config = {
    -- Table with textobject id as fields, textobject specification as values.
    -- Also use this to disable builtin textobjects. See |MiniAi.config|.
    custom_textobjects = nil,

    -- Module mappings. Use `''` (empty string) to disable one.
    mappings = {
      -- Main textobject prefixes
      around = 'a',
      inside = 'i',

      -- Move cursor to certain edge of `a` textobject
      goto_left = 'g[',
      goto_right = 'g]',
    },

    -- Number of lines within which textobject is searched
    n_lines = 50,

    -- How to search for object (first inside current line, then inside
    -- neighborhood). One of 'cover', 'cover_or_next', 'cover_or_prev',
    -- 'cover_or_nearest', 'next', 'previous', 'nearest'.
    search_method = 'cover_or_next',
  }
<
# Options ~

## Custom textobjects ~

Each named entry of `config.custom_textobjects` is a textobject with
that identifier and specification (see |MiniAi-textobject-specification|).
They are also used to override builtin ones (|MiniAi-textobject-builtin|).
Supply non-table input to disable builting textobject. Examples:
>
  require('mini.ai').setup({
    custom_textobjects = {
      -- Disables argument textobject
      a = false,
      -- Now `vax` should select `xxx` and `vix` - middle `x`
      x = { 'x()x()x' },
      -- Whole buffer
      g = function()
        local from = { line = 1, col = 1 }
        local to = {
          line = vim.fn.line('$'), col = vim.fn.getline('$'):len()
        }
        return { from = from, to = to }
      end
    }
  })

  -- Use `vim.b.miniai_config` to customize per buffer
  -- Example of specification useful for Markdown files:
  vim.b.miniai_config = {
    custom_textobjects = {
      ['*'] = { '%f[%*]%*+()[^%*]-()%*+%f[^%*]' },
      ['_'] = { '%f[_]_+()[^_]-()_+%f[^_]' },
    },
  }
<
There are more example specifications in |MiniAi-textobject-specification|.

## Search method~

Value of `config.search_method` defines how best match search is done.
Based on its value, one of the following matches will be selected:
- Covering match. Left/right edge is before/after left/right edge of
  reference region.
- Previous match. Left/right edge is before left/right edge of reference
  region.
- Next match. Left/right edge is after left/right edge of reference region.
- Nearest match. Whichever is closest among previous and next matches.

Possible values are:
- `'cover'` - use only covering match. Don't use either previous or
  next; report that there is no textobject found.
- `'cover_or_next'` (default) - use covering match. If not found, use next.
- `'cover_or_prev'` - use covering match. If not found, use previous.
- `'cover_or_nearest'` - use covering match. If not found, use nearest.
- `'next'` - use next match.
- `'previous'` - use previous match.
- `'nearest'` - use nearest match.

Note: search is first performed on the reference region lines and only
after failure - on the whole neighborhood defined by `config.n_lines`. This
means that with `config.search_method` not equal to `'cover'`, "previous"
or "next" textobject will end up as search result if they are found on
first stage although covering match might be found in bigger, whole
neighborhood. This design is based on observation that most of the time
operation is done within reference region lines (usually cursor line).

Here is an example of what `a)` textobject is based on a value of
`'config.search_method'` when cursor is inside `bbb` word:
- `'cover'`:         `(a) bbb (c)` -> none
- `'cover_or_next'`: `(a) bbb (c)` -> `(c)`
- `'cover_or_prev'`: `(a) bbb (c)` -> `(a)`
- `'cover_or_nearest'`: depends on cursor position.
  For first and second `b` - as in `cover_or_prev` (as previous match is
  nearer), for third - as in `cover_or_next` (as next match is nearer).
- `'next'`: `(a) bbb (c)` -> `(c)`. Same outcome for `(bbb)`.
- `'prev'`: `(a) bbb (c)` -> `(a)`. Same outcome for `(bbb)`.
- `'nearest'`: depends on cursor position (same as in `'cover_or_nearest'`).

------------------------------------------------------------------------------
                                                      *MiniAi.find_textobject()*
               `MiniAi.find_textobject`({ai_type}, {id}, {opts})
Find textobject region

Parameters~
{ai_type} `(string)` One of `'a'` or `'i'`.
{id} `(string)` Single character string representing textobject id. It is
  used to get specification which is later used to compute textobject region.
  Note: if specification is a function, it is called with all present
  arguments (`opts` is populated with default arguments).
{opts} `(table|nil)` Options. Possible fields:
  - <n_lines> - Number of lines within which textobject is searched.
    Default: `config.n_lines` (see |MiniAi.config|).
  - <n_times> - Number of times to perform a consecutive search. Each one
    is done with reference region being previous found textobject region.
    Default: 1.
  - <reference_region> - region to try to cover (see |MiniAi-glossary|). It
    is guaranteed that output region will not be inside or equal to this one.
    Default: empty region at cursor position.
  - <search_method> - Search method. Default: `config.search_method`.

Return~
`(table|nil)` Region of textobject or `nil` if no textobject different
  from `opts.reference_region` was consecutively found `opts.n_times` times.

------------------------------------------------------------------------------
                                                          *MiniAi.move_cursor()*
             `MiniAi.move_cursor`({side}, {ai_type}, {id}, {opts})
Move cursor to edge of textobject

Parameters~
{side} `(string)` One of `'left'` or `'right'`.
{ai_type} `(string)` One of `'a'` or `'i'`.
{id} `(string)` Single character string representing textobject id.
{opts} `(table|nil)` Same as in |MiniAi.find_textobject()|.
  `opts.n_times` means number of *actual* jumps (important when cursor
  already on the potential jump spot).

------------------------------------------------------------------------------
                                                    *MiniAi.select_textobject()*
              `MiniAi.select_textobject`({ai_type}, {id}, {opts})
Visually select textobject region

Does nothing if no region is found.

Parameters~
{ai_type} `(string)` One of `'a'` or `'i'`.
{id} `(string)` Single character string representing textobject id.
{opts} `(table|nil)` Same as in |MiniAi.find_textobject()|. Extra fields:
  - <vis_mode> - One of `'v'`, `'V'`, `'<C-v>'`. Default: Latest visual mode.
  - <operator_pending> - Whether selection is for Operator-pending mode.
    Used in that mode's mappings, shouldn't be used directly. Default: `false`.

------------------------------------------------------------------------------
                                                      *MiniAi.expr_textobject()*
                  `MiniAi.expr_textobject`({mode}, {ai_type})
Make expression to visually select textobject

Designed to be used inside expression mapping. No need to use directly.

Textobject identifier is taken from user single character input.
Default `n_times` option is taken from |v:count1|.

Parameters~
{mode} `(string)` One of 'x' (Visual) or 'o' (Operator-pending).
{ai_type} `(string)` One of `'a'` or `'i'`.

------------------------------------------------------------------------------
                                                          *MiniAi.expr_motion()*
                          `MiniAi.expr_motion`({side})
Make expression for moving cursor to edge of textobject

Designed to be used inside expression mapping (powers `config.goto_left`
and `config.goto_right` mappings). No need to use directly.

Textobject identifier is taken from user single character input.
Default `n_times` option is taken from |v:count1|.

Parameters~
{side} `(string)` One of `'left'` or `'right'`.


==============================================================================
------------------------------------------------------------------------------
                                                                   *mini.base16*
                                                                    *MiniBase16*
Minimal and fast Lua module which implements
[base16](http://chriskempson.com/projects/base16/) color scheme (with
Copyright (C) 2012 Chris Kempson) adapated for modern Neovim 0.5 Lua
plugins. Extra features:
- Configurable automatic support of cterm colors (see |highlight-cterm|).
- Opinionated palette generator based only on background and foreground
  colors.

# Setup~

This module needs a setup with `require('mini.base16').setup({})` (replace
`{}` with your `config` table). It will create global Lua table
`MiniBase16` which you can use for scripting or manually (with
`:lua MiniBase16.*`).

See |MiniBase16.config| for `config` structure and default values.

This module doesn't have runtime options, so using `vim.b.minibase16_config`
will have no effect here.

Example:
>
  require('mini.base16').setup({
    palette = {
      base00 = '#112641',
      base01 = '#3a475e',
      base02 = '#606b81',
      base03 = '#8691a7',
      base04 = '#d5dc81',
      base05 = '#e2e98f',
      base06 = '#eff69c',
      base07 = '#fcffaa',
      base08 = '#ffcfa0',
      base09 = '#cc7e46',
      base0A = '#46a436',
      base0B = '#9ff895',
      base0C = '#ca6ecf',
      base0D = '#42f7ff',
      base0E = '#ffc4ff',
      base0F = '#00a5c5',
    },
    use_cterm = true,
  })
<
# Notes~

1. This module is used to create plugin's colorscheme (see |minischeme|).
2. Using `setup()` doesn't actually create a |colorscheme|. It basically
   creates a coordinated set of |highlight|s. To create your own theme:
    - Put "myscheme.lua" file (name after your chosen theme name) inside
      any "colors" directory reachable from 'runtimepath' ("colors" inside
      your Neovim config directory is usually enough).
    - Inside "myscheme.lua" call `require('mini.base16').setup()` with your
      palette and only after that set |g:colors_name| to "myscheme".

------------------------------------------------------------------------------
                                                            *MiniBase16.setup()*
                          `MiniBase16.setup`({config})
Module setup

Setup is done by applying base16 palette to enable colorscheme. Highlight
groups make an extended set from original
[base16-vim](https://github.com/chriskempson/base16-vim/) plugin. It is a
good idea to have `config.palette` respect the original [styling
principles](https://github.com/chriskempson/base16/blob/master/styling.md).

By default only 'gui highlighting' (see |highlight-gui| and
|termguicolors|) is supported. To support 'cterm highlighting' (see
|highlight-cterm|) supply `config.use_cterm` argument in one of the formats:
- `true` to auto-generate from `palette` (as closest colors).
- Table with similar structure to `palette` but having terminal colors
  (integers from 0 to 255) instead of hex strings.

Parameters~
{config} `(table)` Module config table. See |MiniBase16.config|.

Usage~
`require('mini.base16').setup({})` (replace `{}` with your `config`
  table; `config.palette` should be a table with colors)

------------------------------------------------------------------------------
                                                             *MiniBase16.config*
                              `MiniBase16.config`
Module config

Default values:
>
  MiniBase16.config = {
    -- Table with names from `base00` to `base0F` and values being strings of
    -- HEX colors with format "#RRGGBB". NOTE: this should be explicitly
    -- supplied in `setup()`.
    palette = nil,

    -- Whether to support cterm colors. Can be boolean, `nil` (same as
    -- `false`), or table with cterm colors. See `setup()` documentation for
    -- more information.
    use_cterm = nil,
  }
<

------------------------------------------------------------------------------
                                                     *MiniBase16.mini_palette()*
     `MiniBase16.mini_palette`({background}, {foreground}, {accent_chroma})
Create 'mini' palette

Create base16 palette based on the HEX (string '#RRGGBB') colors of main
background and foreground with optional setting of accent chroma (see
details).

# Algorithm design~

- Main operating color space is
  [CIELCh(uv)](https://en.wikipedia.org/wiki/CIELUV#Cylindrical_representation_(CIELCh))
  which is a cylindrical representation of a perceptually uniform CIELUV
  color space. It defines color by three values: lightness L (values from 0
  to 100), chroma (positive values), and hue (circular values from 0 to 360
  degress). Useful converting tool: https://www.easyrgb.com/en/convert.php
- There are four important lightness values: background, foreground, focus
  (around the middle of background and foreground, leaning towards
  foreground), and edge (extreme lightness closest to foreground).
- First four colors have the same chroma and hue as `background` but
  lightness progresses from background towards focus.
- Second four colors have the same chroma and hue as `foreground` but
  lightness progresses from foreground towards edge in such a way that
  'base05' color is main foreground color.
- The rest eight colors are accent colors which are created in pairs
    - Each pair has same hue from set of hues 'most different' to
      background and foreground hues (if respective chorma is positive).
    - All colors have the same chroma equal to `accent_chroma` (if not
      provided, chroma of foreground is used, as they will appear next
      to each other). Note: this means that in case of low foreground
      chroma, it is a good idea to set `accent_chroma` manually.
      Values from 30 (low chorma) to 80 (high chroma) are common.
    - Within pair there is base lightness (equal to foreground
      lightness) and alternative (equal to focus lightness). Base
      lightness goes to colors which will be used more frequently in
      code: base08 (variables), base0B (strings), base0D (functions),
      base0E (keywords).
  How exactly accent colors are mapped to base16 palette is a result of
  trial and error. One rule of thumb was: colors within one hue pair should
  be more often seen next to each other. This is because it is easier to
  distinguish them and seems to be more visually appealing. That is why
  `base0D` and `base0F` have same hues because they usually represent
  functions and delimiter (brackets included).

Parameters~
{background} `(string)` Background HEX color (formatted as `#RRGGBB`).
{foreground} `(string)` Foreground HEX color (formatted as `#RRGGBB`).
{accent_chroma} `(number)` Optional positive number (usually between 0
  and 100). Default: chroma of foreground color.

Return~
`(table)` Table with base16 palette.

Usage~
`local palette = require('mini.base16').mini_palette('#112641', '#e2e98f', 75)`
`require('mini.base16').setup({palette = palette})`

------------------------------------------------------------------------------
                                     *MiniBase16.rgb_palette_to_cterm_palette()*
              `MiniBase16.rgb_palette_to_cterm_palette`({palette})
Converts palette with RGB colors to terminal colors

Useful for caching `use_cterm` variable to increase speed.

Parameters~
{palette} `(table)` Table with base16 palette (same as in
  `MiniBase16.config.palette`).

Return~
`(table)` Table with base16 palette using |highlight-cterm|.


==============================================================================
------------------------------------------------------------------------------
                                                                *mini.bufremove*
                                                                 *MiniBufremove*
Lua module for minimal buffer removing (unshow, delete, wipeout), which
saves window layout (opposite to builtin Neovim's commands). This is mostly
a Lua implementation of
[bclose.vim](https://vim.fandom.com/wiki/Deleting_a_buffer_without_closing_the_window).
Other alternatives:
- [vim-bbye](https://github.com/moll/vim-bbye)
- [vim-sayonara](https://github.com/mhinz/vim-sayonara)

# Setup~

This module doesn't need setup, but it can be done to improve usability.
Setup with `require('mini.bufremove').setup({})` (replace `{}` with your
`config` table). It will create global Lua table `MiniBufremove` which you
can use for scripting or manually (with `:lua MiniBufremove.*`).

See |MiniBufremove.config| for `config` structure and default values.

This module doesn't have runtime options, so using `vim.b.minibufremove_config`
will have no effect here.

# Notes~

1. Which buffer to show in window(s) after its current buffer is removed is
   decided by the algorithm:
   - If alternate buffer (see |CTRL-^|) is listed (see |buflisted()|), use it.
   - If previous listed buffer (see |bprevious|) is different, use it.
   - Otherwise create a scratch one with `nvim_create_buf(true, true)` and use
     it.

# Disabling~

To disable core functionality, set `g:minibufremove_disable` (globally) or
`b:minibufremove_disable` (for a buffer) to `v:true`. Considering high
number of different scenarios and customization intentions, writing exact
rules for disabling module's functionality is left to user. See
|mini.nvim-disabling-recipes| for common recipes.

------------------------------------------------------------------------------
                                                         *MiniBufremove.setup()*
                        `MiniBufremove.setup`({config})
Module setup

Parameters~
{config} `(table)` Module config table. See |MiniBufremove.config|.

Usage~
`require('mini.bufremove').setup({})` (replace `{}` with your `config` table)

------------------------------------------------------------------------------
                                                          *MiniBufremove.config*
                             `MiniBufremove.config`
Module config

Default values:
>
  MiniBufremove.config = {
    -- Whether to set Vim's settings for buffers (allow hidden buffers)
    set_vim_settings = true,
  }
<

------------------------------------------------------------------------------
                                                        *MiniBufremove.delete()*
                   `MiniBufremove.delete`({buf_id}, {force})
Delete buffer `buf_id` with |:bdelete| after unshowing it

Parameters~
{buf_id} `(number)` Buffer identifier (see |bufnr()|) to use. Default:
  0 for current.
{force} `(boolean)` Whether to ignore unsaved changes (using `!` version of
  command). Default: `false`.

Return~
`(boolean)` Whether operation was successful.

------------------------------------------------------------------------------
                                                       *MiniBufremove.wipeout()*
                   `MiniBufremove.wipeout`({buf_id}, {force})
Wipeout buffer `buf_id` with |:bwipeout| after unshowing it

Parameters~
{buf_id} `(number)` Buffer identifier (see |bufnr()|) to use. Default:
  0 for current.
{force} `(boolean)` Whether to ignore unsaved changes (using `!` version of
  command). Default: `false`.

Return~
`(boolean)` Whether operation was successful.

------------------------------------------------------------------------------
                                                        *MiniBufremove.unshow()*
                        `MiniBufremove.unshow`({buf_id})
Stop showing buffer `buf_id` in all windows

Parameters~
{buf_id} `(number)` Buffer identifier (see |bufnr()|) to use. Default:
  0 for current.

Return~
`(boolean)` Whether operation was successful.

------------------------------------------------------------------------------
                                              *MiniBufremove.unshow_in_window()*
                   `MiniBufremove.unshow_in_window`({win_id})
Stop showing current buffer of window `win_id`

Parameters~
{win_id} `(number)` Window identifier (see |win_getid()|) to use.
  Default: 0 for current.

Return~
`(boolean)` Whether operation was successful.


==============================================================================
------------------------------------------------------------------------------
                                                                  *mini.comment*
                                                                   *MiniComment*
Minimal and fast Lua module for code commenting. This is basically a
reimplementation of "tpope/vim-commentary". Commenting in Normal mode
respects |count| and is dot-repeatable. Comment structure is inferred
from 'commentstring'. Handles both tab and space indenting (but not when
they are mixed). Allows custom hooks before and after successful commeting.

What it doesn't do:
- Block and sub-line comments. This will only support per-line commenting.
- Configurable (from module) comment structure. Modify |commentstring|
  instead. To enhance support for commenting in multi-language files, see
  "JoosepAlviste/nvim-ts-context-commentstring" plugin along with `hooks`
  option of this module (see |MiniComment.config|).
- Handle indentation with mixed tab and space.
- Preserve trailing whitespace in empty lines.

# Setup~

This module needs a setup with `require('mini.comment').setup({})` (replace
`{}` with your `config` table). It will create global Lua table
`MiniComment` which you can use for scripting or manually (with
`:lua MiniComment.*`).

See |MiniComment.config| for `config` structure and default values.

You can override runtime config settings locally to buffer inside
`vim.b.minicomment_config` which should have same structure as
`MiniComment.config`. See |mini.nvim-buffer-local-config| for more details.

# Disabling~

To disable core functionality, set `g:minicomment_disable` (globally) or
`b:minicomment_disable` (for a buffer) to `v:true`. Considering high number
of different scenarios and customization intentions, writing exact rules
for disabling module's functionality is left to user. See
|mini.nvim-disabling-recipes| for common recipes.

------------------------------------------------------------------------------
                                                           *MiniComment.setup()*
                         `MiniComment.setup`({config})
Module setup

Parameters~
{config} `(table)` Module config table. See |MiniComment.config|.

Usage~
`require('mini.comment').setup({})` (replace `{}` with your `config` table)

------------------------------------------------------------------------------
                                                            *MiniComment.config*
                              `MiniComment.config`
Module config

Default values:
>
  MiniComment.config = {
    -- Module mappings. Use `''` (empty string) to disable one.
    mappings = {
      -- Toggle comment (like `gcip` - comment inner paragraph) for both
      -- Normal and Visual modes
      comment = 'gc',

      -- Toggle comment on current line
      comment_line = 'gcc',

      -- Define 'comment' textobject (like `dgc` - delete whole comment block)
      textobject = 'gc',
    },
    -- Hook functions to be executed at certain stage of commenting
    hooks = {
      -- Before successful commenting. Does nothing by default.
      pre = function() end,
      -- After successful commenting. Does nothing by default.
      post = function() end,
    },
  }
<

------------------------------------------------------------------------------
                                                        *MiniComment.operator()*
                         `MiniComment.operator`({mode})
Main function to be mapped

It is meant to be used in expression mappings (see |map-<expr>|) to enable
dot-repeatability and commenting on range. There is no need to do this
manually, everything is done inside |MiniComment.setup()|.

It has a somewhat unintuitive logic (because of how expression mapping with
dot-repeatability works): it should be called without arguments inside
expression mapping and with argument when action should be performed.

Parameters~
{mode} `(string)` Optional string with 'operatorfunc' mode (see |g@|).

Return~
`(string)` 'g@' if called without argument, '' otherwise (but after
  performing action).

------------------------------------------------------------------------------
                                                    *MiniComment.toggle_lines()*
              `MiniComment.toggle_lines`({line_start}, {line_end})
Toggle comments between two line numbers

It uncomments if lines are comment (every line is a comment) and comments
otherwise. It respects indentation and doesn't insert trailing
whitespace. Toggle commenting not in visual mode is also dot-repeatable
and respects |count|.

Before successful commenting it executes `config.hooks.pre`.
After successful commenting it executes `config.hooks.post`.

# Notes~

1. Currently call to this function will remove marks inside written range.
   Use |lockmarks| to preserve marks.

Parameters~
{line_start} `(number)` Start line number (inclusive from 1 to number of lines).
{line_end} `(number)` End line number (inclusive from 1 to number of lines).

------------------------------------------------------------------------------
                                                      *MiniComment.textobject()*
                           `MiniComment.textobject`()
Comment textobject

This selects all commented lines adjacent to cursor line (if it itself is
commented). Designed to be used with operator mode mappings (see |mapmode-o|).

Before successful textobject usage it executes `config.hooks.pre`.
After successful textobject usage it executes `config.hooks.post`.


==============================================================================
------------------------------------------------------------------------------
                                                               *mini.completion*
                                                                *MiniCompletion*
Custom somewhat minimal autocompletion Lua plugin. Key design ideas:
- Have an async (with customizable 'debounce' delay) 'two-stage chain
  completion': first try to get completion items from LSP client (if set
  up) and if no result, fallback to custom action.
- Managing completion is done as much with Neovim's built-in tools as
  possible.

Features:
- Two-stage chain completion:
    - First stage is an LSP completion implemented via
      |MiniCompletion.completefunc_lsp()|. It should be set up as either
      |completefunc| or |omnifunc|. It tries to get completion items from
      LSP client (via 'textDocument/completion' request). Custom
      preprocessing of response items is possible (with
      `MiniCompletion.config.lsp_completion.process_items`), for example
      with fuzzy matching. By default items which are not snippets and
      directly start with completed word are kept and sorted according to
      LSP specification. Supports `additionalTextEdits`, like auto-import
      and others (see 'Notes').
    - If first stage is not set up or resulted into no candidates, fallback
      action is executed. The most tested actions are Neovim's built-in
      insert completion (see |ins-completion|).
- Automatic display in floating window of completion item info (via
  'completionItem/resolve' request) and signature help (with highlighting
  of active parameter if LSP server provides such information). After
  opening, window for signature help is fixed and is closed when there is
  nothing to show, text is different or
  when leaving Insert mode.
- Automatic actions are done after some configurable amount of delay. This
  reduces computational load and allows fast typing (completion and
  signature help) and item selection (item info)
- Autoactions are triggered on Neovim's built-in events.
- User can force two-stage completion via
  |MiniCompletion.complete_twostage()| (by default is mapped to
  `<C-Space>`) or fallback completion via
  |MiniCompletion.complete_fallback()| (maped to `<M-Space>`).

What it doesn't do:
- Snippet expansion.
- Many configurable sources.
- Automatic mapping of `<CR>`, `<Tab>`, etc., as those tend to have highly
  variable user expectations. See 'Helpful key mappings' for suggestions.

# Setup~

This module needs a setup with `require('mini.completion').setup({})`
(replace `{}` with your `config` table). It will create global Lua table
`MiniCompletion` which you can use for scripting or manually (with
`:lua MiniCompletion.*`).

See |MiniCompletion.config| for `config` structure and default values.

You can override runtime config settings locally to buffer inside
`vim.b.minicompletion_config` which should have same structure as
`MiniCompletion.config`. See |mini.nvim-buffer-local-config| for more details.

# Notes~

- More appropriate, albeit slightly advanced, LSP completion setup is to set
  it not on every `BufEnter` event (default), but on every attach of LSP
  client. To do that:
    - Use in initial config:
    `lsp_completion = {source_func = 'omnifunc', auto_setup = false}`.
    - In `on_attach()` of every LSP client set 'omnifunc' option to exactly
      `v:lua.MiniCompletion.completefunc_lsp`.
- If you have trouble using custom (overriden) |vim.ui.input| (like from
  'stevearc/dressing.nvim'), make automated disable of 'mini.completion'
  for input buffer. For example, currently for 'dressing.nvim' it can be
  with `au FileType DressingInput lua vim.b.minicompletion_disable = true`.
- Support of `additionalTextEdits` tries to handle both types of servers:
    - When `additionalTextEdits` are supplied in response to
      'textDocument/completion' request (like currently in 'pyright').
    - When `additionalTextEdits` are supplied in response to
      'completionItem/resolve' request (like currently in
      'typescript-language-server'). In this case to apply edits user needs
      to trigger such request, i.e. select completion item and wait for
      `MiniCompletion.config.delay.info` time plus server response time.

# Comparisons~

- 'nvim-cmp':
    - More complex design which allows multiple sources each in form of
      separate plugin. `MiniCompletion` has two built in: LSP and fallback.
    - Supports snippet expansion.
    - Doesn't have customizable delays for basic actions.
    - Doesn't allow fallback action.
    - Doesn't provide signature help.

# Helpful key mappings~

To use `<Tab>` and `<S-Tab>` for navigation through completion list, make
these key mappings:
`vim.api.nvim_set_keymap('i', '<Tab>',   [[pumvisible() ? "\<C-n>" : "\<Tab>"]],   { noremap = true, expr = true })`
`vim.api.nvim_set_keymap('i', '<S-Tab>', [[pumvisible() ? "\<C-p>" : "\<S-Tab>"]], { noremap = true, expr = true })`

To get more consistent behavior of `<CR>`, you can use this template in
your 'init.lua' to make customized mapping: >
  local keys = {
    ['cr']        = vim.api.nvim_replace_termcodes('<CR>', true, true, true),
    ['ctrl-y']    = vim.api.nvim_replace_termcodes('<C-y>', true, true, true),
    ['ctrl-y_cr'] = vim.api.nvim_replace_termcodes('<C-y><CR>', true, true, true),
  }

  _G.cr_action = function()
    if vim.fn.pumvisible() ~= 0 then
      -- If popup is visible, confirm selected item or add new line otherwise
      local item_selected = vim.fn.complete_info()['selected'] ~= -1
      return item_selected and keys['ctrl-y'] or keys['ctrl-y_cr']
    else
      -- If popup is not visible, use plain `<CR>`. You might want to customize
      -- according to other plugins. For example, to use 'mini.pairs', replace
      -- next line with `return require('mini.pairs').cr()`
      return keys['cr']
    end
  end

  vim.api.nvim_set_keymap('i', '<CR>', 'v:lua._G.cr_action()', { noremap = true, expr = true })
<
# Highlight groups~

* `MiniCompletionActiveParameter` - highlighting of signature active parameter.
  By default displayed as plain underline.

To change any highlight group, modify it directly with |:highlight|.

# Disabling~

To disable, set `g:minicompletion_disable` (globally) or
`b:minicompletion_disable` (for a buffer) to `v:true`. Considering high
number of different scenarios and customization intentions, writing exact
rules for disabling module's functionality is left to user. See
|mini.nvim-disabling-recipes| for common recipes.

------------------------------------------------------------------------------
                                                        *MiniCompletion.setup()*
                        `MiniCompletion.setup`({config})
Module setup

Parameters~
{config} `(table)` Module config table. See |MiniCompletion.config|.

Usage~
`require('mini.completion').setup({})` (replace `{}` with your `config` table)

------------------------------------------------------------------------------
                                                         *MiniCompletion.config*
                            `MiniCompletion.config`
Module config

Default values:
>
  MiniCompletion.config = {
    -- Delay (debounce type, in ms) between certain Neovim event and action.
    -- This can be used to (virtually) disable certain automatic actions by
    -- setting very high delay time (like 10^7).
    delay = { completion = 100, info = 100, signature = 50 },

    -- Maximum dimensions of floating windows for certain actions. Action
    -- entry should be a table with 'height' and 'width' fields.
    window_dimensions = {
      info = { height = 25, width = 80 },
      signature = { height = 25, width = 80 },
    },

    -- Way of how module does LSP completion
    lsp_completion = {
      -- `source_func` should be one of 'completefunc' or 'omnifunc'.
      source_func = 'completefunc',

      -- `auto_setup` should be boolean indicating if LSP completion is set up
      -- on every `BufEnter` event.
      auto_setup = true,

      -- `process_items` should be a function which takes LSP
      -- 'textDocument/completion' response items and word to complete. Its
      -- output should be a table of the same nature as input items. The most
      -- common use-cases are custom filtering and sorting. You can use
      -- default `process_items` as `MiniCompletion.default_process_items()`.
      process_items = --<function: filters out snippets; sorts by LSP specs>,
    },

    -- Fallback action. It will always be run in Insert mode. To use Neovim's
    -- built-in completion (see `:h ins-completion`), supply its mapping as
    -- string. Example: to use 'whole lines' completion, supply '<C-x><C-l>'.
    fallback_action = --<function: like `<C-n>` completion>,

    -- Module mappings. Use `''` (empty string) to disable one. Some of them
    -- might conflict with system mappings.
    mappings = {
      force_twostep = '<C-Space>', -- Force two-step completion
      force_fallback = '<A-Space>', -- Force fallback completion
    },

    -- Whether to set Vim's settings for better experience (modifies
    -- `shortmess` and `completeopt`)
    set_vim_settings = true,
  }
<

------------------------------------------------------------------------------
                                              *MiniCompletion.auto_completion()*
                       `MiniCompletion.auto_completion`()
Auto completion

Designed to be used with |autocmd|. No need to use it directly, everything
is setup in |MiniCompletion.setup|.

------------------------------------------------------------------------------
                                            *MiniCompletion.complete_twostage()*
            `MiniCompletion.complete_twostage`({fallback}, {force})
Run two-stage completion

Parameters~
{fallback} `(boolean)` Whether to use fallback completion.
{force} `(boolean)` Whether to force update of completion popup.

------------------------------------------------------------------------------
                                            *MiniCompletion.complete_fallback()*
                      `MiniCompletion.complete_fallback`()
Run fallback completion

------------------------------------------------------------------------------
                                                    *MiniCompletion.auto_info()*
                          `MiniCompletion.auto_info`()
Auto completion entry information

Designed to be used with |autocmd|. No need to use it directly, everything
is setup in |MiniCompletion.setup|.

------------------------------------------------------------------------------
                                               *MiniCompletion.auto_signature()*
                       `MiniCompletion.auto_signature`()
Auto function signature

Designed to be used with |autocmd|. No need to use it directly, everything
is setup in |MiniCompletion.setup|.

------------------------------------------------------------------------------
                                                         *MiniCompletion.stop()*
                        `MiniCompletion.stop`({actions})
Stop actions

This stops currently active (because of module delay or LSP answer delay)
actions.

Designed to be used with |autocmd|. No need to use it directly, everything
is setup in |MiniCompletion.setup|.

Parameters~
{actions} `(table)` Array containing any of 'completion', 'info', or
  'signature' string.

------------------------------------------------------------------------------
                                            *MiniCompletion.on_text_changed_i()*
                      `MiniCompletion.on_text_changed_i`()
Act on every |TextChangedI|

------------------------------------------------------------------------------
                                            *MiniCompletion.on_text_changed_p()*
                      `MiniCompletion.on_text_changed_p`()
Act on every |TextChangedP|

------------------------------------------------------------------------------
                                             *MiniCompletion.completefunc_lsp()*
             `MiniCompletion.completefunc_lsp`({findstart}, {base})
Module's |complete-function|

This is the main function which enables two-stage completion. It should be
set as one of |completefunc| or |omnifunc|.

No need to use it directly, everything is setup in |MiniCompletion.setup|.

------------------------------------------------------------------------------
                                        *MiniCompletion.default_process_items()*
            `MiniCompletion.default_process_items`({items}, {base})
Default `MiniCompletion.config.lsp_completion.process_items`


==============================================================================
------------------------------------------------------------------------------
                                                               *mini.cursorword*
                                                                *MiniCursorword*
Minimal and fast module for autohighlighting word under cursor with
customizable delay. Current word under cursor can be highlighted
differently. Highlighting is triggered only if current cursor character is
a |[:keyword:]|. "Word under cursor" is meant as in Vim's |<cword>|:
something user would get as 'iw' text object. Highlighting stops in insert
and terminal modes.

# Setup~

This module needs a setup with `require('mini.cursorword').setup({})`
(replace `{}` with your `config` table). It will create global Lua table
`MiniCursorword` which you can use for scripting or manually (with
`:lua MiniCursorword.*`).

See |MiniCursorword.config| for `config` structure and default values.

You can override runtime config settings locally to buffer inside
`vim.b.minicursorword_config` which should have same structure as
`MiniCursorword.config`. See |mini.nvim-buffer-local-config| for more details.

# Highlight groups~

* `MiniCursorword` - highlight group of cursor word. Default: plain underline.
* `MiniCursorwordCurrent` - highlight group of a current word under
  cursor. It will be displayed on top of `MiniCursorword`
  (so `:hi clear MiniCursorwordCurrent` will lead to showing
  `MiniCursorword` highlight group). Note: To not highlight it, use
  `:hi! MiniCursorwordCurrent gui=nocombine guifg=NONE guibg=NONE` .

To change any highlight group, modify it directly with |:highlight|.

# Disabling~

To disable core functionality, set `g:minicursorword_disable` (globally) or
`b:minicursorword_disable` (for a buffer) to `v:true`. Considering high
number of different scenarios and customization intentions, writing exact
rules for disabling module's functionality is left to user. See
|mini.nvim-disabling-recipes| for common recipes. Note: after disabling
there might be highlighting left; it will be removed after next
highlighting update.

Module-specific disabling:
- Don't show highlighting if cursor is on the word that is in a blocklist
  of current filetype. In this example, blocklist for "lua" is "local" and
  "require" words, for "javascript" - "import":
>
  _G.cursorword_blocklist = function()
    local curword = vim.fn.expand('<cword>')
    local filetype = vim.api.nvim_buf_get_option(0, 'filetype')

    -- Add any disabling global or filetype-specific logic here
    local blocklist = {}
    if filetype == 'lua' then
      blocklist = { 'local', 'require' }
    elseif filetype == 'javascript' then
      blocklist = { 'import' }
    end

    vim.b.minicursorword_disable = vim.tbl_contains(blocklist, curword)
  end

  -- Make sure to add this autocommand *before* calling module's `setup()`.
  vim.cmd('au CursorMoved * lua _G.cursorword_blocklist()')

------------------------------------------------------------------------------
                                                        *MiniCursorword.setup()*
                        `MiniCursorword.setup`({config})
Module setup

Parameters~
{config} `(table)` Module config table. See |MiniCursorword.config|.

Usage~
`require('mini.cursorword').setup({})` (replace `{}` with your `config` table)

------------------------------------------------------------------------------
                                                         *MiniCursorword.config*
                            `MiniCursorword.config`
Module config

Default values:
>
  MiniCursorword.config = {
    -- Delay (in ms) between when cursor moved and when highlighting appeared
    delay = 100,
  }
<

------------------------------------------------------------------------------
                                               *MiniCursorword.auto_highlight()*
                       `MiniCursorword.auto_highlight`()
Auto highlight word under cursor

Designed to be used with |autocmd|. No need to use it directly,
everything is setup in |MiniCursorword.setup|.

------------------------------------------------------------------------------
                                             *MiniCursorword.auto_unhighlight()*
                      `MiniCursorword.auto_unhighlight`()
Auto unhighlight word under cursor

Designed to be used with |autocmd|. No need to use it directly, everything
is setup in |MiniCursorword.setup|.


==============================================================================
------------------------------------------------------------------------------
                                                                      *mini.doc*
                                                                       *MiniDoc*
Generation of help files from EmmyLua-like annotations

Key design ideas:
- Keep documentation next to code by writing EmmyLua-like annotation
  comments. They will be parsed as is, so formatting should follow built-in
  guide in |help-writing|. However, custom hooks are allowed at many
  generation stages for more granular management of output help file.
- Generation is done by processing a set of ordered files line by line.
  Each line can either be considered as a part of documentation block (if
  it matches certain configurable pattern) or not (considered to be an
  "afterline" of documentation block). See |MiniDoc.generate()| for more
  details.
- Processing is done by using nested data structures (section, block, file,
  doc) describing certain parts of help file. See |MiniDoc-data-structures|
  for more details.
- Project specific script can be written as plain Lua file with
  configuratble path. See |MiniDoc.generate()| for more details.

What it doesn't do:
- It doesn't support markdown or other markup language inside annotations.
- It doesn't use treesitter in favor of Lua string manipulation for basic
  tasks (parsing annotations, formatting, auto-generating tags, etc.). This
  is done to manage complexity and be dependency free.

# Setup~

This module needs a setup with `require('mini.doc').setup({})` (replace
`{}` with your `config` table). It will create global Lua table `MiniDoc`
which you can use for scripting or manually (with `:lua MiniDoc.*`).

See |MiniDoc.config| for available config settings.

You can override runtime config settings locally to buffer inside
`vim.b.minidoc_config` which should have same structure as `MiniDoc.config`.
See |mini.nvim-buffer-local-config| for more details.

# Tips~

- Some settings tips that might make writing annotation comments easier:
    - Set up appropriate 'comments' for `lua` file type to respect
      EmmyLua-like's `---` comment leader. Value `:---,:--` seems to work.
    - Set up appropriate 'formatoptions' (see also |fo-table|). Consider
      adding `j`, `n`, `q`, and `r` flags.
    - Set up appropriate 'formatlistpat' to help auto-formatting lists (if
      `n` flag is added to 'formatoptions'). One suggestion (not entirely
      ideal) is a value `^\s*[0-9\-\+\*]\+[\.\)]*\s\+`. This reads as 'at
      least one special character (digit, `-`, `+`, `*`) possibly followed
      by some punctuation (`.` or `)`) followed by at least one space is a
      start of list item'.
- Probably one of the most reliable resources for what is considered to be
  best practice when using this module is this whole plugin. Look at source
  code for the reference.

# Comparisons~

- 'tjdevries/tree-sitter-lua':
    - Its key design is to use treesitter grammar to parse both Lua code
      and annotation comments. This makes it not easy to install,
      customize, and support.
    - It takes more care about automating output formatting (like auto
      indentation and line width fit). This plugin leans more to manual
      formatting with option to supply customized post-processing hooks.

# Disabling~

To disable, set `g:minidoc_disable` (globally) or `b:minidoc_disable` (for
a buffer) to `v:true`. Considering high number of different scenarios and
customization intentions, writing exact rules for disabling module's
functionality is left to user. See |mini.nvim-disabling-recipes| for common
recipes.

------------------------------------------------------------------------------
                                                       *MiniDoc-data-structures*
Data structures

Data structures are basically arrays of other structures accompanied with
some fields (keys with data values) and methods (keys with function
values):
- `Section structure` is an array of string lines describing one aspect
  (determined by section id like '@param', '@return', '@text') of an
  annotation subject. All lines will be used directly in help file.
- `Block structure` is an array of sections describing one annotation
  subject like function, table, concept.
- `File structure` is an array of blocks describing certain file on disk.
  Basically, file is split into consecutive blocks: annotation lines go
  inside block, non-annotation - inside `block_afterlines` element of info.
- `Doc structure` is an array of files describing a final help file. Each
  string line from section (when traversed in depth-first fashion) goes
  directly into output file.

All structures have these keys:
- Fields:
    - `info` - contains additional information about current structure.
      For more details see next section.
    - `parent` - table of parent structure (if exists).
    - `parent_index` - index of this structure in its parent's array. Useful
      for adding to parent another structure near current one.
    - `type` - string with structure type (section, block, file, doc).
- Methods (use them as `x:method(args)`):
    - `insert(self, [index,] child)` - insert `child` to `self` at position
      `index` (optional; if not supplied, child will be appended to end).
      Basically, a `table.insert()`, but adds `parent` and `parent_index`
      fields to `child` while properly updating `self`.
    - `remove(self [,index])` - remove from `self` element at position
      `index`. Basically, a `table.remove()`, but properly updates `self`.
    - `has_descendant(self, predicate)` - whether there is a descendant
      (structure or string) for which `predicate` returns `true`. In case of
      success also returns the first such descendant as second value.
    - `has_lines(self)` - whether structure has any lines (even empty ones)
      to be put in output file. For section structures this is equivalent to
      `#self`, but more useful for higher order structures.
    - `clear_lines(self)` - remove all lines from structure. As a result,
      this structure won't contribute to output help file.

Description of `info` fields per structure type:
- `Section`:
    - `id` - captured section identifier. Can be empty string meaning no
      identifier is captured.
    - `line_begin` - line number inside file at which section begins (-1 if
      not generated from file).
    - `line_end` - line number inside file at which section ends (-1 if not
      generated from file).
- `Block`:
    - `afterlines` - array of strings which were parsed from file after
      this annotation block (up until the next block or end of file).
      Useful for making automated decisions about what is being documented.
    - `line_begin` - line number inside file at which block begins  (-1 if
      not generated from file).
    - `line_end` - line number inside file at which block ends  (-1 if not
      generated from file).
- `File`:
    - `path` - absolute path to a file (`''` if not generated from file).
- `Doc`:
    - `input` - array of input file paths (as in |MiniDoc.generate|).
    - `output` - output path (as in |MiniDoc.generate|).
    - `config` - configuration used (as in |MiniDoc.generate|).

------------------------------------------------------------------------------
                                                               *MiniDoc.setup()*
                           `MiniDoc.setup`({config})
Module setup

Parameters~
{config} `(table)` Module config table. See |MiniDoc.config|.

Usage~
`require('mini.doc').setup({})` (replace `{}` with your `config` table)

------------------------------------------------------------------------------
                                                                *MiniDoc.config*
                                `MiniDoc.config`
Module config

Default values:
>
  MiniDoc.config = {
    -- Function which extracts part of line used to denote annotation.
    -- For more information see 'Notes' in |MiniDoc.config|.
    annotation_extractor = function(l) return string.find(l, '^%-%-%-(%S*) ?') end,

    -- Identifier of block annotation lines until first captured identifier
    default_section_id = '@text',

    -- Hooks to be applied at certain stage of document life cycle. Should
    -- modify its input in place (and not return new one).
    hooks = {
      -- Applied to block before anything else
      block_pre = --<function: infers header sections (tag and/or signature)>,

      -- Applied to section before anything else
      section_pre = --<function: replaces current aliases>,

      -- Applied if section has specified captured id
      sections = {
        ['@alias'] = --<function: registers alias in MiniDoc.current.aliases>,
        ['@class'] = --<function>,
        ['@diagnostic'] = --<function: ignores any section content>,
        -- For most typical usage see |MiniDoc.afterlines_to_code|
        ['@eval'] = --<function: evaluates lines; replaces with their return>,
        ['@field'] = --<function>,
        ['@overload'] = --<function>,
        ['@param'] = --<function>,
        ['@private'] = --<function: registers block for removal>,
        ['@return'] = --<function>,
        ['@seealso'] = --<function>,
        ['@signature'] = --<function: formats signature of documented object>,
        ['@tag'] = --<function: turns its line in proper tag lines>,
        ['@text'] = --<function: purposefully does nothing>,
        ['@toc'] = --<function: clears all section lines>,
        ['@toc_entry'] = --<function: registers lines for table of contents>,
        ['@type'] = --<function>,
        ['@usage'] = --<function>,
      },

      -- Applied to section after all previous steps
      section_post = --<function: currently does nothing>,

      -- Applied to block after all previous steps
      block_post = --<function: does many things>,

      -- Applied to file after all previous steps
      file = --<function: adds separator>,

      -- Applied to doc after all previous steps
      doc = --<function: adds modeline>,

      -- Applied to after output help file is written. Takes doc as argument.
      write_post = --<function: various convenience actions>,
    },

    -- Path (relative to current directory) to script which handles project
    -- specific help file generation (like custom input files, hooks, etc.).
    script_path = 'scripts/minidoc.lua',
  }
<
# Notes ~

- `annotation_extractor` takes single string line as input. Output
  describes what makes an input to be an annotation (if anything). It
  should be similar to `string.find` with one capture group: start and end
  of annotation indicator (whole part will be removed from help line) with
  third value being string of section id (if input describes first line of
  section; `nil` or empty string otherwise). Output should be `nil` if line
  is not part of annotation.
  Default value means that annotation line should:
    - Start with `---` at first column.
    - Any non-whitespace after `---` will be treated as new section id.
    - Single whitespace at the start of main text will be ignored.
- Hooks are expected to be functions. Their default values might do many
  things which might change over time, so for more information please look
  at source code. Some more information can be found in
  |MiniDoc.default_hooks|.

------------------------------------------------------------------------------
                                                               *MiniDoc.current*
                               `MiniDoc.current`
Table with information about current state of auto-generation

It is reset at the beginning and end of `MiniDoc.generate()`.

At least these keys are supported:
- {aliases} - table with keys being alias name and values - alias
  description and single string (using `\n` to separate lines).
- {eval_section} - input section of `@eval` section hook. Can be used for
  information about current block, etc.
- {toc} - array with table of contents entries. Each entry is a whole
  `@toc_entry` section.

------------------------------------------------------------------------------
                                                         *MiniDoc.default_hooks*
                            `MiniDoc.default_hooks`
Default hooks

This is default value of `MiniDoc.config.hooks`. Use it if only a little
tweak is needed.

Some more insight about their behavior:
- Default inference of documented object metadata (tag and object signature
  at the moment) is done in `block_pre`. Inference is based on string
  pattern matching, so can lead to false results, although works in most
  cases. It intentionally works only if first line after block has no
  indentation and contains all necessary information to determine if
  inference should happen.
- Hooks for sections describing some "variable-like" object ('@class',
  '@field', '@param') automatically enclose first word in '{}'.
- Hooks for sections which supposed to have "type-like" data ('@field',
  '@param', '@return', '@type') automatically enclose *first found*
  "type-like" word and its neighbor characters in '`(<type>)`' (expect
  false positives). Algoritm is far from being 100% correct, but seems to
  work with present allowed type annotation. For allowed types see
  https://github.com/sumneko/lua-language-server/wiki/EmmyLua-Annotations#types-and-type
  or, better yet, look in source code of this module.
- Automated creation of table of contents (TOC) is done in the following way:
    - Put section with `@toc_entry` id in the annotation block. Section's
      lines will be registered as TOC entry.
    - Put `@toc` section where you want to insert rendered table of
      contents. TOC entries will be inserted on the left, references for
      their respective tag section (only first, if present) on the right.
      Render is done in default `doc` hook (because it should be done after
      processing all files).
- The `write_post` hook executes some actions convenient for iterative
  annotations writing:
    - Generate `:helptags` for directory containing output file.
    - Silently reload buffer containing output file (if such exists).
    - Display notification message about result.

------------------------------------------------------------------------------
                                                            *MiniDoc.generate()*
                `MiniDoc.generate`({input}, {output}, {config})
Generate help file

# Algoritm~

- Main parameters for help generation are an array of input file paths and
  path to output help file.
- Parse all inputs:
  - For each file, lines are processed top to bottom in order to create an
    array of documentation blocks. Each line is tested whether it is an
    annotation by applying `MiniDoc.config.annotation_extractor`: if
    anything is extracted, it is considered to be an annotation. Annotation
    line goes to "current block" after removing extracted annotation
    indicator, otherwise - to afterlines of "current block".
  - Each block's annotation lines are processed top to bottom. If line had
    captured section id, it is a first line of "current section" (first
    block lines are allowed to not specify section id; by default it is
    `@text`). All subsequent lines without captured section id go into
    "current section".
- Apply structure hooks (they should modify its input in place, which is
  possible due to 'table nature' of all inputs):
    - Each block is processed by `MiniDoc.config.hooks.block_pre`. This is a
      designated step for auto-generation of sections from descibed
      annotation subject (like sections with id `@tag`, `@type`).
    - Each section is processed by `MiniDoc.config.hooks.section_pre`.
    - Each section is processed by corresponding
      `MiniDoc.config.hooks.sections` function (table key equals to section
      id). This is a step where most of formatting should happen (like
      wrap first word of `@param` section with `{` and `}`, append empty
      line to section, etc.).
    - Each section is processed by `MiniDoc.config.hooks.section_post`.
    - Each block is processed by `MiniDoc.config.hooks.block_post`. This is
      a step for processing block after formatting is done (like add first
      line with `----` delimiter).
    - Each file is processed by `MiniDoc.config.hooks.file`. This is a step
      for adding any file-related data (like add first line with `====`
      delimiter).
    - Doc is processed by `MiniDoc.config.hooks.doc`. This is a step for
      adding any helpfile-related data (maybe like table of contents).
- Collect all strings from sections in depth-first fashion (equivalent to
  nested "for all files -> for all blocks -> for all sections -> for all
  strings -> add string to output") and write them to output file. Strings
  can have `\n` character indicating start of new line.
- Execute `MiniDoc.config.write_post` hook. This is useful for showing some
  feedback and making actions involving newly updated help file (like
  generate tags, etc.).

# Project specific script~

If all arguments have default `nil` values, first there is an attempt to
source project specific script. This is basically a `luafile
<MiniDoc.config.script_path>` with current Lua runtime while caching and
restoring current `MiniDoc.config`. Its successful execution stops any
further generation actions while error means proceeding generation as if no
script was found.

Typical script content might include definition of custom hooks, input and
output files with eventual call to `require('mini.doc').generate()` (with
or without arguments).

Parameters~
{input} `(table)` Array of file paths which will be processed in supplied
  order. Default: all '.lua' files from current directory following by all
  such files in these subdirectories: 'lua/', 'after/', 'colors/'. Note:
  any 'init.lua' file is placed before other files from the same directory.
{output} `(string)` Path for output help file. Default:
  `doc/<current_directory>.txt` (designed to be used for generating help
  file for plugin).
{config} `(table)` Configuration overriding parts of |MiniDoc.config|.

Return~
`(table)` Document structure which was generated and used for output
  help file. In case `MiniDoc.config.script_path` was successfully used,
  this is a return from the latest call of this function.

------------------------------------------------------------------------------
                                                  *MiniDoc.afterlines_to_code()*
                     `MiniDoc.afterlines_to_code`({struct})
Convert afterlines to code

This function is designed to be used together with `@eval` section to
automate documentation of certain values (notable default values of a
table). It processes afterlines based on certain directives and makes
output looking like a code block.

Most common usage is by adding the following section in your annotation:
`@eval return MiniDoc.afterlines_to_code(MiniDoc.current.eval_section)`

# Directives ~
Directives are special comments that are processed using Lua string pattern
capabilities (so beware of false positives). Each directive should be put
on its separate line. Supported directives:
- `--minidoc_afterlines_end` denotes a line at afterlines end. Only all
  lines before it will be considered as afterlines. Useful if there is
  extra code in afterlines which shouldn't be used.
- `--minidoc_replace_start <replacement>` and `--minidoc_replace_end`
  denote lines between them which should be replaced with `<replacement>`.
  Useful for manually changing what should be placed in output like in case
  of replacing function body with something else.

Here is an example. Suppose having these afterlines:
>
  --minidoc_replace_start {
  M.config = {
    --minidoc_replace_end
    param_one = 1,
    --minidoc_replace_start param_fun = --<function>
    param_fun = function(x)
      return x + 1
    end
    --minidoc_replace_end
  }
  --minidoc_afterlines_end

  return M
<

After adding `@eval` section those will be formatted as:
>
  {
    param_one = 1,
    param_fun = --<function>
  }
<
Parameters~
{struct} `(table)` Block or section structure which after lines will be
  converted to code.

Return~
`(string)` Single string (using `\n` to separate lines) describing
  afterlines as code block in help file.


==============================================================================
------------------------------------------------------------------------------
                                                                    *mini.fuzzy*
                                                                     *MiniFuzzy*
Lua module which implements minimal and fast fuzzy matching.

# Setup~

This module doesn't need setup, but it can be done to improve usability.
Setup with `require('mini.fuzzy').setup({})` (replace `{}` with your
`config` table). It will create global Lua table `MiniFuzzy` which you can
use for scripting or manually (with `:lua MiniFuzzy.*`).

See |MiniFuzzy.config| for `config` structure and default values.

You can override runtime config settings locally to buffer inside
`vim.b.minifuzzy_config` which should have same structure as
`MiniFuzzy.config`.
See |mini.nvim-buffer-local-config| for more details.

# Notes~

1. Currently there is no explicit design to work with multibyte symbols,
   but simple examples should work.
2. Smart case is used: case insensitive if input word (which is usually a
    user input) is all lower ase. Case sensitive otherwise.

------------------------------------------------------------------------------
                                                           *MiniFuzzy-algorithm*
# Algorithm design~

General design uses only width of found match and index of first letter
match. No special characters or positions (like in fzy and fzf) are used.

Given input `word` and target `candidate`:
- The goal is to find matching between `word`'s letters and letters in
  `candidate`, which minimizes certain score. It is assumed that order of
  letters in `word` and those matched in `candidate` should be the same.
- Matching is represented by matched positions: an array `positions` of
  integers with length equal to number of letters in `word`. The following
  should be always true in case of a match: `candidate`'s letter at index
  `positions[i]` is letters[i]` for all valid `i`.
- Matched positions are evaluated based only on two features: their width
  (number of indexes between first and last positions) and first match
  (index of first letter match). There is a global setting `cutoff` for
  which all feature values greater than it can be considered "equally bad".
- Score of matched positions is computed with following explicit formula:
  `cutoff * min(width, cutoff) + min(first, cutoff)`. It is designed to be
  equivalent to first comparing widths (lower is better) and then comparing
  first match (lower is better). For example, if `word = 'time'`:
    - '_time' (width 4) will have a better match than 't_ime' (width 5).
    - 'time_a' (width 4, first 1) will have a better match than 'a_time'
      (width 4, first 3).
- Final matched positions are those which minimize score among all possible
  matched positions of `word` and `candidate`.

------------------------------------------------------------------------------
                                                             *MiniFuzzy.setup()*
                          `MiniFuzzy.setup`({config})
Module setup

Parameters~
{config} `(table)` Module config table. See |MiniFuzzy.config|.

Usage~
`require('mini.fuzzy').setup({})` (replace `{}` with your `config` table)

------------------------------------------------------------------------------
                                                              *MiniFuzzy.config*
                               `MiniFuzzy.config`
Module config

Default values:
>
  MiniFuzzy.config = {
    -- Maximum allowed value of match features (width and first match). All
    -- feature values greater than cutoff can be considered "equally bad".
    cutoff = 100,
  }
<

------------------------------------------------------------------------------
                                                             *MiniFuzzy.match()*
                     `MiniFuzzy.match`({word}, {candidate})
Compute match data of input `word` and `candidate` strings

It tries to find best match for input string `word` (usually user input)
and string `candidate`. Returns table with elements:
- `positions` - array with letter indexes inside `candidate` which
  matched to corresponding letters in `word`. Or `nil` if no match.
- `score` - positive number representing how good the match is (lower is
  better). Or `-1` if no match.

Parameters~
{word} `(string)` Input word (usually user input).
{candidate} `(string)` Target word (usually with which matching is done).

Return~
`(table)` Table with matching information (see function's description).

------------------------------------------------------------------------------
                                                        *MiniFuzzy.filtersort()*
               `MiniFuzzy.filtersort`({word}, {candidate_array})
Filter string array

This leaves only those elements of input array which matched with `word`
and sorts from best to worst matches (based on score and index in original
array, both lower is better).

Parameters~
{word} `(string)` String which will be searched.
{candidate_array} `(table)` Lua array of strings inside which word will be
  searched.

Return~
`(...)` Arrays of matched candidates and their indexes in original input.

------------------------------------------------------------------------------
                                                 *MiniFuzzy.process_lsp_items()*
                 `MiniFuzzy.process_lsp_items`({items}, {base})
Fuzzy matching for |MiniCompletion.lsp_completion.process_items|

Parameters~
{items} `(table)` Lua array with LSP 'textDocument/completion' response items.
{base} `(string)` Word to complete.

------------------------------------------------------------------------------
                                              *MiniFuzzy.get_telescope_sorter()*
                    `MiniFuzzy.get_telescope_sorter`({opts})
Custom getter for `telescope.nvim` sorter

Designed to be used as value for |telescope.defaults.file_sorter| and
|telescope.defaults.generic_sorter| inside `setup()` call.

Parameters~
{opts} `(table)` Options (currently not used).

Usage~
>
  require('telescope').setup({
    defaults = {
      generic_sorter = require('mini.fuzzy').get_telescope_sorter
    }
  })


==============================================================================
------------------------------------------------------------------------------
                                                              *mini.indentscope*
                                                               *MiniIndentscope*
Visualize and operate on indent scope

Indent scope (or just "scope") is a maximum set of consecutive lines which
contains certain reference line (cursor line by default) and every member
has indent not less than certain reference indent ("indent at cursor" by
default: minimum between cursor column and indent of cursor line).

Features:
- Visualize scope with vertical line. It is very fast and done
  automatically in a non-blocking way (other operations can be performed,
  like moving cursor). You can customize debounce delay and animation rule.
- Customization of scope computation options can be done on global level
  (in |MiniIndentscope.config|), for a certain buffer (using
  `vim.b.miniindentscope_config` buffer variable), or within a call (using
  `opts` variable in |MiniIndentscope.get_scope|).
- Customizable notion of a border: which adjacent lines with strictly lower
  indent are recognized as such. This is useful for a certain filetypes
  (for example, Python or plain text).
- Customizable way of line to be considered "border first". This is useful
  if you want to place cursor on function header and get scope of its body.
- There are textobjects and motions to operate on scope. Support |count|
  and dot-repeat (in operator pending mode).

# Setup~

This module needs a setup with `require('mini.indentscope').setup({})`
(replace `{}` with your `config` table). It will create global Lua table
`MiniIndentscope` which you can use for scripting or manually (with `:lua
MiniIndentscope.*`).

See |MiniIndentscope.config| for available config settings.

You can override runtime config settings locally to buffer inside
`vim.b.miniindentscope_config` which should have same structure as
`MiniIndentscope.config`. See |mini.nvim-buffer-local-config| for more details.

# Comparisons~

- 'lukas-reineke/indent-blankline.nvim':
    - Its main functionality is about showing static guides of indent levels.
    - Implementation of 'mini.indentscope' is similar to
      'indent-blankline.nvim' (using |extmarks| on first column to be shown
      even on blank lines). They can be used simultaneously, but it will
      lead to one of the visualizations being on top (hiding) of another.

# Highlight groups~

* `MiniIndentscopeSymbol` - symbol showing on every line of scope.
* `MiniIndentscopePrefix` - space before symbol. By default made so as to
  appear as nothing is displayed.

To change any highlight group, modify it directly with |:highlight|.

# Disabling~

To disable autodrawing, set `g:miniindentscope_disable` (globally) or
`b:miniindentscope_disable` (for a buffer) to `v:true`. Considering high
number of different scenarios and customization intentions, writing exact
rules for disabling module's functionality is left to user. See
|mini.nvim-disabling-recipes| for common recipes.

------------------------------------------------------------------------------
                                                       *MiniIndentscope-drawing*
Drawing of scope indicator

Draw of scope indicator is done as iterative animation. It has the
following design:
- Draw indicator on origin line (where cursor is at) immediately. Indicator
  is visualized as `MiniIndentscope.config.symbol` placed to the right of
  scope's border indent. This creates a line from top to bottom scope edges.
- Draw upward and downward concurrently per one line. Progression by one
  line in both direction is considered to be one step of animation.
- Before each step wait certain amount of time, which is decided by
  "animation function". It takes next and total step numbers (both are one
  or bigger) and returns number of milliseconds to wait before drawing next
  step. Comparing to a more popular "easing functions" in animation (input:
  duration since animation start; output: percent of animation done), it is
  a discrete inverse version of its derivative. Such interface proved to be
  more appropriate for kind of task at hand.

Special cases~

- When scope to be drawn intersects (same indent, ranges overlap) currently
  visible one (at process or finished drawing), drawing is done immediately
  without animation. With most common example being typing new text, this
  feels more natural.
- Scope for the whole buffer is not drawn as it is isually redundant.
  Technically, it can be thought as drawn at column 0 (because border
  indent is -1) which is not visible.

------------------------------------------------------------------------------
                                                       *MiniIndentscope.setup()*
                       `MiniIndentscope.setup`({config})
Module setup

Parameters~
{config} `(table)` Module config table. See |MiniIndentscope.config|.

Usage~
`require('mini.indentscope').setup({})` (replace `{}` with your `config` table)

------------------------------------------------------------------------------
                                                        *MiniIndentscope.config*
                            `MiniIndentscope.config`
Module config

Default values:
>
  MiniIndentscope.config = {
    draw = {
      -- Delay (in ms) between event and start of drawing scope indicator
      delay = 100,

      -- Animation rule for scope's first drawing. A function which, given next
      -- and total step numbers, returns wait time (in ms). See
      -- |MiniIndentscope.gen_animation()| for builtin options. To not use
      -- animation, supply `require('mini.indentscope').gen_animation('none')`.
      animation = --<function: implements constant 20ms between steps>,
    },

    -- Module mappings. Use `''` (empty string) to disable one.
    mappings = {
      -- Textobjects
      object_scope = 'ii',
      object_scope_with_border = 'ai',

      -- Motions (jump to respective border line; if not present - body line)
      goto_top = '[i',
      goto_bottom = ']i',
    },

    -- Options which control scope computation
    options = {
      -- Type of scope's border: which line(s) with smaller indent to
      -- categorize as border. Can be one of: 'both', 'top', 'bottom', 'none'.
      border = 'both',

      -- Whether to use cursor column when computing reference indent. Useful to
      -- see incremental scopes with horizontal cursor movements.
      indent_at_cursor = true,

      -- Whether to first check input line to be a border of adjacent scope.
      -- Use it if you want to place cursor on function header to get scope of
      -- its body.
      try_as_border = false,
    },

    -- Which character to use for drawing scope indicator
    symbol = '',
  }
<
# Options ~

- Options can be supplied globally (from this `config`), locally to buffer
  (via `options` field of `vim.b.miniindentscope_config` buffer variable),
  or locally to call (as argument to |MiniIndentscope.get_scope()|).

- Option `border` controls which line(s) with smaller indent to categorize
  as border. This matters for textobjects and motions.
  It also controls how empty lines are treated: they are included in scope
  only if followed by a border. Another way of looking at it is that indent
  of blank line is computed based on value of `border` option.
  Here is an illustration of how `border` works in presense of empty lines:
>
                             |both|bottom|top|none|
  1|function foo()           | 0  |  0   | 0 | 0  |
  2|                         | 4  |  0   | 4 | 0  |
  3|    print('Hello world') | 4  |  4   | 4 | 4  |
  4|                         | 4  |  4   | 2 | 2  |
  5|  end                    | 2  |  2   | 2 | 2  |
<
  Numbers inside a table are indent values of a line computed with certain
  value of `border`. So, for example, a scope with reference line 3 and
  right-most column has body range depending on value of `border` option:
    - `border` is "both":   range is 2-4, border is 1 and 5 with indent 2.
    - `border` is "top":    range is 2-3, border is 1 with indent 0.
    - `border` is "bottom": range is 3-4, border is 5 with indent 0.
    - `border` is "none":   range is 3-3, border is empty with indent `nil`.

- Option `indent_at_cursor` controls if cursor position should affect
  computation of scope. If `true`, reference indent is a minimum of
  reference line's indent and cursor column. In main example, here how
  scope's body range differs depending on cursor column and `indent_at_cursor`
  value (assuming cursor is on line 3 and it is whole buffer):
>
    Column\Option true|false
       1 and 2    2-5 | 2-4
     3 and more   2-4 | 2-4
<
- Option `try_as_border` controls how to act when input line can be
  recognized as a border of some neighbor indent scope. In main example,
  when input line is 1 and can be recognized as border for inner scope,
  value `try_as_border = true` means that inner scope will be returned.
  Similar, for input line 5 inner scope will be returned if it is
  recognized as border.

------------------------------------------------------------------------------
                                                   *MiniIndentscope.get_scope()*
               `MiniIndentscope.get_scope`({line}, {col}, {opts})
Compute indent scope

Indent scope (or just "scope") is a maximum set of consecutive lines which
contains certain reference line (cursor line by default) and every member
has indent not less than certain reference indent ("indent at column" by
default). Here "indent at column" means minimum between input column value
and indent of reference line. When using cursor column, this allows for a
useful interactive view of nested indent scopes by making horizontal
movements within line.

Options controlling actual computation is taken from these places in order:
- Argument `opts`. Use it to ensure independence from other sources.
- Buffer local variable `vim.b.miniindentscope_config` (`options` field).
  Useful to define local behavior (for example, for a certain filetype).
- Global options from |MiniIndentscope.config|.

Algorithm overview~

- Compute reference "indent at column". Reference line is an input `line`
  which might be modified to one of its neighbors if `try_as_border` option
  is `true`: if it can be viewed as border of some neighbor scope, it will.
- Process upwards and downwards from reference line to search for line with
  indent strictly less than reference one. This is like casting rays up and
  down from reference line and reference indent until meeting "a wall"
  (character to the right of indent or buffer edge). Latest line before
  meeting is a respective end of scope body. It always exists because
  reference line is a such one.
- Based on top and bottom lines with strictly lower indent, construct
  scopes's border. The way it is computed is decided based on `border`
  option (see |MiniIndentscope.config| for more information).
- Compute border indent as maximum indent of border lines (or reference
  indent minus one in case of no border). This is used during drawing
  visual indicator.

Indent computation~

For every line indent is intended to be computed unambiguously:
- For "normal" lines indent is an output of |indent()|.
- Indent is `-1` for imaginary lines 0 and past last line.
- For blank and empty lines indent is computed based on previous
  (|prevnonblank()|) and next (|nextnonblank()|) non-blank lines. The way
  it is computed is decided based on `border` in order to not include blank
  lines at edge of scope's body if there is no border there. See
  |MiniIndentscope.config| for a details example.

Parameters~
{line} `(number)` Input line number (starts from 1). Can be modified to a
  neighbor if `try_as_border` is `true`. Default: cursor line.
{col} `(number)` Column number (starts from 1). Default: if
  `indent_at_cursor` option is `true` - cursor column from `curswant` of
  |getcurpos()| (allows for more natural behavior on empty lines);
  `math.huge` otherwise in order to not incorporate cursor in computation.
{opts} `(table)` Options to override global or buffer local ones (see
  |MiniIndentscope.config|).

Return~
`(table)` Table with scope information:
  - <body> - table with <top> (top line of scope, inclusive), <bottom>
    (bottom line of scope, inclusive), and <indent> (minimum indent withing
    scope) keys. Line numbers start at 1.
  - <border> - table with <top> (line of top border, might be `nil`),
    <bottom> (line of bottom border, might be `nil`), and <indent> (indent
    of border) keys. Line numbers start at 1.
  - <buf_id> - identifier of current buffer.
  - <reference> - table with <line> (reference line), <column> (reference
    column), and <indent> ("indent at column") keys.

------------------------------------------------------------------------------
                                                   *MiniIndentscope.auto_draw()*
                      `MiniIndentscope.auto_draw`({opts})
Auto draw scope indicator based on movement events

Designed to be used with |autocmd|. No need to use it directly, everything
is setup in |MiniIndentscope.setup|.

Parameters~
{opts} `(table)` Options.

------------------------------------------------------------------------------
                                                        *MiniIndentscope.draw()*
                    `MiniIndentscope.draw`({scope}, {opts})
Draw scope manually

Scope is visualized as a vertical line withing scope's body range at column
equal to border indent plus one (or body indent if border is absent).
Numbering starts from one.

Parameters~
{scope} `(table)` Scope. Default: output of |MiniIndentscope.get_scope|
  with default arguments.
{opts} `(table)` Options. Currently supported:
   - <animation_fun> - animation function for drawing. See
     |MiniIndentscope-drawing| and |MiniIndentscope.gen_animation()|.

------------------------------------------------------------------------------
                                                      *MiniIndentscope.undraw()*
                           `MiniIndentscope.undraw`()
Undraw currently visible scope manually

------------------------------------------------------------------------------
                                               *MiniIndentscope.gen_animation()*
               `MiniIndentscope.gen_animation`({easing}, {opts})
Generate builtin animation function

This is a builtin source to generate animation function for usage in
`MiniIndentscope.config.draw.animation`. Most of them are variations of
common easing functions, which provide certain type of progression for
revealing scope visual indicator.

Supported easing types:
- `'none'` - show indicator immediately. Equivalent to animation function
  always returning 0.
- `'linear'` - linear progression.
- Quadratic progression:
    - `'quadraticIn'` - accelerating from zero speed.
    - `'quadraticOut'` - decelerating to zero speed.
    - `'quadraticInOut'` - accelerating halfway, decelerating after.
- Cubic progression:
    - `'cubicIn'` - accelerating from zero speed.
    - `'cubicOut'` - decelerating to zero speed.
    - `'cubicInOut'` - accelerating halfway, decelerating after.
- Quartic progression:
    - `'quarticIn'` - accelerating from zero speed.
    - `'quarticOut'` - decelerating to zero speed.
    - `'quarticInOut'` - accelerating halfway, decelerating after.
- Exponential progression:
    - `'exponentialIn'` - accelerating from zero speed.
    - `'exponentialOut'` - decelerating to zero speed.
    - `'exponentialInOut'` - accelerating halfway, decelerating after.

Customization of duration and other general behavior of output animation
function is done through `opts` argument.

Parameters~
{easing} `(string)` One of supported easing types.
{opts} `(table)` Options that control progression. Possible keys:
  - <duration> `(number)` - duration (in ms) of a unit. Default: 20.
  - <unit> `(string)` - which unit's duration `opts.duration` controls. One
    of "step" (default; ensures average duration of step to be `opts.duration`)
    or "total" (ensures fixed total duration regardless of scope's range).

Return~
`(function)` Animation function (see |MiniIndentscope-drawing|).

Examples~
- Don't use animation: `gen_animation('none')`
- Use quadratic "out" easing with total duration of 1000 ms:
  `gen_animation('quadraticOut', { duration = 1000, unit = 'total' })`

See also~
|MiniIndentscope-drawing| for more information about how drawing is done.

------------------------------------------------------------------------------
                                                 *MiniIndentscope.move_cursor()*
          `MiniIndentscope.move_cursor`({side}, {use_border}, {scope})
Move cursor within scope

Cursor is placed on a first non-blank character of target line.

Parameters~
{side} `(string)` One of "top" or "bottom".
{use_border} `(boolean)` Whether to move to border or withing scope's body.
  If particular border is absent, body is used.
{scope} `(table)` Scope to use. Default: output of |MiniIndentscope.get_scope()|.

------------------------------------------------------------------------------
                                                    *MiniIndentscope.operator()*
             `MiniIndentscope.operator`({side}, {add_to_jumplist})
Function for motion mappings

Move to a certain side of border. Respects |count| and dot-repeat (in
operator-pending mode). Doesn't move cursor for scope that is not shown
(drawing indent less that zero).

Parameters~
{side} `(string)` One of "top" or "bottom".
{add_to_jumplist} `(boolean)` Whether to add movement to jump list. It is
  `true` only for Normal mode mappings.

------------------------------------------------------------------------------
                                                  *MiniIndentscope.textobject()*
                   `MiniIndentscope.textobject`({use_border})
Function for textobject mappings

Respects |count| and dot-repeat (in operator-pending mode). Doesn't work
for scope that is not shown (drawing indent less that zero).

Parameters~
{use_border} `(boolean)` Whether to include border in textobject. When
  `true` and `try_as_border` option is `false`, allows "chaining" calls for
  incremental selection.


==============================================================================
------------------------------------------------------------------------------
                                                                     *mini.jump*
                                                                      *MiniJump*
Minimal and fast module for smarter jumping to a single character. Inspired
by 'rhysd/clever-f.vim'.

Features:
- Extend f, F, t, T to work on multiple lines.
- Repeat jump by pressing f, F, t, T again. It is reset when cursor moved
  as a result of not jumping or timeout after idle time (duration
  customizable).
- Highlight (after customizable delay) of all possible target characters.
- Normal, Visual, and Operator-pending (with full dot-repeat) modes are
  supported.

This module follows vim's 'ignorecase' and 'smartcase' options. When
'ignorecase' is set, f, F, t, T will match case-insensitively. When
'smartcase' is also set, f, F, t, T will only match lowercase
characters case-insensitively.

# Setup~

This module needs a setup with `require('mini.jump').setup({})`
(replace `{}` with your `config` table). It will create global Lua table
`MiniJump` which you can use for scripting or manually (with
`:lua MiniJump.*`).

See |MiniJump.config| for `config` structure and default values.

You can override runtime config settings locally to buffer inside
`vim.b.minijump_config` which should have same structure as
`MiniJump.config`. See |mini.nvim-buffer-local-config| for more details.

# Highlight groups~

* `MiniJump` - all possible cursor positions.

To change any highlight group, modify it directly with |:highlight|.

# Disabling~

To disable core functionality, set `g:minijump_disable` (globally) or
`b:minijump_disable` (for a buffer) to `v:true`. Considering high number of
different scenarios and customization intentions, writing exact rules for
disabling module's functionality is left to user. See
|mini.nvim-disabling-recipes| for common recipes.

------------------------------------------------------------------------------
                                                              *MiniJump.setup()*
                           `MiniJump.setup`({config})
Module setup

Parameters~
{config} `(table)` Module config table. See |MiniJump.config|.

Usage~
`require('mini.jump').setup({})` (replace `{}` with your `config` table)

------------------------------------------------------------------------------
                                                               *MiniJump.config*
                               `MiniJump.config`
Module config

Default values:
>
  MiniJump.config = {
    -- Module mappings. Use `''` (empty string) to disable one.
    mappings = {
      forward = 'f',
      backward = 'F',
      forward_till = 't',
      backward_till = 'T',
      repeat_jump = ';',
    },

    -- Delay values (in ms) for different functionalities. Set any of them to
    -- a very big number (like 10^7) to virtually disable.
    delay = {
      -- Delay between jump and highlighting all possible jumps
      highlight = 250,

      -- Delay between jump and automatic stop if idle (no jump is done)
      idle_stop = 10000000,
    },
  }
<

------------------------------------------------------------------------------
                                                                *MiniJump.state*
                                `MiniJump.state`
Data about jumping state

It stores various information used in this module. All elements, except
`jumping`, is about the latest jump. They are used as default values for
similar arguments.

Class~
{JumpingState}

Fields~
{target} `(string)` The string to jump to.
{backward} `(boolean)` Whether to jump backward.
{till} `(boolean)` Whether to jump just before/after the match instead of
  exactly on target. Also ignore matches that have nothing before/after them.
{n_times} `(number)` Number of times to perform consecutive jumps.
{mode} `(string)` Mode of latest jump (output of |mode()| with non-zero argument).
{jumping} `(boolean)` Whether module is currently in "jumping mode": usage of
  |MiniJump.smart_jump| and all mappings won't require target.

Initial values:
>
  MiniJump.state = {
    target = nil,
    backward = false,
    till = false,
    n_times = 1,
    mode = nil,
    jumping = false,
  }
<

------------------------------------------------------------------------------
                                                               *MiniJump.jump()*
            `MiniJump.jump`({target}, {backward}, {till}, {n_times})
Jump to target

Takes a string and jumps to its first occurrence in desired direction.

All default values are taken from |MiniJump.state| to emulate latest jump.

Parameters~
{target} `(string)` The string to jump to.
{backward} `(boolean)` Whether to jump backward.
{till} `(boolean)` Whether to jump just before/after the match instead of
  exactly on target. Also ignore matches that have nothing before/after them.
{n_times} `(number)` Number of times to perform consecutive jumps.

------------------------------------------------------------------------------
                                                         *MiniJump.smart_jump()*
                   `MiniJump.smart_jump`({backward}, {till})
Make smart jump

If the last movement was a jump, perform another jump with the same target.
Otherwise, wait for a target input (via |getchar()|). Respects |v:count|.

All default values are taken from |MiniJump.state| to emulate latest jump.

Parameters~
{backward} `(boolean)` Whether to jump backward.
{till} `(boolean)` Whether to jump just before/after the match instead of
  exactly on target. Also ignore matches that have nothing before/after them.

------------------------------------------------------------------------------
                                                          *MiniJump.expr_jump()*
                    `MiniJump.expr_jump`({backward}, {till})
Make expression jump

Cache information about the jump and return string with command to perform
jump. Designed to be used inside Operator-pending mapping (see
|omap-info|). Always asks for target (via |getchar()|). Respects |v:count|.

All default values are taken from |MiniJump.state| to emulate latest jump.

Parameters~
{backward} `(boolean)` Whether to jump backward.
{till} `(boolean)` Whether to jump just before/after the match instead of
  exactly on target. Also ignore matches that have nothing before/after them.

------------------------------------------------------------------------------
                                                       *MiniJump.stop_jumping()*
                           `MiniJump.stop_jumping`()
Stop jumping

Removes highlights (if any) and forces the next smart jump to prompt for
the target. Automatically called on appropriate Neovim |events|.

------------------------------------------------------------------------------
                                                     *MiniJump.on_cursormoved()*
                          `MiniJump.on_cursormoved`()
Act on |CursorMoved|


==============================================================================
------------------------------------------------------------------------------
                                                                   *mini.jump2d*
                                                                    *MiniJump2d*
Minimal and fast Lua plugin for jumping (moving cursor) within
visible lines via iterative label filtering. Main inspiration is a
"phaazon/hop.nvim" plugin, but this module has a slightly different idea
about how target jump spot is chosen.

Features:
- Make jump by iterative filtering of possible, equally considered jump
  spots until there is only one. Filtering is done by typing a label
  character that is visualized at jump spot.
- Customizable:
    - Way of computing possible jump spots with opinionated default.
    - Characters used to label jump spots during iterative filtering.
    - Action hooks to be executed at certain events during jump.
    - Allowed windows: current and/or not current.
    - Allowed lines: whether to process blank or folded lines, lines
      before/at/after cursor line, etc. Example: user can configure to look
      for spots only inside current window at or after cursor line.
    Example: user can configure to look for word starts only inside current
    window at or after cursor line with 'j' and 'k' labels performing some
    action after jump.
- Works in Visual and Operator-pending (with dot-repeat) modes.
- Preconfigured ways of computing jump spots (see |MiniJump2d.builtin_opts|).
- Works with multibyte characters.

General overview of how jump is intended to be performed:
- Lock eyes on desired location ("spot") recognizable by future jump.
  Should be within visible lines at place where cursor can be placed.
- Initiate jump. Either by custom keybinding or with a call to
  |MiniJump2d.start()| (allows customization options). This will highlight
  all possible jump spots with their labels (letters from "a" to "z" by
  default). For more details, read |MiniJump2d.start()| and |MiniJump2d.config|.
- Type character that appeared over desired location. If its label was
  unique, jump is performed. If it wasn't unique, possible jump spots are
  filtered to those having the same label character.
- Repeat previous step until there is only one possible jump spot or type `<CR>`
  to jump to first available jump spot. Typing anything else stops jumping
   without moving cursor.

# Setup~

This module needs a setup with `require('mini.jump2d').setup({})` (replace
`{}` with your `config` table). It will create global Lua table
`MiniJump2d` which you can use for scripting or manually (with
`:lua MiniJump2d.*`).

See |MiniJump2d.config| for available config settings.

You can override runtime config settings locally to buffer inside
`vim.b.minijump2d_config` which should have same structure as
`MiniJump2d.config`. See |mini.nvim-buffer-local-config| for more details.

# Example usage~

- Modify default jumping to use only current window at or after cursor line: >
  require('mini.jump2d').setup({
    allowed_lines = { cursor_before = false },
    allowed_windows = { not_current = false },
  })
- `lua MiniJump2d.start(MiniJump2d.builtin_opts.line_start)` - jump to word
  start using combination of options supplied in |MiniJump2d.config| and
  |MiniJump2d.builtin_opts.line_start|.
- `lua MiniJump2d.start(MiniJump2d.builtin_opts.single_character)` - jump
  to single character typed after executing this command.
- See more examples in |MiniJump2d.start| and |MiniJump2d.builtin_opts|.

# Comparisons~

- 'phaazon/hop.nvim':
    - Both are fast, customizable, and extensible (user can write their own
      ways to define jump spots).
    - Both have several builtin ways to specify type of jump (word start,
      line start, one character or query based on user input). 'hop.nvim'
      does that by exporting many targeted Neovim commands, while this
      module has preconfigured basic options leaving others to
      customization with Lua code (see |MiniJump2d.builtin_opts|).
    - 'hop.nvim' computes labels (called "hints") differently. Contrary to
      this module deliberately not having preference of one jump spot over
      another, 'hop.nvim' uses specialized algorithm that produces sequence
      of keys in a slightly biased manner: some sequences are intentionally
      shorter than the others (leading to fewer average keystrokes). They
      are put near cursor (by default) and highlighted differently. Final
      order of sequences is based on distance to the cursor.
    - 'hop.nvim' visualizes labels differently. It is designed to show
      whole sequences at once, while this module intentionally shows only
      current one at a time.
    - 'mini.jump2d' has opinionated default algorithm of computing jump
      spots. See |MiniJump2d.default_spotter|.

# Highlight groups~

* `MiniJump2dSpot` - highlighting of jump spots. By default it uses label
  with highest contrast while not being too visually demanding: white on
  black for dark 'background', black on white for light. If it doesn't
  suit your liking, try couple of these alternatives (or choose your own,
  of course):
    - `hi MiniJump2dSpot gui=reverse` - reverse underlying highlighting (more
      colorful while being visible in any colorscheme).
    - `hi MiniJump2dSpot gui=bold,italic` - bold italic.
    - `hi MiniJump2dSpot gui=undercurl guisp=red` - red undercurl.

To change any highlight group, modify it directly with |:highlight|.

# Disabling~

To disable, set `g:minijump2d_disable` (globally) or `b:minijump2d_disable`
(for a buffer) to `v:true`. Considering high number of different scenarios
and customization intentions, writing exact rules for disabling module's
functionality is left to user. See |mini.nvim-disabling-recipes| for common
recipes.

------------------------------------------------------------------------------
                                                            *MiniJump2d.setup()*
                          `MiniJump2d.setup`({config})
Module setup

Parameters~
{config} `(table)` Module config table. See |MiniJump2d.config|.

Usage~
`require('mini.jump2d').setup({})` (replace `{}` with your `config` table)

------------------------------------------------------------------------------
                                                             *MiniJump2d.config*
                              `MiniJump2d.config`
Module config

Default values:
>
  MiniJump2d.config = {
    -- Function producing jump spots (byte indexed) for a particular line.
    -- For more information see |MiniJump2d.start|.
    -- If `nil` (default) - use |MiniJump2d.default_spotter|
    spotter = nil,

    -- Characters used for labels of jump spots (in supplied order)
    labels = 'abcdefghijklmnopqrstuvwxyz',

    -- Which lines are used for computing spots
    allowed_lines = {
      blank = true, -- Blank line (not sent to spotter even if `true`)
      cursor_before = true, -- Lines before cursor line
      cursor_at = true, -- Cursor line
      cursor_after = true, -- Lines after cursor line
      fold = true, -- Start of fold (not sent to spotter even if `true`)
    },

    -- Which windows from current tabpage are used for visible lines
    allowed_windows = {
      current = true,
      not_current = true,
    },

    -- Functions to be executed at certain events
    hooks = {
      before_start = nil, -- Before jump start
      after_jump = nil, -- After jump was actually done
    },

    -- Module mappings. Use `''` (empty string) to disable one.
    mappings = {
      start_jumping = '<CR>',
    },
  }
<
# Options~

## Spotter function~

Actual computation of possible jump spots is done through spotter function.
It should have the following arguments:
- `line_num` is a line number inside buffer.
- `args` - table with additional arguments:
    - {win_id} - identifier of a window where input line number is from.
    - {win_id_init} - identifier of a window which was current when
      `MiniJump2d.start()` was called.

Its output is a list of byte-indexed positions that should be considered as
possible jump spots for this particular line in this particular window.
Note: for a more aligned visualization this list should be (but not
strictly necessary) sorted increasingly.

Note: spotter function is always called with `win_id` window being
"temporary current" (see |nvim_win_call|). This allows using builtin
Vimscript functions that operate only inside current window.

## Allowed lines~

Option `allowed_lines` controls which lines will be used for computing
possible jump spots:
- If `blank` or `fold` is `true`, it is possible to jump to first column of blank
  line (determined by |prevnonblank|) or first folded one (determined by
  |foldclosed|) respectively. Otherwise they are skipped. These lines are
  not processed by spotter function even if the option is `true`.
- If `cursor_before`, (`cursor_at`, `cursor_after`) is `true`, lines before
  (at, after) cursor line of all processed windows are forwarded to spotter
  function. Otherwise, they don't. This allows control of jump "direction".

## Hooks~

Following hook functions can be used to further tweak jumping experience:
- `before_start` - called without arguments first thing when jump starts.
  One of the possible use cases is to ask for user input and update spotter
  function with it.
- `after_jump` - called after jump was actually done. Useful to make
  post-adjustments (like move cursor to first non-whitespace character).

------------------------------------------------------------------------------
                                                            *MiniJump2d.start()*
                           `MiniJump2d.start`({opts})
Start jumping

Compute possible jump spots, visualize them and wait for iterative filtering.

First computation of possible jump spots~

- Process allowed windows (current and/or not current; controlled by
  `allowed_windows` option) by visible lines from top to bottom. For each
  one see if it is allowed (controlled by `allowed_lines` option). If not
  allowed, then do nothing. If allowed and should be processed by
  `spotter`, process it.
- Apply spotter function from `spotter` option for each appropriate line
  and concatenate outputs. This means that eventual order of jump spots
  aligns with lexicographical order within "window id" - "line number" -
  "position in `spotter` output" tuples.
- For each possible jump compute its label: a single character from
  `labels` option used to filter jump spots. Each possible label character
  might be used more than once to label several "consecutive" jump spots.
  It is done in an optimal way under assumption of no preference of one
  spot over another. Basically, it means "use all labels at each step of
  iterative filtering as equally as possible".

Visualization~

Current label for each possible jump spot is shown at that position
overriding everything underneath it.

Iterative filtering~

Labels of possible jump spots are computed in order to use them as equally
as possible.

Example:
- With `abc` as `labels` option, initial labels for 10 possible jumps
  are "aaaabbbccc". As there are 10 spots which should be "coded" with 3
  symbols, at least 2 symbols need 3 steps to filter them out. With current
  implementation those are always the "first ones".
- After typing `a`, it filters first four jump spots and recomputes its
  labels to be "aabc".
- After typing `a` again, it filters first two spots and recomputes its
  labels to be "ab".
- After typing either `a` or `b` it filters single spot and makes jump.

With default 26 labels for most real-world cases 2 steps is enough for
default spotter function. Rarely 3 steps are needed with several windows.

Parameters~
{opts} `(table)` Configuration of jumping, overriding global and buffer
  local values.config|. Has the same structure as |MiniJump2d.config|
  without <mappings> field. Extra allowed fields:
    - <hl_group> - which highlight group to use (default: "MiniJump2dSpot").

Usage~
- Start default jumping:
  `MiniJump2d.start()`
- Jump to word start:
  `MiniJump2d.start(MiniJump2d.builtin_opts.word_start)`
- Jump to single character from user input (follow by typing one character):
  `MiniJump2d.start(MiniJump2d.builtin_opts.single_character)`
- Jump to first character of punctuation group only inside current window
  which is placed at cursor line; visualize with 'hl-Search': >
  MiniJump2d.start({
    spotter = MiniJump2d.gen_pattern_spotter('%p+'),
    allowed_lines = { cursor_before = false, cursor_after = false },
    allowed_windows = { not_current = false },
    hl_group = 'Search'
  })

See also~
|MiniJump2d.config|

------------------------------------------------------------------------------
                                                             *MiniJump2d.stop()*
                              `MiniJump2d.stop`()
Stop jumping

------------------------------------------------------------------------------
                                              *MiniJump2d.gen_pattern_spotter()*
              `MiniJump2d.gen_pattern_spotter`({pattern}, {side})
Generate spotter for Lua pattern

Parameters~
{pattern} `(string|nil)` Lua pattern. Default: `'[^%s%p]+'` which matches group
  of "non-whitespace non-punctuation characters" (basically a way of saying
  "group of alphanumeric characters" that works with multibyte characters).
{side} `(string|nil)` Which side of pattern match should be considered as
  jumping spot. Should be one of 'start' (start of match, default), 'end'
  (inclusive end of match), or 'none' (match for spot is done manually
  inside pattern with plain `()` matching group).

Usage~
- Match any punctuation:
  `MiniJump2d.gen_pattern_spotter('%p')`
- Match first from line start non-whitespace character:
  `MiniJump2d.gen_pattern_spotter('^%s*%S', 'end')`
- Match start of last word:
  `MiniJump2d.gen_pattern_spotter('[^%s%p]+[%s%p]-$', 'start')`
- Match letter followed by another letter (example of manual matching
  inside pattern):
  `MiniJump2d.gen_pattern_spotter('%a()%a', 'none')`

------------------------------------------------------------------------------
                                                    *MiniJump2d.default_spotter*
                          `MiniJump2d.default_spotter`
Default spotter function

Spot is possible for jump if it is one of the following:
- Start or end of non-whitespace character group.
- Alphanumeric character followed or preceeded by punctuation (useful for
  snake case names).
- Start of uppercase character group (useful for camel case names). Usually
  only Lating alphabet is recognized due to Lua patterns shortcomings.

These rules are derived in an attempt to balance between two intentions:
- Allow as much useful jumping spots as possible.
- Make labeled jump spots easily distinguishable.

Usually takes from 2 to 3 keystrokes to get to destination.

------------------------------------------------------------------------------
                                                       *MiniJump2d.builtin_opts*
                           `MiniJump2d.builtin_opts`
Table with builtin `opts` values for |MiniJump2d.start()|

Each element of table is itself a table defining one or several options for
`MiniJump2d.start()`. Read help description to see which options it defines
(like in |MiniJump2d.builtin_opts.line_start|).

Usage~
Using |MiniJump2d.builtin_opts.line_start| as example:
- Command:
  `:lua MiniJump2d.start(MiniJump2d.builtin_opts.line_start)`
- Custom mapping: >
  vim.api.nvim_set_keymap(
    'n', '<CR>',
    '<Cmd>lua MiniJump2d.start(MiniJump2d.builtin_opts.line_start)<CR>', {}
  )
- Inside |MiniJump2d.setup| (make sure to use all defined options): >
  local jump2d = require('mini.jump2d')
  local jump_line_start = jump2d.builtin_opts.line_start
  jump2d.setup({
    spotter = jump_line_start.spotter,
    hooks = { after_jump = jump_line_start.hooks.after_jump }
  })
<

------------------------------------------------------------------------------
                                               *MiniJump2d.builtin_opts.default*
                       `MiniJump2d.builtin_opts.default`
Jump with |MiniJump2d.default_spotter()|

Defines `spotter`.

------------------------------------------------------------------------------
                                            *MiniJump2d.builtin_opts.line_start*
                      `MiniJump2d.builtin_opts.line_start`
Jump to line start

Defines `spotter` and `hooks.after_jump`.

------------------------------------------------------------------------------
                                            *MiniJump2d.builtin_opts.word_start*
                      `MiniJump2d.builtin_opts.word_start`
Jump to word start

Defines `spotter`.

------------------------------------------------------------------------------
                                      *MiniJump2d.builtin_opts.single_character*
                   `MiniJump2d.builtin_opts.single_character`
Jump to single character taken from user input

Defines `spotter`, `allowed_lines.blank`, `allowed_lines.fold`, and
`hooks.before_start`.

------------------------------------------------------------------------------
                                                 *MiniJump2d.builtin_opts.query*
                        `MiniJump2d.builtin_opts.query`
Jump to query taken from user input

Defines `spotter`, `allowed_lines.blank`, `allowed_lines.fold`, and
`hooks.before_start`.


==============================================================================
------------------------------------------------------------------------------
                                                                     *mini.misc*
                                                                      *MiniMisc*
Lua module with miscellaneous useful functions (can be used independently).

# Setup~

This module doesn't need setup, but it can be done to improve usability.
Setup with `require('mini.misc').setup({})` (replace `{}` with your
`config` table). It will create global Lua table `MiniMisc` which you can
use for scripting or manually (with `:lua MiniMisc.*`).

See |MiniMisc.config| for `config` structure and default values.

This module doesn't have runtime options, so using `vim.b.minimisc_config`
will have no effect here.

------------------------------------------------------------------------------
                                                              *MiniMisc.setup()*
                           `MiniMisc.setup`({config})
Module setup

Parameters~
{config} `(table)` Module config table. See |MiniMisc.config|.

Usage~
`require('mini.misc').setup({})` (replace `{}` with your `config` table)

------------------------------------------------------------------------------
                                                               *MiniMisc.config*
                               `MiniMisc.config`
Module config

Default values:
>
  MiniMisc.config = {
    -- Array of fields to make global (to be used as independent variables)
    make_global = { 'put', 'put_text' },
  }
<

------------------------------------------------------------------------------
                                                         *MiniMisc.bench_time()*
                     `MiniMisc.bench_time`({f}, {n}, {...})
Execute `f` several times and time how long it took

Parameters~
{f} `(function)` Function which execution to benchmark.
{n} `(number)` Number of times to execute `f(...)`. Default: 1.
{...} `(any)` Arguments when calling `f`.

Return~
`(...)` Table with durations (in seconds; up to microseconds) and
  output of (last) function execution.

------------------------------------------------------------------------------
                                                   *MiniMisc.get_gutter_width()*
                     `MiniMisc.get_gutter_width`({win_id})
Compute width of gutter (info column on the left of the window)

Parameters~
{win_id} `(number)` Window identifier (see |win_getid()|) for which gutter
  width is computed. Default: 0 for current.

------------------------------------------------------------------------------
                                                                *MiniMisc.put()*
                             `MiniMisc.put`({...})
Print Lua objects in command line

Parameters~
{...} `(any)` Any number of objects to be printed each on separate line.

------------------------------------------------------------------------------
                                                           *MiniMisc.put_text()*
                           `MiniMisc.put_text`({...})
Print Lua objects in current buffer

Parameters~
{...} `(any)` Any number of objects to be printed each on separate line.

------------------------------------------------------------------------------
                                                      *MiniMisc.resize_window()*
                `MiniMisc.resize_window`({win_id}, {text_width})
Resize window to have exact number of editable columns

Parameters~
{win_id} `(number)` Window identifier (see |win_getid()|) to be resized.
  Default: 0 for current.
{text_width} `(number)` Number of editable columns resized window will
  display. Default: first element of 'colorcolumn' or otherwise 'textwidth'
  (using screen width as its default but not more than 79).

------------------------------------------------------------------------------
                                                       *MiniMisc.stat_summary()*
                          `MiniMisc.stat_summary`({t})
Compute summary statistics of numerical array

This might be useful to compute summary of time benchmarking with
|MiniMisc.bench_time|.

Parameters~
{t} `(table)` Array (table suitable for `ipairs`) of numbers.

Return~
`(table)` Table with summary values under following keys (may be
  extended in the future): <maximum>, <mean>, <median>, <minimum>, <n>
  (number of elements), <sd> (sample standard deviation).

------------------------------------------------------------------------------
                                                           *MiniMisc.tbl_head()*
                         `MiniMisc.tbl_head`({t}, {n})
Return "first" elements of table as decided by `pairs`

Note: order of elements might vary.

Parameters~
{t} `(table)` Input table.
{n} `(number)` Maximum number of first elements. Default: 5.

Return~
`(table)` Table with at most `n` first elements of `t` (with same keys).

------------------------------------------------------------------------------
                                                           *MiniMisc.tbl_tail()*
                         `MiniMisc.tbl_tail`({t}, {n})
Return "last" elements of table as decided by `pairs`

This function makes two passes through elements of `t`:
- First to count number of elements.
- Second to construct result.

Note: order of elements might vary.

Parameters~
{t} `(table)` Input table.
{n} `(number)` Maximum number of last elements. Default: 5.

Return~
`(table)` Table with at most `n` last elements of `t` (with same keys).

------------------------------------------------------------------------------
                                                *MiniMisc.use_nested_comments()*
                    `MiniMisc.use_nested_comments`({buf_id})
Add possibility of nested comment leader

This works by parsing 'commentstring' buffer option, extracting
non-whitespace comment leader (symbols on the left of commented line), and
locally modifying 'comments' option (by prepending `n:<leader>`). Does
nothing if 'commentstring' is empty or has comment symbols both in front
and back (like "/*%s*/").

Nested comment leader added with this function is useful for formatting
nested comments. For example, have in Lua "first-level" comments with '--'
and "second-level" comments with '----'. With nested comment leader second
type can be formatted with `gq` in the same way as first one.

Recommended usage is with |autocmd|:
`autocmd BufEnter * lua pcall(require('mini.misc').use_nested_comments)`

Note: for most filetypes 'commentstring' option is added only when buffer
with this filetype is entered, so using non-current `buf_id` can not lead
to desired effect.

Parameters~
{buf_id} `(number)` Buffer identifier (see |bufnr()|) in which function
  will operate. Default: 0 for current.

------------------------------------------------------------------------------
                                                               *MiniMisc.zoom()*
                      `MiniMisc.zoom`({buf_id}, {config})
Zoom in and out of a buffer, making it full screen in a floating window

This function is useful when working with multiple windows but temporarily
needing to zoom into one to see more of the code from that buffer. Call it
again (without arguments) to zoom out.

Parameters~
{buf_id} `(number)` Buffer identifier (see |bufnr()|) to be zoomed.
  Default: 0 for current.
{config} `(table)` Optional config for window (as for |nvim_open_win()|).


==============================================================================
------------------------------------------------------------------------------
                                                                    *mini.pairs*
                                                                     *MiniPairs*
Minimal and fast autopairs Lua module. It provides functionality to work
with 'paired' characters conditional on cursor's neighborhood (two
characters to its left and right). Its usage should be through making
appropriate mappings using |MiniPairs.map| or in |MiniPairs.setup| (for
global mapping), |MiniPairs.map_buf| (for buffer mapping). Pairs get
automatically registered to be recognized by `<BS>` and `<CR>`.

What it doesn't do:
- It doesn't support multiple characters as "open" and "close" symbols. Use
  snippets for that.
- It doesn't support dependency on filetype. Use |i_CTRL-V| to insert
  single symbol or `autocmd` command or 'after/ftplugin' approach to:
    - `lua MiniPairs.map_buf(0, 'i', <*>, <pair_info>)` : make new mapping
      for '<*>' in current buffer.
    - `lua MiniPairs.unmap_buf(0, 'i', <*>, <pair>)`: unmap key `<*>` while
      unregistering `<pair>` pair in current buffer. Note: this reverts
      mapping done by |MiniPairs.map_buf|. If mapping was done with
      |MiniPairs.map|, unmap for buffer in usual Neovim manner:
      `inoremap <buffer> <*> <*>` (this maps `<*>` key to do the same it
      does by default).
    - Disable module for buffer (see 'Disabling' section).

# Setup~

This module needs a setup with `require('mini.pairs').setup({})`
(replace `{}` with your `config` table). It will create global Lua table
`MiniPairs` which you can use for scripting or manually (with
`:lua MiniPairs.*`).

See |MiniPairs.config| for `config` structure and default values.

This module doesn't have runtime options, so using `vim.b.minipairs_config`
will have no effect here.

# Example mappings~

- Register quotes inside `config` of |MiniPairs.setup|: >
  mappings = {
    ['"'] = { register = { cr = true } },
    ["'"] = { register = { cr = true } },
  }
<
- Insert `<>` pair if `<` is typed at line start, don't register for `<CR>`: >
  lua MiniPairs.map('i', '<', { action = 'open', pair = '<>', neigh_pattern = '\r.', register = { cr = false } })
  lua MiniPairs.map('i', '>', { action = 'close', pair = '<>', register = { cr = false } })
<
- Create symmetrical `$$` pair only in Tex files: >
  au FileType tex lua MiniPairs.map_buf(0, 'i', '$', {action = 'closeopen', pair = '$$'})
<
# Notes~

- Make sure to make proper mapping of `<CR>` in order to support completion
  plugin of your choice:
    - For |MiniCompletion| see 'Helpful key mappings' section.
    - For current implementation of "hrsh7th/nvim-cmp" there is no need to
      make custom mapping. You can use default setup, which will confirm
      completion selection if popup is visible and expand pair otherwise.
- Having mapping in terminal mode can conflict with:
    - Autopairing capabilities of interpretators (`ipython`, `radian`).
    - Vim mode of terminal itself.

# Disabling~

To disable, set `g:minipairs_disable` (globally) or `b:minipairs_disable`
(for a buffer) to `v:true`. Considering high number of different scenarios
and customization intentions, writing exact rules for disabling module's
functionality is left to user. See |mini.nvim-disabling-recipes| for common
recipes.

------------------------------------------------------------------------------
                                                             *MiniPairs.setup()*
                          `MiniPairs.setup`({config})
Module setup

Parameters~
{config} `(table)` Module config table. See |MiniPairs.config|.

Usage~
`require('mini.completion').setup({})` (replace `{}` with your `config` table)

------------------------------------------------------------------------------
                                                              *MiniPairs.config*
                               `MiniPairs.config`
Module config

Default values:
>
  MiniPairs.config = {
    -- In which modes mappings from this `config` should be created
    modes = { insert = true, command = false, terminal = false },

    -- Global mappings. Each right hand side should be a pair information, a
    -- table with at least these fields (see more in |MiniPairs.map|):
    -- - <action> - one of "open", "close", "closeopen".
    -- - <pair> - two character string for pair to be used.
    -- By default pair is not inserted after `\`, quotes are not recognized by
    -- `<CR>`, `'` does not insert pair after a letter.
    -- Only parts of tables can be tweaked (others will use these defaults).
    mappings = {
      ['('] = { action = 'open', pair = '()', neigh_pattern = '[^\\].' },
      ['['] = { action = 'open', pair = '[]', neigh_pattern = '[^\\].' },
      ['{'] = { action = 'open', pair = '{}', neigh_pattern = '[^\\].' },

      [')'] = { action = 'close', pair = '()', neigh_pattern = '[^\\].' },
      [']'] = { action = 'close', pair = '[]', neigh_pattern = '[^\\].' },
      ['}'] = { action = 'close', pair = '{}', neigh_pattern = '[^\\].' },

      ['"'] = { action = 'closeopen', pair = '""', neigh_pattern = '[^\\].', register = { cr = false } },
      ["'"] = { action = 'closeopen', pair = "''", neigh_pattern = '[^%a\\].', register = { cr = false } },
      ['`'] = { action = 'closeopen', pair = '``', neigh_pattern = '[^\\].', register = { cr = false } },
    },
  }
<

------------------------------------------------------------------------------
                                                               *MiniPairs.map()*
              `MiniPairs.map`({mode}, {lhs}, {pair_info}, {opts})
Make global mapping

This is a wrapper for |nvim_set_keymap()| but instead of right hand side of
mapping (as string) it expects table with pair information:
- `action` - one of "open" (for |MiniPairs.open|), "close" (for
  |MiniPairs.close|), or "closeopen" (for |MiniPairs.closeopen|).
- `pair` - two character string to be used as argument for action function.
- `neigh_pattern` - optional 'two character' neighborhood pattern to be
  used as argument for action function. Default: '..' (no restriction from
  neighborhood).
- `register` - optional table with information about whether this pair
  should be recognized by `<BS>` (in |MiniPairs.bs|) and/or `<CR>` (in
  |MiniPairs.cr|). Should have boolean elements `bs` and `cr` which are
  both `true` by default (if not overriden explicitly).

Using this function instead of |nvim_set_keymap()| allows automatic
registration of pairs which will be recognized by `<BS>` and `<CR>`.
For Neovim>=0.7 it also infers mapping description from `pair_info`.

Parameters~
{mode} `(string)` `mode` for |nvim_set_keymap()|.
{lhs} `(string)` `lhs` for |nvim_set_keymap()|.
{pair_info} `(table)` Table with pair information.
{opts} `(table)` Optional table `opts` for |nvim_set_keymap()|. Elements
  `expr` and `noremap` won't be recognized (`true` by default).

------------------------------------------------------------------------------
                                                           *MiniPairs.map_buf()*
       `MiniPairs.map_buf`({buffer}, {mode}, {lhs}, {pair_info}, {opts})
Make buffer mapping

This is a wrapper for |nvim_buf_set_keymap()| but instead of string right
hand side of mapping it expects table with pair information similar to one
in |MiniPairs.map|.

Using this function instead of |nvim_buf_set_keymap()| allows automatic
registration of pairs which will be recognized by `<BS>` and `<CR>`.
For Neovim>=0.7 it also infers mapping description from `pair_info`.

Parameters~
{buffer} `(number)` `buffer` for |nvim_buf_set_keymap()|.
{mode} `(string)` `mode` for |nvim_buf_set_keymap()|.
{lhs} `(string)` `lhs` for |nvim_buf_set_keymap()|.
{pair_info} `(table)` Table with pair information.
{opts} `(table)` Optional table `opts` for |nvim_buf_set_keymap()|.
  Elements `expr` and `noremap` won't be recognized (`true` by default).

------------------------------------------------------------------------------
                                                             *MiniPairs.unmap()*
                    `MiniPairs.unmap`({mode}, {lhs}, {pair})
Remove global mapping

A wrapper for |nvim_del_keymap()| which registers supplied `pair`.

Parameters~
{mode} `(string)` `mode` for |nvim_del_keymap()|.
{lhs} `(string)` `lhs` for |nvim_del_keymap()|.
{pair} `(string)` Pair which should be unregistered from both
  `<BS>` and `<CR>`. Should be explicitly supplied to avoid confusion.
  Supply `''` to not unregister pair.

------------------------------------------------------------------------------
                                                         *MiniPairs.unmap_buf()*
             `MiniPairs.unmap_buf`({buffer}, {mode}, {lhs}, {pair})
Remove buffer mapping

Wrapper for |nvim_buf_del_keymap()| which also unregisters supplied `pair`.

Note: this only reverts mapping done by |MiniPairs.map_buf|. If mapping was
done with |MiniPairs.map|, unmap for buffer in usual Neovim manner:
`inoremap <buffer> <*> <*>` (this maps `<*>` key to do the same it does by
default).

Parameters~
{buffer} `(number)` `buffer` for |nvim_buf_del_keymap()|.
{mode} `(string)` `mode` for |nvim_buf_del_keymap()|.
{lhs} `(string)` `lhs` for |nvim_buf_del_keymap()|.
{pair} `(string)` Pair which should be unregistered from both
  `<BS>` and `<CR>`. Should be explicitly supplied to avoid confusion.
  Supply `''` to not unregister pair.

------------------------------------------------------------------------------
                                                              *MiniPairs.open()*
                   `MiniPairs.open`({pair}, {neigh_pattern})
Process "open" symbols

Used as |map-expr| mapping for "open" symbols in asymmetric pair ('(', '[',
etc.). If neighborhood doesn't match supplied pattern, function results
into "open" symbol. Otherwise, it pastes whole pair and moves inside pair
with |<Left>|.

Used inside |MiniPairs.map| and |MiniPairs.map_buf| for an actual mapping.

Parameters~
{pair} `(string)` String with two characters representing pair.
{neigh_pattern} `(string)` Pattern for two neighborhood characters ("\r" line
  start, "\n" - line end).

------------------------------------------------------------------------------
                                                             *MiniPairs.close()*
                   `MiniPairs.close`({pair}, {neigh_pattern})
Process "close" symbols

Used as |map-expr| mapping for "close" symbols in asymmetric pair (')',
']', etc.). If neighborhood doesn't match supplied pattern, function
results into "close" symbol. Otherwise it jumps over symbol to the right of
cursor (with |<Right>|) if it is equal to "close" one and inserts it
otherwise.

Used inside |MiniPairs.map| and |MiniPairs.map_buf| for an actual mapping.

Parameters~
{pair} `(string)` String with two characters representing pair.
{neigh_pattern} `(string)` Pattern for two neighborhood characters ("\r" line
  start, "\n" - line end).

------------------------------------------------------------------------------
                                                         *MiniPairs.closeopen()*
                 `MiniPairs.closeopen`({pair}, {neigh_pattern})
Process "closeopen" symbols

Used as |map-expr| mapping for 'symmetrical' symbols (from pairs '""',
'\'\'', '``').  It tries to perform 'closeopen action': move over right
character (with |<Right>|) if it is equal to second character from pair or
conditionally paste pair otherwise (with |MiniPairs.open()|).

Used inside |MiniPairs.map| and |MiniPairs.map_buf| for an actual mapping.

Parameters~
{pair} `(string)` String with two characters representing pair.
{neigh_pattern} `(string)` Pattern for two neighborhood characters ("\r" line
  start, "\n" - line end).

------------------------------------------------------------------------------
                                                                *MiniPairs.bs()*
                                `MiniPairs.bs`()
Process |<BS>|

Used as |map-expr| mapping for `<BS>`. It removes whole pair (via
`<BS><Del>`) if neighborhood is equal to a whole pair recognized for
current buffer. Pair is recognized for current buffer if it is registered
for global or current buffer mapping. Pair is registered as a result of
calling |MiniPairs.map| or |MiniPairs.map_buf|.

Mapped by default inside |MiniPairs.setup|.

------------------------------------------------------------------------------
                                                                *MiniPairs.cr()*
                                `MiniPairs.cr`()
Process |i_<CR>|

Used as |map-expr| mapping for `<CR>` in insert mode. It puts "close"
symbol on next line (via `<CR><C-o>O`) if neighborhood is equal to a whole
pair recognized for current buffer. Pair is recognized for current buffer
if it is registered for global or current buffer mapping. Pair is
registered as a result of calling |MiniPairs.map| or |MiniPairs.map_buf|.

Mapped by default inside |MiniPairs.setup|.


==============================================================================
------------------------------------------------------------------------------
                                                                 *mini.sessions*
                                                                  *MiniSessions*
Lua module for minimal session management (read, write, delete), which
works using |mksession| (meaning 'sessionoptions' is fully respected).
This is intended as a drop-in Lua replacement for session management part
of [mhinz/vim-startify](https://github.com/mhinz/vim-startify) (works out
of the box with sessions created by it). Implements both global (from
configured directory) and local (from current directory) sessions.

Key design ideas:
- Sessions are represented by readable files (results of applying
  |mksession|). There are two kinds of sessions:
    - Global: any file inside a configurable directory.
    - Local: configurable file inside current working directory (|getcwd|).
- All session files are detected during `MiniSessions.setup()` with session
  names being file names (including their possible extension).
- Store information about detected sessions in separate table
  (|MiniSessions.detected|) and operate only on it. Meaning if this
  information changes, there will be no effect until next detection. So to
  avoid confusion, don't directly use |mksession| and |source| for writing
  and reading sessions files.

Features:
- Autoread default session (local if detected, latest otherwise) if Neovim
  was called without intention to show something else.
- Autowrite current session before quitting Neovim.
- Configurable severity level of all actions.

# Setup~

This module needs a setup with `require('mini.sessions').setup({})`
(replace `{}` with your `config` table). It will create global Lua table
`MiniSessions` which you can use for scripting or manually (with
`:lua MiniSessions.*`).

See |MiniSessions.config| for `config` structure and default values.

This module doesn't benefit from buffer local configuration, so using
`vim.b.minimisc_config` will have no effect here.

# Disabling~

To disable core functionality, set `g:minisessions_disable` (globally) or
`b:minisessions_disable` (for a buffer) to `v:true`. Considering high
number of different scenarios and customization intentions, writing exact
rules for disabling module's functionality is left to user. See
|mini.nvim-disabling-recipes| for common recipes.

------------------------------------------------------------------------------
                                                          *MiniSessions.setup()*
                         `MiniSessions.setup`({config})
Module setup

Parameters~
{config} `(table)` Module config table. See |MiniSessions.config|.

Usage~
`require('mini.sessions').setup({})` (replace `{}` with your `config` table)

------------------------------------------------------------------------------
                                                           *MiniSessions.config*
                             `MiniSessions.config`
Module config

Default values:
>
  MiniSessions.config = {
    -- Whether to read latest session if Neovim opened without file arguments
    autoread = false,

    -- Whether to write current session before quitting Neovim
    autowrite = true,

    -- Directory where global sessions are stored (use `''` to disable)
    directory = --<"session" subdir of user data directory from |stdpath()|>,

    -- File for local session (use `''` to disable)
    file = 'Session.vim',

    -- Whether to force possibly harmful actions (meaning depends on function)
    force = { read = false, write = true, delete = false },

    -- Hook functions for actions. Default `nil` means 'do nothing'.
    -- Takes table with active session data as argument.
    hooks = {
      -- Before successful action
      pre = { read = nil, write = nil, delete = nil },
      -- After successful action
      post = { read = nil, write = nil, delete = nil },
    },

    -- Whether to print session path after action
    verbose = { read = false, write = true, delete = true },
  }
<

------------------------------------------------------------------------------
                                                         *MiniSessions.detected*
                            `MiniSessions.detected`
Table of detected sessions. Keys represent session name. Values are tables
with session information that currently has these fields (but subject to
change):
- <modify_time> `(number)` modification time (see |getftime|) of session file.
- <name> `(string)` name of session (should be equal to table key).
- <path> `(string)` full path to session file.
- <type> `(string)` type of session ('global' or 'local').

------------------------------------------------------------------------------
                                                           *MiniSessions.read()*
                  `MiniSessions.read`({session_name}, {opts})
Read detected session

What it does:
- Delete all current buffers with |bwipeout|. This is needed to correctly
  restore buffers from target session. If `force` is not `true`, checks
  beforehand for unsaved listed buffers and stops if there is any.
- Source session with supplied name.

Parameters~
{session_name} `(string)` Name of detected session file to read. Default:
  `nil` for default session: local (if detected) or latest session (see
  |MiniSessions.get_latest|).
{opts} `(table)` Table with options. Current allowed keys:
  - <force> (whether to delete unsaved buffers; default:
    `MiniSessions.config.force.read`).
  - <verbose> (whether to print session path after action; default
    `MiniSessions.config.verbose.read`).
  - <hooks> (a table with <pre> and <post> function hooks to be executed
    with session data argument before and after successful read; overrides
    `MiniSessions.config.hooks.pre.read` and
    `MiniSessions.config.hooks.post.read`).

------------------------------------------------------------------------------
                                                          *MiniSessions.write()*
                  `MiniSessions.write`({session_name}, {opts})
Write session

What it does:
- Check if file for supplied session name already exists. If it does and
  `force` is not `true`, then stop.
- Write session with |mksession| to a file named `session_name`. Its
  directory is determined based on type of session:
    - It is at location |v:this_session| if `session_name` is `nil` and
      there is current session.
    - It is current working directory (|getcwd|) if `session_name` is equal
      to `MiniSessions.config.file` (represents local session).
    - It is `MiniSessions.config.directory` otherwise (represents global
      session).
- Update |MiniSessions.detected|.

Parameters~
{session_name} `(string)` Name of session file to write. Default: `nil` for
  current session (|v:this_session|).
{opts} `(table)` Table with options. Current allowed keys:
  - <force> (whether to ignore existence of session file; default:
    `MiniSessions.config.force.write`).
  - <verbose> (whether to print session path after action; default
    `MiniSessions.config.verbose.write`).
  - <hooks> (a table with <pre> and <post> function hooks to be executed
    with session data argument before and after successful write; overrides
    `MiniSessions.config.hooks.pre.write` and
    `MiniSessions.config.hooks.post.write`).

------------------------------------------------------------------------------
                                                         *MiniSessions.delete()*
                 `MiniSessions.delete`({session_name}, {opts})
Delete detected session

What it does:
- Check if session name is a current one. If yes and `force` is not `true`,
  then stop.
- Delete session.
- Update |MiniSessions.detected|.

Parameters~
{session_name} `(string)` Name of detected session file to delete. Default:
  `nil` for name of current session (taken from |v:this_session|).
{opts} `(table)` Table with options. Current allowed keys:
  - <force> (whether to allow deletion of current session; default:
    `MiniSessions.config.force.delete`).
  - <verbose> (whether to print session path after action; default
    `MiniSessions.config.verbose.delete`).
  - <hooks> (a table with <pre> and <post> function hooks to be executed
    with session data argument before and after successful delete; overrides
    `MiniSessions.config.hooks.pre.delete` and
    `MiniSessions.config.hooks.post.delete`).

------------------------------------------------------------------------------
                                                         *MiniSessions.select()*
                    `MiniSessions.select`({action}, {opts})
Select session interactively and perform action

Note: this uses |vim.ui.select| function, which is present in Neovim
starting from 0.6 version. For more user-friendly experience, override it
(for example, with external plugins like "stevearc/dressing.nvim").

Parameters~
{action} `(string)` Action to perform. Should be one of "read" (default),
  "write", or "delete".
{opts} `(table)` Options for specified action.

------------------------------------------------------------------------------
                                                     *MiniSessions.get_latest()*
                          `MiniSessions.get_latest`()
Get name of latest detected session

Latest session is the session with the latest modification time determined
by |getftime|.

Return~
`(string|nil)` Name of latest session or `nil` if there is no sessions.

------------------------------------------------------------------------------
                                                    *MiniSessions.on_vimenter()*
                          `MiniSessions.on_vimenter`()
Act on |VimEnter|


==============================================================================
------------------------------------------------------------------------------
                                                                  *mini.starter*
                                                                   *MiniStarter*
Lua module for minimal, fast, and flexible start screen. Displayed items
are fully customizable both in terms of what they do and how they look
(with reasonable defaults). Item selection can be done using prefix query
with instant visual feedback. This is mostly inspired by
[mhinz/vim-startify](https://github.com/mhinz/vim-startify).

Key design ideas:
- All available actions are defined inside items. Each item should have the
  following info:
    - <action> - function or string for |vim.cmd| which is executed when
      item is chosen. Empty string result in placeholder "inactive" item.
    - <name> - string which will be displayed and used for choosing.
    - <section> - string representing to which section item belongs.
  There are pre-configured whole sections in |MiniStarter.sections|.
- Configure what items are displayed by supplying an array which can be
  normalized to an array of items. Read about how supplied items are
  normalized in |MiniStarter.refresh|.
- Modify the final look by supplying content hooks: functions which take
  buffer content as input (see |MiniStarter.get_content()| for more
  information) and return buffer content as output. There are
  pre-configured content hook generators in |MiniStarter.gen_hook|.
- Choosing an item can be done in two ways:
    - Type prefix query to filter item by matching its name (ignoring
      case). Displayed information is updated after every typed character.
      For every item its unique prefix is highlighted.
    - Use Up/Down arrows and hit Enter.
- Allow multiple simultaneously open Starter buffers.

What is doesn't do:
- It doesn't support fuzzy query for items. And probably will never do.

# Setup~

This module needs a setup with `require('mini.starter').setup({})`
(replace `{}` with your `config` table). It will create global Lua table
`MiniStarter` which you can use for scripting or manually (with
`:lua MiniStarter.*`).

See |MiniStarter.config| for `config` structure and default values. For
some configuration examples (including one similar to 'vim-startify' and
'dashboard-nvim'), see |MiniStarter-example-config|.

You can override runtime config settings locally to buffer inside
`vim.b.ministarter_config` which should have same structure as
`MiniStarter.config`. See |mini.nvim-buffer-local-config| for more details.
Note: `vim.b.ministarter_config` is copied to Starter buffer from current
buffer allowing full customization.

# Highlight groups~

* `MiniStarterCurrent` - current item.
* `MiniStarterFooter` - footer units.
* `MiniStarterHeader` - header units.
* `MiniStarterInactive` - inactive item.
* `MiniStarterItem` - item name.
* `MiniStarterItemBullet` - units from |MiniStarter.gen_hook.adding_bullet|.
* `MiniStarterItemPrefix` - unique query for item.
* `MiniStarterSection` - section units.
* `MiniStarterQuery` - current query in active items.

To change any highlight group, modify it directly with |:highlight|.

# Disabling~

To disable core functionality, set `g:ministarter_disable` (globally) or
`b:ministarter_disable` (for a buffer) to `v:true`. Considering high number
of different scenarios and customization intentions, writing exact rules
for disabling module's functionality is left to user. See
|mini.nvim-disabling-recipes| for common recipes.

------------------------------------------------------------------------------
                                                    *MiniStarter-example-config*
Example configurations

Configuration similar to 'mhinz/vim-startify':
>
  local starter = require('mini.starter')
  starter.setup({
    evaluate_single = true,
    items = {
      starter.sections.builtin_actions(),
      starter.sections.recent_files(10, false),
      starter.sections.recent_files(10, true),
      -- Use this if you set up 'mini.sessions'
      starter.sections.sessions(5, true)
    },
    content_hooks = {
      starter.gen_hook.adding_bullet(),
      starter.gen_hook.indexing('all', { 'Builtin actions' }),
      starter.gen_hook.padding(3, 2),
    },
  })
<
Configuration similar to 'glepnir/dashboard-nvim':
>
  local starter = require('mini.starter')
  starter.setup({
    items = {
      starter.sections.telescope(),
    },
    content_hooks = {
      starter.gen_hook.adding_bullet(),
      starter.gen_hook.aligning('center', 'center'),
    },
  })
<
Elaborated configuration showing capabilities of custom items,
header/footer, and content hooks:
>
  local my_items = {
    { name = 'Echo random number', action = 'lua print(math.random())', section = 'Section 1' },
    function()
      return {
        { name = 'Item #1 from function', action = [[echo 'Item #1']], section = 'From function' },
        { name = 'Placeholder (always incative) item', action = '', section = 'From function' },
        function()
          return {
            name = 'Item #1 from double function',
            action = [[echo 'Double function']],
            section = 'From double function',
          }
        end,
      }
    end,
    { name = [[Another item in 'Section 1']], action = 'lua print(math.random() + 10)', section = 'Section 1' },
  }

  local footer_n_seconds = (function()
    local timer = vim.loop.new_timer()
    local n_seconds = 0
    timer:start(0, 1000, vim.schedule_wrap(function()
      if vim.api.nvim_buf_get_option(0, 'filetype') ~= 'starter' then
        timer:stop()
        return
      end
      n_seconds = n_seconds + 1
      MiniStarter.refresh()
    end))

    return function()
      return 'Number of seconds since opening: ' .. n_seconds
    end
  end)()

  local hook_top_pad_10 = function(content)
    -- Pad from top
    for _ = 1, 10 do
      -- Insert at start a line with single content unit
      table.insert(content, 1, { { type = 'empty', string = '' } })
    end
    return content
  end

  local starter = require('mini.starter')
  starter.setup({
    items = my_items,
    footer = footer_n_seconds,
    content_hooks = { hook_top_pad_10 },
  })
<

------------------------------------------------------------------------------
                                                         *MiniStarter-lifecycle*
# Lifecycle of Starter buffer~

- Open with |MiniStarter.open()|. It includes creating buffer with
  appropriate options, mappings, behavior; call to |MiniStarter.refresh()|;
  issue `MiniStarterOpened` |User| event.
- Wait for user to choose an item. This is done using following logic:
    - Typing any character from `MiniStarter.config.query_updaters` leads
      to updating query. Read more in |MiniStarter.add_to_query|.
    - <BS> deletes latest character from query.
    - <Down>/<Up>, <C-n>/<C-p>, <M-j>/<M-k> move current item.
    - <CR> executes action of current item.
    - <C-c> closes Starter buffer.
- Evaluate current item when appropriate (after `<CR>` or when there is a
  single item and `MiniStarter.config.evaluate_single` is `true`). This
  executes item's `action`.

------------------------------------------------------------------------------
                                                           *MiniStarter.setup()*
                         `MiniStarter.setup`({config})
Module setup

Parameters~
{config} `(table)` Module config table. See |MiniStarter.config|.

Usage~
`require('mini.starter').setup({})` (replace `{}` with your `config` table)

------------------------------------------------------------------------------
                                                            *MiniStarter.config*
                              `MiniStarter.config`
Module config

Default values:
>
  MiniStarter.config = {
    -- Whether to open starter buffer on VimEnter. Not opened if Neovim was
    -- started with intent to show something else.
    autoopen = true,

    -- Whether to evaluate action of single active item
    evaluate_single = false,

    -- Items to be displayed. Should be an array with the following elements:
    -- - Item: table with <action>, <name>, and <section> keys.
    -- - Function: should return one of these three categories.
    -- - Array: elements of these three types (i.e. item, array, function).
    -- If `nil` (default), default items will be used (see |mini.starter|).
    items = nil,

    -- Header to be displayed before items. Converted to single string via
    -- `tostring` (use `\n` to display several lines). If function, it is
    -- evaluated first. If `nil` (default), polite greeting will be used.
    header = nil,

    -- Footer to be displayed after items. Converted to single string via
    -- `tostring` (use `\n` to display several lines). If function, it is
    -- evaluated first. If `nil` (default), default usage help will be shown.
    footer = nil,

    -- Array  of functions to be applied consecutively to initial content.
    -- Each function should take and return content for 'Starter' buffer (see
    -- |mini.starter| and |MiniStarter.get_content()| for more details).
    content_hooks = nil,

    -- Characters to update query. Each character will have special buffer
    -- mapping overriding your global ones. Be careful to not add `:` as it
    -- allows you to go into command mode.
    query_updaters = 'abcdefghijklmnopqrstuvwxyz0123456789_-.',
  }
<

------------------------------------------------------------------------------
                                                     *MiniStarter.on_vimenter()*
                          `MiniStarter.on_vimenter`()
Act on |VimEnter|.

------------------------------------------------------------------------------
                                                            *MiniStarter.open()*
                          `MiniStarter.open`({buf_id})
Open Starter buffer

- Create buffer if necessary and move into it.
- Set buffer options. Note that settings are done with |noautocmd| to
  achieve a massive speedup.
- Set buffer mappings. Besides basic mappings (described inside "Lifecycle
  of Starter buffer" of |mini.starter|), map every character from
  `MiniStarter.config.query_updaters` to add itself to query with
  |MiniStarter.add_to_query|.
- Populate buffer with |MiniStarter.refresh|.
- Issue custom `MiniStarterOpened` event to allow acting upon opening
  Starter buffer. Use it with
  `autocmd User MiniStarterOpened <your command>`.

Note: to fully use it in autocommand, it is recommended to utilize
|autocmd-nested|. Example:
`autocmd TabNewEntered * ++nested lua MiniStarter.open()`

Parameters~
{buf_id} `(number)` Identifier of existing valid buffer (see |bufnr()|) to
  open inside. Default: create a new one.

------------------------------------------------------------------------------
                                                         *MiniStarter.refresh()*
                        `MiniStarter.refresh`({buf_id})
Refresh Starter buffer

- Normalize `MiniStarter.config.items`:
    - Flatten: recursively (in depth-first fashion) parse its elements. If
      function is found, execute it and continue with parsing its output
      (this allows deferring item collection up until it is actually
      needed).  If proper item is found (table with fields `action`,
      `name`, `section`), add it to output.
    - Sort: order first by section and then by item id (both in order of
      appearance).
- Normalize `MiniStarter.config.header` and `MiniStarter.config.footer` to
  be multiple lines by splitting at `\n`. If function - evaluate it first.
- Make initial buffer content (see |MiniStarter.get_content()| for a
  description of what a buffer content is). It consist from content lines
  with single content unit:
    - First lines contain strings of normalized header.
    - Body is for normalized items. Section names have own lines preceded
      by empty line.
    - Last lines contain separate strings of normalized footer.
- Sequentially apply hooks from `MiniStarter.config.content_hooks` to
  content. Output of one hook serves as input to the next.
- Gather final items from content with |MiniStarter.content_to_items|.
- Convert content to buffer lines with |MiniStarter.content_to_lines| and
  add them to buffer.
- Add highlighting of content units.
- Position cursor.
- Make current query. This results into some items being marked as
  "inactive" and updating highlighting of current query on "active" items.

Note: this function is executed on every |VimResized| to allow more
responsive behavior.

Parameters~
{buf_id} `(number|nil)` Buffer identifier of a valid Starter buffer.
  Default: current buffer.

------------------------------------------------------------------------------
                                                           *MiniStarter.close()*
                         `MiniStarter.close`({buf_id})
Close Starter buffer

Parameters~
{buf_id} `(number|nil)` Buffer identifier of a valid Starter buffer.
  Default: current buffer.

------------------------------------------------------------------------------
                                                          *MiniStarter.sections*
                             `MiniStarter.sections`
Table of pre-configured sections

------------------------------------------------------------------------------
                                        *MiniStarter.sections.builtin_actions()*
                    `MiniStarter.sections.builtin_actions`()
Section with builtin actions

Return~
`(table)` Array of items.

------------------------------------------------------------------------------
                                               *MiniStarter.sections.sessions()*
                 `MiniStarter.sections.sessions`({n}, {recent})
Section with |MiniSessions| sessions

Sessions are taken from |MiniSessions.detected|. Notes:
- If it shows "'mini.sessions' is not set up", it means that you didn't
  call `require('mini.sessions').setup()`.
- If it shows "There are no detected sessions in 'mini.sessions'", it means
  that there are no sessions at the current sessions directory. Either
  create session or supply different directory where session files are
  stored (see |MiniSessions.setup|).
- Local session (if detected) is always displayed first.

Parameters~
{n} `(number)` Number of returned items. Default: 5.
{recent} `(boolean)` Whether to use recent sessions (instead of
  alphabetically by name). Default: true.

Return~
`(function)` Function which returns array of items.

------------------------------------------------------------------------------
                                           *MiniStarter.sections.recent_files()*
      `MiniStarter.sections.recent_files`({n}, {current_dir}, {show_path})
Section with most recently used files

Files are taken from |vim.v.oldfiles|.

Parameters~
{n} `(number)` Number of returned items. Default: 5.
{current_dir} `(boolean)` Whether to return files only from current working
  directory. Default: `false`.
{show_path} `(boolean)` Whether to append file name with its full path.
  Default: `true`.

Return~
`(function)` Function which returns array of items.

------------------------------------------------------------------------------
                                              *MiniStarter.sections.telescope()*
                       `MiniStarter.sections.telescope`()
Section with basic Telescope pickers relevant to start screen

Return~
`(function)` Function which returns array of items.

------------------------------------------------------------------------------
                                                          *MiniStarter.gen_hook*
                             `MiniStarter.gen_hook`
Table with pre-configured content hook generators

Each element is a function which returns content hook. So to use them
inside |MiniStarter.setup|, call them.

------------------------------------------------------------------------------
                                                *MiniStarter.gen_hook.padding()*
                 `MiniStarter.gen_hook.padding`({left}, {top})
Hook generator for padding

Output is a content hook which adds constant padding from left and top.
This allows tweaking the screen position of buffer content.

Parameters~
{left} `(number)` Number of empty spaces to add to start of each content
  line. Default: 0.
{top} `(number)` Number of empty lines to add to start of content.
  Default: 0.

Return~
`(function)` Content hook.

------------------------------------------------------------------------------
                                          *MiniStarter.gen_hook.adding_bullet()*
         `MiniStarter.gen_hook.adding_bullet`({bullet}, {place_cursor})
Hook generator for adding bullet to items

Output is a content hook which adds supplied string to be displayed to the
left of item.

Parameters~
{bullet} `(string)` String to be placed to the left of item name.
  Default: " ".
{place_cursor} `(boolean)` Whether to place cursor on the first character
  of bullet when corresponding item becomes current. Default: true.

Return~
`(function)` Content hook.

------------------------------------------------------------------------------
                                               *MiniStarter.gen_hook.indexing()*
        `MiniStarter.gen_hook.indexing`({grouping}, {exclude_sections})
Hook generator for indexing items

Output is a content hook which adds unique index to the start of item's
name. It results into shortening queries required to choose an item (at
expense of clarity).

Parameters~
{grouping} `(string)` One of "all" (number indexing across all sections) or
  "section" (letter-number indexing within each section). Default: "all".
{exclude_sections} `(table)` Array of section names (values of `section`
  element of item) for which index won't be added. Default: `{}`.

Return~
`(function)` Content hook.

------------------------------------------------------------------------------
                                               *MiniStarter.gen_hook.aligning()*
           `MiniStarter.gen_hook.aligning`({horizontal}, {vertical})
Hook generator for aligning content

Output is a content hook which independently aligns content horizontally
and vertically. Basically, this computes left and top pads for
|MiniStarter.gen_hook.padding| such that output lines would appear aligned
in certain way.

Parameters~
{horizontal} `(string)` One of "left", "center", "right". Default: "left".
{vertical} `(string)` One of "top", "center", "bottom". Default: "top".

Return~
`(function)` Content hook.

------------------------------------------------------------------------------
                                                     *MiniStarter.get_content()*
                      `MiniStarter.get_content`({buf_id})
Get content of Starter buffer

Generally, buffer content is a table in the form of "2d array" (or rather
"2d list" because number of elements can differ):
- Each element represents content line: an array with content units to be
  displayed in one buffer line.
- Each content unit is a table with at least the following elements:
    - "type" - string with type of content. Something like "item",
      "section", "header", "footer", "empty", etc.
    - "string" - which string should be displayed. May be an empty string.
    - "hl" - which highlighting should be applied to content string. May be
      `nil` for no highlighting.

See |MiniStarter.content_to_lines| for converting content to buffer lines
and |MiniStarter.content_to_items| - to list of parsed items.

Notes:
- Content units with type "item" also have `item` element with all
  information about an item it represents. Those elements are used directly
  to create an array of items used for query.

Parameters~
{buf_id} `(number|nil)` Buffer identifier of a valid Starter buffer.
  Default: current buffer.

------------------------------------------------------------------------------
                                                  *MiniStarter.content_coords()*
              `MiniStarter.content_coords`({content}, {predicate})
Helper to iterate through content

Basically, this traverses content "2d array" (in depth-first fashion; top
to bottom, left to right) and returns "coordinates" of units for which
`predicate` is true-ish.

Parameters~
{content} `(table)` Content "2d array". Default: content of current buffer.
{predicate} `(function|string|nil)` Predictate to filter units. If it is:
   - Function, then it is evaluated with unit as input.
   - String, then it checks unit to have this type (allows easy getting of
     units with some type).
   - `nil`, all units are kept.

Return~
`(table)` Array of resulting units' coordinates. Each coordinate is a
  table with <line> and <unit> keys. To retrieve actual unit from coordinate
  `c`, use `content[c.line][c.unit]`.

------------------------------------------------------------------------------
                                                *MiniStarter.content_to_lines()*
                   `MiniStarter.content_to_lines`({content})
Convert content to buffer lines

One buffer line is made by concatenating `string` element of units within
same content line.

Parameters~
{content} `(table)` Content "2d array". Default: content of current buffer.

Return~
`(table)` Array of strings for each buffer line.

------------------------------------------------------------------------------
                                                *MiniStarter.content_to_items()*
                   `MiniStarter.content_to_items`({content})
Convert content to items

Parse content (in depth-first fashion) and retrieve each item from `item`
element of content units with type "item". This also:
- Computes some helper information about how item will be actually
  displayed (after |MiniStarter.content_to_lines|) and minimum number of
  prefix characters needed for a particular item to be queried single.
- Modifies item's `name` element taking it from corresponing `string`
  element of content unit. This allows modifying item's `name` at the stage
  of content hooks (like, for example, in |MiniStarter.gen_hook.indexing|).

Parameters~
{content} `(table)` Content "2d array". Default: content of current buffer.

Return~
`(table)` Array of items.

------------------------------------------------------------------------------
                                               *MiniStarter.eval_current_item()*
                   `MiniStarter.eval_current_item`({buf_id})
Evaluate current item

Parameters~
{buf_id} `(number|nil)` Buffer identifier of a valid Starter buffer.
  Default: current buffer.

------------------------------------------------------------------------------
                                             *MiniStarter.update_current_item()*
            `MiniStarter.update_current_item`({direction}, {buf_id})
Update current item

This makes next (with respect to `direction`) active item to be current.

Parameters~
{direction} `(string)` One of "next" or "previous".
{buf_id} `(number|nil)` Buffer identifier of a valid Starter buffer.
  Default: current buffer.

------------------------------------------------------------------------------
                                                    *MiniStarter.add_to_query()*
                  `MiniStarter.add_to_query`({char}, {buf_id})
Add character to current query

- Update current query by appending `char` to its end (only if it results
  into at least one active item) or delete latest character if `char` is `nil`.
- Recompute status of items: "active" if its name starts with new query,
  "inactive" otherwise.
- Update highlighting: whole strings for "inactive" items, current query
  for "active" items.

Parameters~
{char} `(string)` Single character to be added to query. If `nil`, deletes
  latest character from query.
{buf_id} `(number|nil)` Buffer identifier of a valid Starter buffer.
  Default: current buffer.

------------------------------------------------------------------------------
                                                       *MiniStarter.set_query()*
                   `MiniStarter.set_query`({query}, {buf_id})
Set current query

Parameters~
{query} `(string|nil)` Query to be set (only if it results into at least one
  active item). Default: `nil` for setting query to empty string, which
  essentially resets query.
{buf_id} `(number|nil)` Buffer identifier of a valid Starter buffer.
  Default: current buffer.

------------------------------------------------------------------------------
                                                  *MiniStarter.on_cursormoved()*
                     `MiniStarter.on_cursormoved`({buf_id})
Act on |CursorMoved| by repositioning cursor in fixed place.


==============================================================================
------------------------------------------------------------------------------
                                                               *mini.statusline*
                                                                *MiniStatusline*
Minimal and fast statusline module with opinionated default look.
Special features: change color depending on current mode and compact
version of sections activated when window width is small enough.

Features:
- Built-in active mode indicator with colors.
- Sections can hide information when window is too narrow (specific window
  width is configurable per section).
- Define own custom statusline structure for active and inactive windows.
  This is done with a function which should return string appropriate for
  |statusline|. Its code should be similar to default one with structure:
    - Compute string data for every section you want to be displayed.
    - Combine them in groups with |MiniStatusline.combine_groups()|.

# Dependencies~

Suggested dependencies (provide extra functionality, statusline will work
without them):
- Nerd font (to support extra icons).
- Plugin 'lewis6991/gitsigns.nvim' for Git information in
  |MiniStatusline.section_git|. If missing, no section will be shown.
- Plugin 'kyazdani42/nvim-web-devicons' for filetype icons in
  `MiniStatusline.section_fileinfo`. If missing, no icons will be shown.

# Setup~

This module needs a setup with `require('mini.statusline').setup({})`
(replace `{}` with your `config` table). It will create global Lua table
`MiniStatusline` which you can use for scripting or manually (with
`:lua MiniStatusline.*`).

See |MiniStatusline.config| for `config` structure and default values. For
some content examples, see |MiniStatusline-example-content|.

You can override runtime config settings locally to buffer inside
`vim.b.ministatusline_config` which should have same structure as
`MiniStatusline.config`. See |mini.nvim-buffer-local-config| for more details.

# Highlight groups~

Highlight depending on mode (second output from |MiniStatusline.section_mode|):
* `MiniStatuslineModeNormal` - Normal mode.
* `MiniStatuslineModeInsert` - Insert mode.
* `MiniStatuslineModeVisual` - Visual mode.
* `MiniStatuslineModeReplace` - Replace mode.
* `MiniStatuslineModeCommand` - Command mode.
* `MiniStatuslineModeOther` - other modes (like Terminal, etc.).

Highlight used in default statusline:
* `MiniStatuslineDevinfo` - for "dev info" group
  (|MiniStatusline.section_git| and |MiniStatusline.section_diagnostics|).
* `MiniStatuslineFilename` - for |MiniStatusline.section_filename| section.
* `MiniStatuslineFileinfo` - for |MiniStatusline.section_fileinfo| section.

Other groups:
* `MiniStatuslineInactive` - highliting in not focused window.

To change any highlight group, modify it directly with |:highlight|.

# Disabling~

To disable (show empty statusline), set `g:ministatusline_disable`
(globally) or `b:ministatusline_disable` (for a buffer) to `v:true`.
Considering high number of different scenarios and customization
intentions, writing exact rules for disabling module's functionality is
left to user. See |mini.nvim-disabling-recipes| for common recipes.

------------------------------------------------------------------------------
                                                *MiniStatusline-example-content*
Example content

# Default content~

This function is used as default value for active content:
>
  function()
    local mode, mode_hl = MiniStatusline.section_mode({ trunc_width = 120 })
    local git           = MiniStatusline.section_git({ trunc_width = 75 })
    local diagnostics   = MiniStatusline.section_diagnostics({ trunc_width = 75 })
    local filename      = MiniStatusline.section_filename({ trunc_width = 140 })
    local fileinfo      = MiniStatusline.section_fileinfo({ trunc_width = 120 })
    local location      = MiniStatusline.section_location({ trunc_width = 75 })

    return MiniStatusline.combine_groups({
      { hl = mode_hl,                  strings = { mode } },
      { hl = 'MiniStatuslineDevinfo',  strings = { git, diagnostics } },
      '%<', -- Mark general truncate point
      { hl = 'MiniStatuslineFilename', strings = { filename } },
      '%=', -- End left alignment
      { hl = 'MiniStatuslineFileinfo', strings = { fileinfo } },
      { hl = mode_hl,                  strings = { location } },
    })
  end
<
# Show boolean options~

To compute section string for boolean option use variation of this code
snippet inside content function (you can modify option itself, truncation
width, short and long displayed names):
>
  local spell = vim.wo.spell and (MiniStatusline.is_truncated(120) and 'S' or 'SPELL') or ''
<
Here `x and y or z` is a common Lua way of doing ternary operator: if `x`
is `true`-ish then return `y`, if not - return `z`.

------------------------------------------------------------------------------
                                                        *MiniStatusline.setup()*
                        `MiniStatusline.setup`({config})
Module setup

Parameters~
{config} `(table)` Module config table. See |MiniStatusline.config|.

Usage~
`require('mini.statusline').setup({})` (replace `{}` with your `config` table)

------------------------------------------------------------------------------
                                                         *MiniStatusline.config*
                            `MiniStatusline.config`
Module config

Default values:
>
  MiniStatusline.config = {
    -- Content of statusline as functions which return statusline string. See
    -- `:h statusline` and code of default contents (used instead of `nil`).
    content = {
      -- Content for active window
      active = nil,
      -- Content for inactive window(s)
      inactive = nil,
    },

    -- Whether to use icons by default
    use_icons = true,

    -- Whether to set Vim's settings for statusline (make it always shown with
    -- 'laststatus' set to 2). To use global statusline in Neovim>=0.7.0, set
    -- this to `false` and 'laststatus' to 3.
    set_vim_settings = true,
  }
<

------------------------------------------------------------------------------
                                                       *MiniStatusline.active()*
                           `MiniStatusline.active`()
Compute content for active window

------------------------------------------------------------------------------
                                                     *MiniStatusline.inactive()*
                          `MiniStatusline.inactive`()
Compute content for inactive window

------------------------------------------------------------------------------
                                               *MiniStatusline.combine_groups()*
                   `MiniStatusline.combine_groups`({groups})
Combine groups of sections

Each group can be either a string or a table with fields `hl` (group's
highlight group) and `strings` (strings representing sections).

General idea of this function is as follows;
- String group is used as is (useful for special strings like `%<` or `%=`).
- Each table group has own highlighting in `hl` field (if missing, the
  previous one is used) and string parts in `strings` field. Non-empty
  strings from `strings` are separated by one space. Non-empty groups are
  separated by two spaces (one for each highlighting).

Parameters~
{groups} `(string|table)` Array of groups.

Return~
`(string)` String suitable for 'statusline'.

------------------------------------------------------------------------------
                                                 *MiniStatusline.is_truncated()*
                  `MiniStatusline.is_truncated`({trunc_width})
Decide whether to truncate

This basically computes window width and compares it to `trunc_width`: if
window is smaller then truncate; otherwise don't. Don't truncate by
default.

Use this to manually decide if section needs truncation or not.

Parameters~
{trunc_width} `(number)` Truncation width. If `nil`, output is `false`.

Return~
`(boolean)` Whether to truncate.

------------------------------------------------------------------------------
                                                 *MiniStatusline.section_mode()*
                     `MiniStatusline.section_mode`({args})
Section for Vim |mode()|

Short output is returned if window width is lower than `args.trunc_width`.

Parameters~
{args} `(table)` Section arguments.

Return~
`(...)` Section string and mode's highlight group.

------------------------------------------------------------------------------
                                                  *MiniStatusline.section_git()*
                      `MiniStatusline.section_git`({args})
Section for Git information

Normal output contains name of `HEAD` (via |b:gitsigns_head|) and chunk
information (via |b:gitsigns_status|). Short output - only name of `HEAD`.
Note: requires 'lewis6991/gitsigns' plugin.

Short output is returned if window width is lower than `args.trunc_width`.

Parameters~
{args} `(table)` Section arguments. Use `args.icon` to supply your own icon.

Return~
`(string)` Section string.

------------------------------------------------------------------------------
                                          *MiniStatusline.section_diagnostics()*
                  `MiniStatusline.section_diagnostics`({args})
Section for Neovim's builtin diagnostics

Shows nothing if there is no attached LSP clients or for short output.
Otherwise uses builtin Neovim capabilities to compute and show number of
errors ('E'), warnings ('W'), information ('I'), and hints ('H').

Short output is returned if window width is lower than `args.trunc_width`.

Parameters~
{args} `(table)` Section arguments. Use `args.icon` to supply your own icon.

Return~
`(string)` Section string.

------------------------------------------------------------------------------
                                             *MiniStatusline.section_filename()*
                   `MiniStatusline.section_filename`({args})
Section for file name

Show full file name or relative in short output.

Short output is returned if window width is lower than `args.trunc_width`.

Parameters~
{args} `(table)` Section arguments.

Return~
`(string)` Section string.

------------------------------------------------------------------------------
                                             *MiniStatusline.section_fileinfo()*
                   `MiniStatusline.section_fileinfo`({args})
Section for file information

Short output contains only extension and is returned if window width is
lower than `args.trunc_width`.

Parameters~
{args} `(table)` Section arguments.

Return~
`(string)` Section string.

------------------------------------------------------------------------------
                                             *MiniStatusline.section_location()*
                   `MiniStatusline.section_location`({args})
Section for location inside buffer

Show location inside buffer in the form:
- Normal: '<cursor line>|<total lines><cursor column>|<total columns>'.
- Short: '<cursor line><cursor column>'.

Short output is returned if window width is lower than `args.trunc_width`.

Parameters~
{args} `(table)` Section arguments.

Return~
`(string)` Section string.

------------------------------------------------------------------------------
                                          *MiniStatusline.section_searchcount()*
                  `MiniStatusline.section_searchcount`({args})
Section for current search count

Show the current status of |searchcount()|. Empty output is returned if
window width is lower than `args.trunc_width`, search highlighting is not
on (see |v:hlsearch|), or if number of search result is 0.

`args.options` is forwarded to |searchcount()|.  By default it recomputes
data on every call which can be computationally expensive (although still
usually same order of magnitude as 0.1 ms). To prevent this, supply
`args.options = {recompute = false}`.

Parameters~
{args} `(table)` Section arguments.

Return~
`(string)` Section string.


==============================================================================
------------------------------------------------------------------------------
                                                                 *mini.surround*
                                                                  *MiniSurround*
Custom somewhat minimal and fast surrounding Lua plugin. This is mostly
a reimplementation of the core features of 'machakann/vim-sandwich' with a
couple more on top (find surrounding, highlight surrounding). Can be
configured to have experience similar to 'tpope/vim-surround'.

Features:
- Actions (all of them are dot-repeatable out of the box):
    - Add surrounding with `sa` (in visual mode or on motion).
    - Delete surrounding with `sd`.
    - Replace surrounding with `sr`.
    - Find surrounding with `sf` or `sF` (move cursor right or left).
    - Highlight surrounding with `sh`.
    - Change number of neighbor lines with `sn` (see |MiniSurround-algorithm|).
- Surrounding is identified by a single character as both "input" (in
  `delete` and `replace` start, `find`, and `highlight`) and "output" (in
  `add` and `replace` end):
    - 'f' - function call (string of alphanumeric symbols or '_' or '.'
      followed by balanced '()'). In "input" finds function call, in
      "output" prompts user to enter function name.
    - 'i' - interactive. Prompts user to enter left and right parts.
    - 't' - tag. In "input" finds tab with same identifier, in "output"
      prompts user to enter tag name.
    - All symbols in brackets '()', '[]', '{}', '<>". In "input' represents
      balanced brackets, in "output" - left and right parts of brackets.
    - All other alphanumeric, punctuation, or space characters represent
      surrounding with identical left and right parts.

Known issues which won't be resolved:
- Search for surrounding is done using Lua patterns (regex-like approach).
  So certain amount of false positives should be expected.
- When searching for "input" surrounding, there is no distinction if it is
  inside string or comment. So in this case there will be not proper match
  for a function call: 'f(a = ")", b = 1)'.
- Tags are searched using regex-like methods, so issues are inevitable.
  Overall it is pretty good, but certain cases won't work. Like self-nested
  tags won't match correctly on both ends: '<a><a></a></a>'.

# Setup~

This module needs a setup with `require('mini.surround').setup({})`
(replace `{}` with your `config` table). It will create global Lua table
`MiniSurround` which you can use for scripting or manually (with
`:lua MiniSurround.*`).

See |MiniSurround.config| for `config` structure and default values. It
also has example setup providing experience similar to 'tpope/vim-surround'.

You can override runtime config settings locally to buffer inside
`vim.b.minisurround_config` which should have same structure as
`MiniSurround.config`. See |mini.nvim-buffer-local-config| for more details.

# Example usage~

- `saiw)` - add (`sa`) for inner word (`iw`) parenthesis (`)`).
- `saiwi[[<CR>]]<CR>` - add (`sa`) for inner word (`iw`) interactive
  surrounding (`i`): `[[` for left and `]]` for right.
- `sdf` - delete (`sd`) surrounding function call (`f`).
- `sr)tdiv<CR>` - replace (`sr`) surrounding parenthesis (`)`) with tag
  (`t`) with identifier 'div' (`div<CR>` in command line prompt).
- `sff` - find right (`sf`) part of surrounding function call (`f`).
- `sh}` - highlight (`sh`) for a brief period of time surrounding curly
  brackets (`}`)

# Highlight groups~

* `MiniSurround` - highlighting of requested surrounding.

To change any highlight group, modify it directly with |:highlight|.

# Disabling~

To disable, set `g:minisurround_disable` (globally) or
`b:minisurround_disable` (for a buffer) to `v:true`. Considering high
number of different scenarios and customization intentions, writing exact
rules for disabling module's functionality is left to user. See
|mini.nvim-disabling-recipes| for common recipes.

------------------------------------------------------------------------------
                                                        *MiniSurround-algorithm*
Algorithm design

- Adding "output" surrounding has a fairly straightforward algorithm:
    - Determine places for left and right parts (via `<>`/`[]` marks or by
      finding some other surrounding).
    - Determine left and right parts of surrounding via using custom and
      builtin surroundings (via `output` field of surrounding info see
      |MiniSurround.config|).
    - Properly add.
- Finding "input" surrounding is a lot more complicated and is a reason why
  this implementation is only somewhat minimal. In a nutshell, current
  algorithm `searches in the neighborhood lines based on a certain pattern
  and search method a best match`. More detailed:
    - Extract neighborhood of cursor line: no more than
      `MiniSurround.config.n_lines` before, cursor line itself, no more than
      `MiniSurround.config.n_lines` after. Note: actual search is done
      firstly on cursor line (i.e. with `n_lines = 0`), as it is the most
      frequent usage and only then searches in wholeneighborhood.
    - Convert it to "1d neighborhood" by concatenating with '\n' delimiter.
      Compute location of current cursor position in this line.
    - Given Lua pattern for an "input" surrounding (`input.find` field of
      surrounding info; see |MiniSurround.config|), search for best match.
      That is:
        - Match with span covering cursor position. If several, try to pick
          one with smallest width.
        - If no covering match, pick one of "previous" (nearest
          non-covering to the left) or "next" (nearest non-covering to the
          right) matches, depending on `config.search_method` (see
          |MiniSurround.config| for more details).
      This computation is an iterative procedure, duration of which heavily
      depends on the length of "1d neighborhood" and frequency of pattern
      matching. If no match is found, there is no surrounding. Note: with
      current approach smallest width of covering match is ensured by
      checking match on covering substrings. This may have unwanted
      consequences when using complex Lua patterns (like `%f[]` at the
      pattern end, for example).
    - Compute parts of "1d neighborhood" that represent left and right part
      of found surrounding. This is done by using pattern from
      `input.extract` field of surrounding info; see |MiniSurround.config|.
      Note: pattern is used on a matched substring, so using `^` and `$` at
      start and end of pattern means start and end of substring.
    - Convert "1d offsets" of found parts to their positions in buffer.

------------------------------------------------------------------------------
                                                          *MiniSurround.setup()*
                         `MiniSurround.setup`({config})
Module setup

Parameters~
{config} `(table)` Module config table. See |MiniSurround.config|.

Usage~
`require('mini.surround').setup({})` (replace `{}` with your `config` table)

------------------------------------------------------------------------------
                                                           *MiniSurround.config*
                             `MiniSurround.config`
Module config

Default values:
>
  MiniSurround.config = {
    -- Add custom surroundings to be used on top of builtin ones. For more
    -- information with examples, see `:h MiniSurround.config`.
    custom_surroundings = nil,

    -- Duration (in ms) of highlight when calling `MiniSurround.highlight()`
    highlight_duration = 500,

    -- Module mappings. Use `''` (empty string) to disable one.
    mappings = {
      add = 'sa', -- Add surrounding in Normal and Visual modes
      delete = 'sd', -- Delete surrounding
      find = 'sf', -- Find surrounding (to the right)
      find_left = 'sF', -- Find surrounding (to the left)
      highlight = 'sh', -- Highlight surrounding
      replace = 'sr', -- Replace surrounding
      update_n_lines = 'sn', -- Update `n_lines`
    },

    -- Number of lines within which surrounding is searched
    n_lines = 20,

    -- How to search for surrounding (first inside current line, then inside
    -- neighborhood). One of 'cover', 'cover_or_next', 'cover_or_prev',
    -- 'cover_or_nearest'. For more details, see `:h MiniSurround.config`.
    search_method = 'cover',
  }
<
# Setup similar to 'tpope/vim-surround'~

This module is primarily designed after 'machakann/vim-sandwich'. To get
behavior closest to 'tpope/vim-surround' (but not identical), use this setup:
>
  require('mini.surround').setup({
    custom_surroundings = {
      ['('] = { output = { left = '( ', right = ' )' } },
      ['['] = { output = { left = '[ ', right = ' ]' } },
      ['{'] = { output = { left = '{ ', right = ' }' } },
      ['<'] = { output = { left = '< ', right = ' >' } },
    },
    mappings = {
      add = 'ys',
      delete = 'ds',
      find = '',
      find_left = '',
      highlight = '',
      replace = 'cs',
      update_n_lines = '',
    },
    search_method = 'cover_or_next',
  })

  -- Remap adding surrounding to Visual mode selection
  vim.api.nvim_set_keymap('x', 'S', [[:<C-u>lua MiniSurround.add('visual')<CR>]], { noremap = true })

  -- Make special mapping for "add surrounding for line"
  vim.api.nvim_set_keymap('n', 'yss', 'ys_', { noremap = false })
<
# Options~

## Custom surroundings~

User can define own surroundings by supplying `config.custom_surroundings`.
It should be a **table** with keys being single character surrounding
identifier and values - surround info or **function** returning it.
Surround info itself is a table with keys:
- <input> - defines how to find and extract surrounding for "input"
  operations (like `delete`). A table with fields <find> (Lua pattern
  applied for search in neighborhood) and <extract> (Lua pattern applied
  for extracting left and right parts; should have two matches).
- <output> - defines what to add on left and right for "output" operations
  (like `add`). A table with <left> (plain text string) and <right> (plain
  text string) fields.

Example of surround info for builtin `(` identifier:>
  {
    input = { find = '%b()', extract = '^(.).*(.)$' },
    output = { left = '(', right = ')' }
  }
<
General recommendations:
- In `config.custom_surroundings` only some data can be defined (like only
  `input.find`). Other fields will be taken from builtin surroundings.
- Function returning table with surround info instead of table itself is
  helpful when user input is needed (like asking for function name). Use
  |input()| or |MiniSurround.user_input()|. Return `nil` to stop any current
  surround operation.
- In input patterns try to use lazy quantifier instead of greedy ones (`.-`
  instead of `.*` or `.+`). That is because the underlying algorithm of
  finding smallest covering is better designed for lazy quantifier.
- Usage of frontier pattern `%f[]` not at the end of pattern can be useful
  to extend match to the left. Like `%f[%w]%w+%b()` matches simplified
  function call while capturing whole function name instead of last symbol.
- Usage of frontier pattern at the end of match is currently problematic
  because output "smallest width" match is computed by checking the match
  on substrings. And frontier pattern matches at the end of substring for
  appropriate last character. So `%f[%w]%w+%f[%W]` won't match whole word.

Present builtin surroundings by their single character identifier:
- `(` and `)` - balanced pair of `()`.
- `[` and `]` - balanced pair of `[]`.
- `{` and `}` - balanced pair of `{}`.
- `<` and `>` - balanced pair of `<>`.
- `f` - function call. Maximum set of allowed symbols (alphanumeric, `_`
  and `.`) followed by balanced pair of `()`.
- `i` - interactive, prompts user to enter left and right parts.
- `t` - HTML tags.
- Any other non-recognized identifier represents surrounding with identical
  left and right parts equal to identifier (like `_`, etc.).

Examples of using `config.custom_surroundings`:
>
  require('mini.surround').setup({
    custom_surroundings = {
      -- Make `)` insert parts with spaces. `input` pattern stays the same.
      [')'] = { output = { left = '( ', right = ' )' } },

      -- Modify `f` (function call) to find functions with only alphanumeric
      -- characters in its name.
      f = { input = { find = '%f[%w]%w+%b()' } },

      -- Use function to compute surrounding info
      ['*'] = {
        input = function()
          local n_star = MiniSurround.user_input('Number of * to find: ')
          local many_star = string.rep('%*', tonumber(n_star) or 1)
          local find = string.format('%s.-%s', many_star, many_star)
          local extract = string.format('^(%s).*(%s)$', many_star, many_star)
          return { find = find, extract = extract }
        end,
        output = function()
          local n_star = MiniSurround.user_input('Number of * to output: ')
          local many_star = string.rep('*', tonumber(n_star) or 1)
          return { left = many_star, right = many_star }
        end,
      },
    },
  })

  -- Create custom surrouding for Lua's block string `[[...]]`. Use this inside
  -- autocommand or 'after/ftplugin/lua.lua' file.
  vim.b.minisurround_config = {
    custom_surroundings = {
      s = {
        input = { find = '%[%[.-%]%]', extract = '^(..).*(..)$' },
        output = { left = '[[', right = ']]' },
      },
    },
  }
<
## Search method~

Value of `config.search_method` defines how best match search for "input"
surrounding is done when there is no covering match (with span covering
cursor position) found within searched neighborhood. Based on its value,
one of "previous", "next", or neither match is used as output.
Its possible values are:
- `'cover'` (default) - don't use either "previous" or "next"; report that
  there is no surrounding found.
- `'cover_or_prev'` - use previous.
- `'cover_or_next'` - use next.
- `'cover_or_nearest'` - use nearest to current cursor position. Distance
  is computed based on "1d neighborhood" using nearest part of
  surroundings. Next is used in case of a tie.

Note: search is first performed on the cursor line and only after failure -
on the whole neighborhood defined by `config.n_lines`. This means that with
`config.search_method` not equal to `'cover'`, "previous" or "next"
surrounding will end up as search result if they present on current line
although covering match might be found in bigger, whole neighborhood. This
design is based on observation that most of the time operation involving
surrounding is done withtin cursor line.

Here is an example of how replacing `)` with `]` surrounding is done based
on a value of `'config.search_method'` when cursor is inside `bbb` word:
- `search_method = 'cover'`:         `(a) bbb (c)` -> `(a) bbb (c)` (with message)
- `search_method = 'cover_or_prev'`: `(a) bbb (c)` -> `[a] bbb (c)`
- `search_method = 'cover_or_next'`: `(a) bbb (c)` -> `(a) bbb [c]`
- `search_method = 'cover_or_nearest'`: depends on cursor position.
  For first `b` - as in `cover_or_prev` (as previous match is nearer), for
  second and third - as in `cover_or_next` (as next match is nearer).

------------------------------------------------------------------------------
                                                       *MiniSurround.operator()*
                    `MiniSurround.operator`({task}, {cache})
Surround operator

Main function to be used in expression mappings. No need to use it
directly, everything is setup in |MiniSurround.setup|.

Parameters~
{task} `(string)` Name of surround task.
{cache} `(table)` Task cache.

------------------------------------------------------------------------------
                                                            *MiniSurround.add()*
                           `MiniSurround.add`({mode})
Add surrounding

No need to use it directly, everything is setup in |MiniSurround.setup|.

Parameters~
{mode} `(string)` Mapping mode (normal by default).

------------------------------------------------------------------------------
                                                         *MiniSurround.delete()*
                            `MiniSurround.delete`()
Delete surrounding

No need to use it directly, everything is setup in |MiniSurround.setup|.

------------------------------------------------------------------------------
                                                        *MiniSurround.replace()*
                            `MiniSurround.replace`()
Replace surrounding

No need to use it directly, everything is setup in |MiniSurround.setup|.

------------------------------------------------------------------------------
                                                           *MiniSurround.find()*
                             `MiniSurround.find`()
Find surrounding

No need to use it directly, everything is setup in |MiniSurround.setup|.

------------------------------------------------------------------------------
                                                      *MiniSurround.highlight()*
                           `MiniSurround.highlight`()
Highlight surrounding

No need to use it directly, everything is setup in |MiniSurround.setup|.

------------------------------------------------------------------------------
                                                 *MiniSurround.update_n_lines()*
                        `MiniSurround.update_n_lines`()
Update `MiniSurround.config.n_lines`

Convenient wrapper for updating `MiniSurround.config.n_lines` in case the
default one is not appropriate.

------------------------------------------------------------------------------
                                                     *MiniSurround.user_input()*
                  `MiniSurround.user_input`({prompt}, {text})
Ask user for input

This is mainly a wrapper for |input()| which allows empty string as input,
cancelling with `<Esc>` and `<C-c>`, and slightly modifies prompt. Use it
to ask for input inside function custom surrounding (see |MiniSurround.config|).


==============================================================================
------------------------------------------------------------------------------
                                                                  *mini.tabline*
                                                                   *MiniTabline*
Minimal and fast tabline module. General idea: show all listed buffers in
readable way with minimal total width. Also allow showing extra information
section in case of multiple vim tabpages. Inspired by
[ap/vim-buftabline](https://github.com/ap/vim-buftabline).

Features:
- Buffers are listed in the order of their identifier (see |bufnr()|).
- Different highlight groups for "states" of buffer affecting 'buffer tabs':
- Buffer names are made unique by extending paths to files or appending
  unique identifier to buffers without name.
- Current buffer is displayed "optimally centered" (in center of screen
  while maximizing the total number of buffers shown) when there are many
  buffers open.
- 'Buffer tabs' are clickable if Neovim allows it.

What it doesn't do:
- Custom buffer order is not supported.

# Dependencies~

Suggested dependencies (provide extra functionality, tabline will work
without them):
- Plugin 'kyazdani42/nvim-web-devicons' for filetype icons near the buffer
  name. If missing, no icons will be shown.

# Setup~

This module needs a setup with `require('mini.tabline').setup({})`
(replace `{}` with your `config` table). It will create global Lua table
`MiniTabline` which you can use for scripting or manually (with
`:lua MiniTabline.*`).

See |MiniTabline.config| for `config` structure and default values.

You can override runtime config settings locally to buffer inside
`vim.b.minitabline_config` which should have same structure as
`MiniTabline.config`. See |mini.nvim-buffer-local-config| for more details.

# Highlight groups~

* `MiniTablineCurrent` - buffer is current (has cursor in it).
* `MiniTablineVisible` - buffer is visible (displayed in some window).
* `MiniTablineHidden` - buffer is hidden (not displayed).
* `MiniTablineModifiedCurrent` - buffer is modified and current.
* `MiniTablineModifiedVisible` - buffer is modified and visible.
* `MiniTablineModifiedHidden` - buffer is modified and hidden.
* `MiniTablineFill` - unused right space of tabline.
* `MiniTablineTabpagesection` - section with tabpage information.

To change any highlight group, modify it directly with |:highlight|.

# Disabling~

To disable (show empty tabline), set `g:minitabline_disable` (globally) or
`b:minitabline_disable` (for a buffer) to `v:true`. Considering high number
of different scenarios and customization intentions, writing exact rules
for disabling module's functionality is left to user. See
|mini.nvim-disabling-recipes| for common recipes. Note: after disabling,
tabline is not updated right away, but rather after dedicated event (see
|events| and `MiniTabline` |augroup|).

------------------------------------------------------------------------------
                                                           *MiniTabline.setup()*
                         `MiniTabline.setup`({config})
Module setup

Parameters~
{config} `(table)` Module config table. See |MiniTabline.config|.

Usage~
`require('mini.tabline').setup({})` (replace `{}` with your `config` table)

------------------------------------------------------------------------------
                                                            *MiniTabline.config*
                              `MiniTabline.config`
Module config

Default values:
>
  MiniTabline.config = {
    -- Whether to show file icons (requires 'kyazdani42/nvim-web-devicons')
    show_icons = true,

    -- Whether to set Vim's settings for tabline (make it always shown and
    -- allow hidden buffers)
    set_vim_settings = true,

    -- Where to show tabpage section in case of multiple vim tabpages.
    -- One of 'left', 'right', 'none'.
    tabpage_section = 'left',
  }
<

------------------------------------------------------------------------------
                                             *MiniTabline.make_tabline_string()*
                      `MiniTabline.make_tabline_string`()
Make string for |tabline|


==============================================================================
------------------------------------------------------------------------------
                                                                     *mini.test*
                                                                      *MiniTest*
Module for writing extensive Neovim plugin tests.

Features:
- Test action is defined as a named callable entry of a table.
- Helper for creating child Neovim process which is designed to be used in
  tests (including taking and verifying screenshots). See
  |MiniTest.new_child_neovim()| and |Minitest.expect.reference_screenshot()|.
- Hierarchical organization of tests with custom hooks, parametrization,
  and user data. See |MiniTest.new_set()|.
- Emulation of 'Olivine-Labs/busted' interface (`describe`, `it`, etc.).
- Predefined small yet usable set of expectations (`assert`-like functions).
  See |MiniTest.expect|.
- Customizable definition of what files should be tested.
- Test case filtering. There are predefined wrappers for testing a file
  (|MiniTest.run_file()|) and case at a location like current cursor position
  (|MiniTest.run_at_location()|).
- Customizable reporter of output results. There are two predefined ones:
    - |MiniTest.gen_reporter.buffer()| for interactive usage.
    - |MiniTest.gen_reporter.stdout()| for headless Neovim.
- Customizable project specific testing script.

What it doesn't support:
- Parallel execution. Due to idea of limiting implementation complexity.
- Mocks, stubs, etc. Use child Neovim process and manually override what is
  needed. Reset child process it afterwards.
- "Overly specific" expectations. Tests for (no) equality and (absence of)
  errors usually cover most of the needs. Adding new expectations is a
  subject to weighing its usefulness against additional implementation
  complexity. Use |MiniTest.new_expectation()| to create custom ones.

For more information see:
- 'TESTING.md' file for a hands-on introduction based on examples.
- Code of this plugin's tests. Consider it to be an example of intended
  way to use 'mini.test' for test organization and creation.

# Workflow

- Organize tests in separate files. Each test file should return a test set
  (explicitly or implicitly by using "busted" style functions).
- Write test actions as callable entries of test set. Use child process
  inside test actions (see |MiniTest.new_child_neovim()|) and builtin
  expectations (see |MiniTest.expect|).
- Run tests. This does two steps:
    - *Collect*. This creates single hierarchical test set, flattens into
      array of test cases (see |MiniTest-test-case|) while expanding with
      parametrization, and possibly filters them.
    - *Execute*. This safely calls hooks and main test actions in specified
      order while allowing reporting progress in asynchronous fashion.
      Detected errors means test case fail; otherwise - pass.

# Setup~

This module needs a setup with `require('mini.test').setup({})` (replace
`{}` with your `config` table). It will create global Lua table `MiniTest`
which you can use for scripting or manually (with `:lua MiniTest.*`).

See |MiniTest.config| for available config settings.

You can override runtime config settings locally to buffer inside
`vim.b.minitest_config` which should have same structure as `MiniTest.config`.
See |mini.nvim-buffer-local-config| for more details.

# Comparisons~

- Testing infrastructure from 'nvim-lua/plenary.nvim':
    - Executes each file in separate headless Neovim process with customizable
      'init.vim' file. While 'mini.test' executes everything in current
      Neovim process encouraging writing tests with help of manually
      managed child Neovim process (see |MiniTest.new_child_neovim()|).
    - Tests are expected to be written with embedded simplified versions of
      'Olivine-Labs/busted' and 'Olivine-Labs/luassert'. While 'mini.test'
      uses concepts of test set (see |MiniTest.new_set()|) and test case
      (see |MiniTest-test-case|). It also can emulate bigger part of
      "busted" framework.
    - Has single way of reporting progress (shows result after every case
      without summary). While 'mini.test' can have customized reporters
      with defaults for interactive and headless usage (provide more
      compact and user-friendly summaries).
    - Allows parallel execution, while 'mini.test' does not.
    - Allows making mocks, stubs, and spies, while 'mini.test' does not in
      favor of manually overwriting functionality in child Neovim process.

Although 'mini.test' supports emulation of "busted style" testing, it will
be more stable to use its designed approach of defining tests (with
`MiniTest.new_set()` and explicit table fields). Couple of reasons:
- "Busted" syntax doesn't support full capabilities offered by 'mini.test'.
  Mainly it is about parametrization and supplying user data to test sets.
- It is an emulation, not full support. So some subtle things might not
  work the way you expect.

Some hints for converting from 'plenary.nvim' tests to 'mini.test':
- Rename files from "***_spec.lua" to "test_***.lua" and put them in
  "tests" directory.
- Replace `assert` calls with 'mini.test' expectations. See |MiniTest.expect|.
- Create main test set `T = MiniTest.new_set()` and eventually return it.
- Make new sets (|MiniTest.new_set()|) from `describe` blocks. Convert
  `before_each()` and `after_each` to `pre_case` and `post_case` hooks.
- Make test cases from `it` blocks.

# Highlight groups~

* `MiniTestEmphasis` - emphasis highlighting. By default it is a bold text.
* `MiniTestFail` - highlighting of failed cases. By default it is a bold
  text with `vim.g.terminal_color_1` color (red).
* `MiniTestPass` - highlighting of passed cases. By default it is a bold
  text with `vim.g.terminal_color_2` color (green).

To change any highlight group, modify it directly with |:highlight|.

# Disabling~

To disable, set `g:minitest_disable` (globally) or `b:minitest_disable`
(for a buffer) to `v:true`. Considering high number of different scenarios
and customization intentions, writing exact rules for disabling module's
functionality is left to user. See |mini.nvim-disabling-recipes| for common
recipes.

------------------------------------------------------------------------------
                                                              *MiniTest.setup()*
                           `MiniTest.setup`({config})
Module setup

Parameters~
{config} `(table|nil)` Module config table. See |MiniTest.config|.

Usage~
`require('mini.test').setup({})` (replace `{}` with your `config` table)

------------------------------------------------------------------------------
                                                               *MiniTest.config*
                               `MiniTest.config`
Module config

Default values:
>
  MiniTest.config = {
    -- Options for collection of test cases. See `:h MiniTest.collect()`.
    collect = {
      -- Temporarily emulate functions from 'busted' testing framework
      -- (`describe`, `it`, `before_each`, `after_each`, and more)
      emulate_busted = true,

      -- Function returning array of file paths to be collected.
      -- Default: all Lua files in 'tests' directory starting with 'test_'.
      find_files = function()
        return vim.fn.globpath('tests', '**/test_*.lua', true, true)
      end,

      -- Predicate function indicating if test case should be executed
      filter_cases = function(case) return true end,
    },

    -- Options for execution of test cases. See `:h MiniTest.execute()`.
    execute = {
      -- Table with callable fields `start()`, `update()`, and `finish()`
      reporter = nil,

      -- Whether to stop execution after first error
      stop_on_error = false,
    },

    -- Path (relative to current directory) to script which handles project
    -- specific test running
    script_path = 'scripts/minitest.lua',
  }
<

------------------------------------------------------------------------------
                                                              *MiniTest.current*
                               `MiniTest.current`
Table with information about current state of test execution

Use it to examine result of |MiniTest.execute()|. It is reset at the
beginning of every call.

At least these keys are supported:
- <all_cases> - array with all cases being currently executed. Basically,
  an input of `MiniTest.execute()`.
- <case> - currently executed test case. See |MiniTest-test-case|. Use it
  to customize execution output (like adding custom notes, etc).

------------------------------------------------------------------------------
                                                            *MiniTest.new_set()*
                       `MiniTest.new_set`({opts}, {tbl})
Create test set

Test set is one of the two fundamental data structures. It is a table that
defines hierarchical test organization as opposed to sequential
organization with |MiniTest-test-case|.

All its elements are one of three categories:
- A callable (object that can be called; function or table with `__call`
  metatble entry) is considered to define a test action. It will be called
  with "current arguments" (result of all nested `parametrize` values, read
  further). If it throws error, test has failed.
- A test set (output of this function) defines nested structure. Its
  options during collection (see |MiniTest.collect()|) will be extended
  with options of this (parent) test set.
- Any other elements are considered helpers and don't directly participate
  in test structure.

Set options allow customization of test collection and execution (more
details in `opts` description):
- `hooks` - table with elements that will be called without arguments at
  predefined stages of test execution.
- `parametrize` - array defining different arguments with which main test
  actions will be called. Any non-trivial parametrization will lead to
  every element (even nested) be "multiplied" and processed with every
  element of `parametrize`. This allows handling many different combination
  of tests with little effort.
- `data` - table with user data that will be forwarded to cases. Primary
  objective is to be used for customized case filtering.

Notes:
- Preferred way of adding elements is by using syntax `T[name] = element`.
  This way order of added elements will be preserved. Any other way won't
  guarantee any order.
- Supplied options `opts` are stored in `opts` field of metatable
  (`getmetatable(set).opts`).

Parameters~
{opts} `(table|nil)` Allowed options:
  - <hooks> - table with fields:
      - <pre_once> - executed before first filtered node.
      - <pre_case> - executed before each case (even nested).
      - <post_case> - executed after each case (even nested).
      - <post_once> - executed after last filtered node.
  - <parametrize> - array where each element is itself an array of
    parameters to be appended to "current parameters" of callable fields.
    Note: don't use plain `{}` as it is equivalent to "parametrization into
    zero cases", so no cases will be collected from this set. Calling test
    actions with no parameters is equivalent to `{{}}` or not supplying
    `parametrize` option at all.
  - <data> - user data to be forwarded to cases. Can be used for a more
    granular filtering.
{tbl} `(table|nil)` Initial test items (possibly nested). Will be executed
  without any guarantees on order.

Return~
`(table)` A single test set.

Usage~
>
  -- Use with defaults
  T = MiniTest.new_set()
  T['works'] = function() MiniTest.expect.equality(1, 1) end

  -- Use with custom options. This will result into two actual cases: first
  -- will pass, second - fail.
  T['nested'] = MiniTest.new_set({
    hooks = { pre_case = function() _G.x = 1 end },
    parametrize = { { 1 }, { 2 } }
  })

  T['nested']['works'] = function(x)
    MiniTest.expect.equality(_G.x, x)
  end

------------------------------------------------------------------------------
                                                            *MiniTest-test-case*
Test case

An item of sequential test organization, as opposed to hierarchical with
test set (see |MiniTest.new_set()|). It is created as result of test
collection with |MiniTest.collect()| to represent all necessary information
of test execution.

Execution of test case goes by the following rules:
- Call functions in order:
    - All elements of `hooks.pre` from first to last without arguments.
    - Field `test` with arguments unpacked from `args`.
    - All elements of `hooks.post` from first to last without arguments.
- Error in any call gets appended to `exec.fails`, meaning error in any
  hook will lead to test fail.
- State (`exec.state`) is changed before every call and after last call.

Class~
{Test-case}

Fields~
{args} `(table)` Array of arguments with which `test` will be called.
{data} `(table)` User data: all fields of `opts.data` from nested test sets.
{desc} `(table)` Description: array of fields from nested test sets.
{exec} `(table|nil)` Information about test case execution. Value of `nil` means
  that this particular case was not (yet) executed. Has following fields:
    - <fails> - array of strings with failing information.
    - <notes> - array of strings with non-failing information.
    - <state> - state of test execution. One of:
        - 'Executing <name of what is being executed>' (during execution).
        - 'Pass' (no fails, no notes).
        - 'Pass with notes' (no fails, some notes).
        - 'Fail' (some fails, no notes).
        - 'Fail with notes' (some fails, some notes).
{hooks} `(table)` Hooks to be executed as part of test case. Has fields
  <pre> and <post> with arrays to be consecutively executed before and
  after execution of `test`.
{test} `(function|table)` Main callable object representing test action.

------------------------------------------------------------------------------
                                                               *MiniTest.skip()*
                             `MiniTest.skip`({msg})
Skip rest of current callable execution

Can be used inside hooks and main test callable of test case. Note: at the
moment implemented as a specially handled type of error.

Parameters~
{msg} `(string|nil)` Message to be added to current case notes.

------------------------------------------------------------------------------
                                                           *MiniTest.add_note()*
                           `MiniTest.add_note`({msg})
Add note to currently executed test case

Appends `msg` to `exec.notes` field of |MiniTest.current.case|.

Parameters~
{msg} `(string)` Note to add.

------------------------------------------------------------------------------
                                                            *MiniTest.finally()*
                            `MiniTest.finally`({f})
Register callable execution after current callable

Can be used inside hooks and main test callable of test case.

Parameters~
{f} `(function)` Callable to be executed after current callable is finished
  executing (regardless of whether it ended with error or not).

------------------------------------------------------------------------------
                                                                *MiniTest.run()*
                             `MiniTest.run`({opts})
Run tests

- Try executing project specific script at path `opts.script_path`. If
  successful (no errors), then stop.
- Collect cases with |MiniTest.collect()| and `opts.collect`.
- Execute collected cases with |MiniTest.execute()| and `opts.execute`.

Parameters~
{opts} `(table|nil)` Options with structure similar to |MiniTest.config|.
  Absent values are inferred from there.

------------------------------------------------------------------------------
                                                           *MiniTest.run_file()*
                      `MiniTest.run_file`({file}, {opts})
Run specific test file

Basically a |MiniTest.run()| wrapper with custom `collect.find_files` option.

Parameters~
{file} `(string|nil)` Path to test file. By default a path of current buffer.
{opts} `(table|nil)` Options for |MiniTest.run()|.

------------------------------------------------------------------------------
                                                    *MiniTest.run_at_location()*
                 `MiniTest.run_at_location`({location}, {opts})
Run case(s) covering location

Try filtering case(s) covering location, meaning that definition of its
main `test` action (as taken from builtin `debug.getinfo`) is located in
specified file and covers specified line. Note that it can result in
multiple cases if they come from parametrized test set (see `parametrize`
option in |MiniTest.new_set()|).

Basically a |MiniTest.run()| wrapper with custom `collect.find_files` option.

Parameters~
{location} `(table|nil)` Table with fields <file> (path to file) and <line>
  (line number in that file). Default is taken from current cursor position.

------------------------------------------------------------------------------
                                                            *MiniTest.collect()*
                           `MiniTest.collect`({opts})
Collect test cases

Overview of collection process:
- If `opts.emulate_busted` is `true`, temporary make special global
  functions (removed at the end of collection). They can be used inside
  test files to create hierarchical structure of test cases.
- Source each file from array output of `opts.find_files`. It should output
  a test set (see |MiniTest.new_set()|) or `nil` (if "busted" style is used;
  test set is created implicitly).
- Combine all test sets into single set with fields equal to its file path.
- Convert from hierarchical test configuration to sequential: from single
  test set to array of test cases (see |MiniTest-test-case|). Conversion is
  done in the form of "for every table element do: for every `parametrize`
  element do: ...". Details:
    - If element is a callable, construct test case with it being main
      `test` action. Description is appended with key of element in current
      test set table. Hooks, arguments, and data are taken from "current
      nested" ones. Add case to output array.
    - If element is a test set, process it in similar, recursive fashion.
      The "current nested" information is expanded:
        - `args` is extended with "current element" from `parametrize`.
        - `desc` is appended with element key.
        - `hooks` are appended to their appropriate places. `*_case` hooks
          will be inserted closer to all child cases than hooks from parent
          test sets: `pre_case` at end, `post_case` at start.
        - `data` is extended via |vim.tbl_deep_extend()|.
    - Any other element is not processed.
- Filter array with `opts.filter_cases`. Note that input case doesn't contain
  all hooks, as `*_once` hooks will be added after filtration.
- Add `*_once` hooks to appropriate cases.

Parameters~
{opts} `(table|nil)` Options controlling case collection. Possible fields:
  - <emulate_busted> - whether to emulate 'Olivine-Labs/busted' interface.
    It emulates these global functions: `describe`, `it`, `setup`, `teardown`,
    `before_each`, `after_each`. Use |MiniTest.skip()| instead of `pending()`
    and |MiniTest.finally()| instead of `finally`.
  - <find_files> - function which when called without arguments returns
    array with file paths. Each file should be a Lua file returning single
    test set or `nil`.
  - <filter_cases> - function which when called with single test case
    (see |MiniTest-test-case|) returns `false` if this case should be filtered
    out; `true` otherwise.

Return~
`(table)` Array of test cases ready to be used by |MiniTest.execute()|.

------------------------------------------------------------------------------
                                                            *MiniTest.execute()*
                      `MiniTest.execute`({cases}, {opts})
Execute array of test cases

Overview of execution process:
- Reset `all_cases` in |MiniTest.current| with `cases` input.
- Call `reporter.start(cases)` (if present).
- Execute each case in natural array order (aligned with their integer
  keys). Set `MiniTest.current.case` to currently executed case. Detailed
  test case execution is described in |MiniTest-test-case|. After any state
  change, call `reporter.update(case_num)` (if present), where `case_num` is an
  integer key of current test case.
- Call `reporter.finish()` (if present).

Notes:
- Execution is done in asynchronous fashion with scheduling. This allows
  making meaningful progress report during execution.
- This function doesn't return anything. Instead, it updates `cases` in
  place with proper `exec` field. Use `all_cases` at |MiniTest.current| to
  look at execution result.

Parameters~
{cases} `(table)` Array of test cases (see |MiniTest-test-case|).
{opts} `(table|nil)` Options controlling case collection. Possible fields:
  - <reporter> - table with possible callable fields `start`, `update`,
    `finish`. Default: |MiniTest.gen_reporter.buffer()| in interactive
    usage and |MiniTest.gen_reporter.stdout()| in headless usage.
  - <stop_on_error> - whether to stop execution (see |MiniTest.stop()|)
    after first error. Default: `false`.

------------------------------------------------------------------------------
                                                               *MiniTest.stop()*
                            `MiniTest.stop`({opts})
Stop test execution

Parameters~
{opts} `(table|nil)` Options with fields:
  - <close_all_child_neovim> - whether to close all child neovim processes
    created with |MiniTest.new_child_neovim()|. Default: `true`.

------------------------------------------------------------------------------
                                                       *MiniTest.is_executing()*
                           `MiniTest.is_executing`()
Check if tests are being executed

Return~
`(boolean)`

------------------------------------------------------------------------------
                                                               *MiniTest.expect*
                               `MiniTest.expect`
Table with expectation functions

Each function has the following behavior:
- Silently returns `true` if expectation is fulfilled.
- Throws an informative error with information helpful for debugging.

Mostly designed to be used within 'mini.test' framework.

Usage~
>
  local x = 1 + 1
  MiniTest.expect.equality(x, 2) -- passes
  MiniTest.expect.equality(x, 1) -- fails

------------------------------------------------------------------------------
                                                    *MiniTest.expect.equality()*
                  `MiniTest.expect.equality`({left}, {right})
Expect equality of two objects

Equality is tested via |vim.deep_equal()|.

Parameters~
{left} `(any)` First object.
{right} `(any)` Second object.

------------------------------------------------------------------------------
                                                 *MiniTest.expect.no_equality()*
                 `MiniTest.expect.no_equality`({left}, {right})
Expect no equality of two objects

Equality is tested via |vim.deep_equal()|.

Parameters~
{left} `(any)` First object.
{right} `(any)` Second object.

------------------------------------------------------------------------------
                                                       *MiniTest.expect.error()*
                 `MiniTest.expect.error`({f}, {pattern}, {...})
Expect function call to raise error

Parameters~
{f} `(function)` Function to be tested for raising error.
{pattern} `(string|nil)` Pattern which error message should match.
  Use `nil` or empty string to not test for pattern matching.
{...} `(any)` Extra arguments with which `f` will be called.

------------------------------------------------------------------------------
                                                    *MiniTest.expect.no_error()*
                     `MiniTest.expect.no_error`({f}, {...})
Expect function call to not raise error

Parameters~
{f} `(function)` Function to be tested for raising error.
{...} `(any)` Extra arguments with which `f` will be called.

------------------------------------------------------------------------------
                                        *MiniTest.expect.reference_screenshot()*
      `MiniTest.expect.reference_screenshot`({screenshot}, {path}, {opts})
Expect equality to reference screenshot

Parameters~
{screenshot} `(table|nil)` Array with screenshot information. Usually an output
  of `child.get_screenshot()` (see |MiniTest-child-neovim.get_screenshot()|).
  If `nil`, expectation passed.
{path} `(string|nil)` Path to reference screenshot. If `nil`, constructed
  automatically in directory 'tests/screenshots' from current case info and
  total number of times it was called inside current case. If there is no
  file at `path`, it is created with content of `screenshot`.
{opts} `(table|nil)` Options:
  - <force> - whether to forcefuly create reference screenshot.
    Temporary useful during test writing. Default: `false`.

------------------------------------------------------------------------------
                                                    *MiniTest.new_expectation()*
       `MiniTest.new_expectation`({subject}, {predicate}, {fail_context})
Create new expectation function

Helper for writing custom functions with behavior similar to other methods
of |MiniTest.expect|.

Parameters~
{subject} `(string|function)` Subject of expectation. If function, called with
  expectation input arguments to produce string value.
{predicate} `(function)` Predicate function. Called with expectation input
  arguments. Output `false` or `nil` means failed expectation.
{fail_context} `(string|function)` Information about fail. If function, called
  with expectation input arguments to produce string value.

Return~
`(function)` Expectation function.

Usage~
>
  local expect_truthy = MiniTest.new_expectation(
    'truthy',
    function(x) return x end,
    function(x) return 'Object: ' .. vim.inspect(x) end
  )

------------------------------------------------------------------------------
                                                         *MiniTest.gen_reporter*
                            `MiniTest.gen_reporter`
Table with pre-configured report generators

Each element is a function which returns reporter - table with callable
`start`, `update`, and `finish` fields.

------------------------------------------------------------------------------
                                                *MiniTest.gen_reporter.buffer()*
                     `MiniTest.gen_reporter.buffer`({opts})
Generate buffer reporter

This is a default choice for interactive (not headless) usage. Opens a window
with dedicated non-terminal buffer and updates it with throttled redraws.

Opened buffer has the following helpful Normal mode mappings:
- `<Esc>` - stop test execution if executing (see |MiniTest.is_executing()|
  and |MiniTest.stop()|). Close window otherwise.
- `q` - same as `<Esc>` for convenience and compatibility.

General idea:
- Group cases by concatenating first `opts.group_depth` elements of case
  description (`desc` field). Groups by collected files if using default values.
- In `start()` show some stats to know how much is scheduled to be executed.
- In `update()` show symbolic overview of current group and state of current
  case. Each symbol represents one case and its state:
    - `?` - case didn't finish executing.
    - `o` - pass.
    - `O` - pass with notes.
    - `x` - fail.
    - `X` - fail with notes.
- In `finish()` show all fails and notes ordered by case.

Parameters~
{opts} `(table|nil)` Table with options. Used fields:
  - <group_depth> - number of first elements of case description (can be zero)
    used for grouping. Higher values mean higher granularity of output.
    Default: 1.
  - <throttle_delay> - minimum number of milliseconds to wait between
    redrawing. Reduces screen flickering but not amount of computations.
    Default: 10.
  - <window> - definition of window to open. Can take one of the forms:
      - Callable. It is called expecting output to be target window id
        (current window is used if output is `nil`). Use this to open in
        "normal" window (like `function() vim.cmd('vsplit') end`).
      - Table. Used as `config` argument in |nvim_open_win()|.
    Default: table for centered floating window.

------------------------------------------------------------------------------
                                                *MiniTest.gen_reporter.stdout()*
                     `MiniTest.gen_reporter.stdout`({opts})
Generate stdout reporter

This is a default choice for headless usage. Writes to `stdout`. Uses
coloring ANSI escape sequences to make pretty and informative output
(should work in most modern terminals and continuous integration providers).

It has same general idea as |MiniTest.gen_reporter.buffer()| with slightly
less output (it doesn't overwrite previous text) to overcome typical
terminal limitations.

Parameters~
{opts} `(table|nil)` Table with options. Used fields:
  - <group_depth> - number of first elements of case description (can be zero)
    used for grouping. Higher values mean higher granularity of output.
    Default: 1.
  - <quit_on_finish> - whether to quit after finishing test execution.
    Default: `true`.

------------------------------------------------------------------------------
                                                   *MiniTest.new_child_neovim()*
                         `MiniTest.new_child_neovim`()
Create child Neovim process

This creates an object designed to be a fundamental piece of 'mini.test'
methodology. It can start/stop/restart a separate (child) Neovim process in
full (non-headless) mode together with convenience helpers to interact with
it through |RPC| messages.

For more information see |MiniTest-child-neovim|.

Return~
`child` Object of |MiniTest-child-neovim|.

Usage~
>
  -- Initiate
  local child = MiniTest.new_child_neovim()
  child.start()

  -- Use API functions
  child.api.nvim_buf_set_lines(0, 0, -1, true, { 'Line inside child Neovim' })

  -- Execute Lua code, Vimscript commands, etc.
  child.lua('_G.n = 0')
  child.cmd('au CursorMoved * lua _G.n = _G.n + 1')
  child.type_keys('l')
  print(child.lua_get('_G.n')) -- Should be 1

  -- Use other `vim.xxx` Lua wrappers (executed inside child process)
  vim.b.aaa = 'current process'
  child.b.aaa = 'child process'
  print(child.lua_get('vim.b.aaa')) -- Should be 'child process'

  -- Always stop process after it is not needed
  child.stop()

------------------------------------------------------------------------------
                                                         *MiniTest-child-neovim*
Child class

It offers a great set of tools to write reliable and reproducible tests by
allowing to use fresh process in any test action. Interaction with it is done
through |RPC| protocol.

Although quite flexible, at the moment it has certain limitations:
- Doesn't allow using functions or userdata for child's both inputs and
  outputs. Usual solution is to move computations from current Neovim process
  to child process. Use `child.lua()` and `child.lua_get()` for that.
- When writing tests, it is common to end up with "hanging" process: it
  stops executing without any output. Most of the time it is because Neovim
  process is "blocked", i.e. it waits for user input and won't return from
  other call (like `child.api.nvim_exec_lua()`). Common causes are active
  |hit-enter-prompt| (increase prompt height to a bigger value) or
  Operator-pending mode (exit it). To mitigate this experience, most helpers
  will throw an error if its immediate execution will lead to hanging state.
  Also in case of hanging state try `child.api_notify` instead of `child.api`.

Notes:
- An important type of field is a "redirection table". It acts as a
  convenience wrapper for corresponding `vim.*` table. Can be used both to
  return and set values. Examples:
    - `child.api.nvim_buf_line_count(0)` will execute
      `vim.api.nvim_buf_line_count(0)` inside child process and return its
      output to current process.
    - `child.bo.filetype = 'lua'` will execute `vim.bo.filetype = 'lua'`
      inside child process.
  They still have same limitations listed above, so are not perfect. In
  case of a doubt, use `child.lua()`.
- Almost all methods use |vim.rpcrequest()| (i.e. wait for call to finish and
  then return value). See for `*_notify` variant to use |vim.rpcnotify()|.
- All fields and methods should be called with `.`, not `:`.

Class~
{child}

Fields~
{start} `(function)` Start child process. See |MiniTest-child-neovim.start()|.
{stop} `(function)` Stop current child process.
{restart} `(function)` Restart child process: stop if running and then
  start a new one. Takes same arguments as `child.start()` but uses values
  from most recent `start()` call as defaults.

{type_keys} `(function)` Emulate typing keys.
  See |MiniTest-child-neovim.type_keys()|. Doesn't check for blocked state.

{cmd} `(function)` Execute Vimscript code from a string.
  A wrapper for |nvim_exec()| without capturing output.
{cmd_capture} `(function)` Execute Vimscript code from a string and
  capture output. A wrapper for |nvim_exec()| with capturing output.

{lua} `(function)` Execute Lua code. A wrapper for |nvim_exec_lua()|.
{lua_get} `(function)` Execute Lua code and return result. A wrapper
  for |nvim_exec_lua()| but prepends string code with `return`.

{is_blocked} `(function)` Check whether child process is blocked.
{is_running} `(function)` Check whether child process is currently running.

{ensure_normal_mode} `(function)` Ensure normal mode.
{get_screenshot} `(function)` Returns table with two "2d arrays" of single
  characters representing what is displayed on screen and how it looks.
  Note: works only in Neovim>=0.6. See |MiniTest-child-neovim.get_screenshot()|.

{job} `(table|nil)` Information about current job. If `nil`, child is not running.

{api} `(table)` Redirection table for `vim.api`. Doesn't check for blocked state.
{api_notify} `(table)` Same as `api`, but uses |vim.rpcnotify()|.

{diagnostic} `(table)` Redirection table for |vim.diagnostic|.
{fn} `(table)` Redirection table for |vim.fn|.
{highlight} `(table)` Redirection table for `vim.highlight` (|lua-highlight)|.
{json} `(table)` Redirection table for `vim.json`.
{loop} `(table)` Redirection table for |vim.loop|.
{lsp} `(table)` Redirection table for `vim.lsp` (|lsp-core)|.
{mpack} `(table)` Redirection table for |vim.mpack|.
{spell} `(table)` Redirection table for |vim.spell|.
{treesitter} `(table)` Redirection table for |vim.treesitter|.
{ui} `(table)` Redirection table for `vim.ui` (|lua-ui|). Currently of no
  use because it requires sending function through RPC, which is impossible
  at the moment.

{g} `(table)` Redirection table for |vim.g|.
{b} `(table)` Redirection table for |vim.b|.
{w} `(table)` Redirection table for |vim.w|.
{t} `(table)` Redirection table for |vim.t|.
{v} `(table)` Redirection table for |vim.v|.
{env} `(table)` Redirection table for |vim.env|.

{o} `(table)` Redirection table for |vim.o|.
{go} `(table)` Redirection table for |vim.go|.
{bo} `(table)` Redirection table for |vim.bo|.
{wo} `(table)` Redirection table for |vim.wo|.

------------------------------------------------------------------------------
                                                 *MiniTest-child-neovim.start()*
child.start(args, opts)~

Start child process and connect to it. Won't work if child is already running.

Parameters~
{args} `(table)` Array with arguments for executable. Will be prepended
  with `{'--clean', '-n', '--listen', <some address>}` (see |startup-options|).
{opts} `(table)` Options:
  - <nvim_executable> - name of Neovim executable. Default: |v:progpath|.
  - <connection_timeout> - stop trying to connect after this amount of
    milliseconds. Default: 5000.

Usage~
>
  child = MiniTest.new_child_neovim()

  -- Start default clean Neovim instance
  child.start()

  -- Start with custom 'init.lua' file
  child.start({ '-u', 'scripts/minimal_init.lua' })

------------------------------------------------------------------------------
                                             *MiniTest-child-neovim.type_keys()*
child.type_keys(wait, ...)~

Basically a wrapper for |nvim_input()| applied inside child process.
Differences:
- Can wait after each group of characters.
- Raises error if typing keys resulted into error in child process (i.e. its
  |v:errmsg| was updated).
- Key '<' as separate entry may not be escaped as '<LT>'.

Parameters~
{wait} `(number)` Number of milliseconds to wait after each entry. May be
  omitted, in which case no waiting is done.
{...} `(string|table<number,string>)` Separate entries for |nvim_input()|,
  after which `wait` will be applied. Can be either string or array of strings.

Usage~
>
  -- All of these type keys 'c', 'a', 'w'
  child.type_keys('caw')
  child.type_keys('c', 'a', 'w')
  child.type_keys('c', { 'a', 'w' })

  -- Waits 5 ms after `c` and after 'w'
  child.type_keys(5, 'c', { 'a', 'w' })

  -- Special keys can also be used
  child.type_keys('i', 'Hello world', '<Esc>')

------------------------------------------------------------------------------
                                        *MiniTest-child-neovim.get_screenshot()*
child.get_screenshot()~

Compute what is displayed on (default TUI) screen and how it is displayed.
This basically calls |screenstring()| and |screenattr()| for every visible
cell (row from 1 to 'lines', column from 1 to 'columns').

Notes:
- This requires Neovim>=0.6 as `screenstring()` was introduced only in 0.6.
- Due to implementation details of `screenstring()` and `screenattr()` in
  Neovim<=0.7, this function won't recognize floating windows displayed on
  screen. It will throw an error if there is a visible floating window. Use
  Neovim>=0.8 (current nightly) to properly handle floating windows. Details:
    - https://github.com/neovim/neovim/issues/19013
    - https://github.com/neovim/neovim/pull/19020
- To make output more portable and visually useful, outputs of
  `screenattr()` are coded with single character symbols. Those are taken from
  94 characters (ASCII codes between 33 and 126), so there will be duplicates
  in case of more than 94 different ways text is displayed on screen.

Return~
`(table|nil)` Screenshot table with the following fields:
  - <text> - "2d array" (row-column) of single characters displayed at
    particular cells.
  - <attr> - "2d array" (row-column) of symbols representing how text is
    displayed (basically, "coded" appearance/highlighting). They should be
    used only in relation to each other: same/different symbols for two
    cells mean same/different visual appearance. Note: there will be false
    positives if there are more than 94 different attribute values.
  It also can be used with `tostring()` to convert to single string (used
  for writing to reference file). It results into two visual parts
  (separated by empty line), for `text` and `attr`. Each part has "ruler"
  above content and line numbers for each line.
  Returns `nil` if couldn't get a reasonable screenshot.

Usage~
>
  local screenshot = child.get_screenshot()

  -- Show character displayed row=3 and column=4
  print(screenshot.text[3][4])

  -- Convert to string
  tostring(screenshot)


==============================================================================
------------------------------------------------------------------------------
                                                               *mini.trailspace*
                                                                *MiniTrailspace*
Minimal and fast module for working with trailing whitespace.

Features:
- Highlighting is done only in modifiable buffer by default; only in Normal
  mode; stops in Insert mode and when leaving window.
- Trim all trailing whitespace with |MiniTrailspace.trim()| function.

# Setup~

This module needs a setup with `require('mini.trailspace').setup({})`
(replace `{}` with your `config` table). It will create global Lua table
`MiniTrailspace` which you can use for scripting or manually (with
`:lua MiniTrailspace.*`).

See |MiniTrailspace.config| for `config` structure and default values.

You can override runtime config settings locally to buffer inside
`vim.b.minitrailspace_config` which should have same structure as
`MiniTrailspace.config`. See |mini.nvim-buffer-local-config| for more details.

# Highlight groups~

* `MiniTrailspace` - highlight group for trailing space.

To change any highlight group, modify it directly with |:highlight|.

# Disabling~

To disable, set `g:minitrailspace_disable` (globally) or
`b:minitrailspace_disable` (for a buffer) to `v:true`. Considering high
number of different scenarios and customization intentions, writing exact
rules for disabling module's functionality is left to user. See
|mini.nvim-disabling-recipes| for common recipes. Note: after disabling
there might be highlighting left; it will be removed after next
highlighting update (see |events| and `MiniTrailspace` |augroup|).

------------------------------------------------------------------------------
                                                        *MiniTrailspace.setup()*
                        `MiniTrailspace.setup`({config})
Module setup

Parameters~
{config} `(table)` Module config table. See |MiniTrailspace.config|.

Usage~
`require('mini.trailspace').setup({})` (replace `{}` with your `config` table)

------------------------------------------------------------------------------
                                                         *MiniTrailspace.config*
                            `MiniTrailspace.config`
Module config

Default values:
>
  MiniTrailspace.config = {
    -- Highlight only in normal buffers (ones with empty 'buftype'). This is
    -- useful to not show trailing whitespace where it usually doesn't matter.
    only_in_normal_buffers = true,
  }
<

------------------------------------------------------------------------------
                                                    *MiniTrailspace.highlight()*
                          `MiniTrailspace.highlight`()
Highlight trailing whitespace in current window

------------------------------------------------------------------------------
                                                  *MiniTrailspace.unhighlight()*
                         `MiniTrailspace.unhighlight`()
Unhighlight trailing whitespace in current window

------------------------------------------------------------------------------
                                                         *MiniTrailspace.trim()*
                            `MiniTrailspace.trim`()
Trim trailing whitespace

------------------------------------------------------------------------------
                                              *MiniTrailspace.trim_last_lines()*
                       `MiniTrailspace.trim_last_lines`()
Trim last blank lines

------------------------------------------------------------------------------
                                          *MiniTrailspace.track_normal_buffer()*
                     `MiniTrailspace.track_normal_buffer`()
Track normal buffer

Designed to be used with |autocmd|. No need to use it directly.


 vim:tw=78:ts=8:noet:ft=help:norl: