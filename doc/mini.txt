================================================================================
                                                                     *mini.nvim*

|mini.nvim| is a collection of minimal, independent, and fast Lua modules
dedicated to improve Neovim (version 0.5 and higher) experience. Each module
can be considered as a separate sub-plugin.

# General principles

- <Design>. Each module is designed to solve a particular problem targeting 
  balance between feature-richness (handling as many edge-cases as possible)
  and simplicity of implementation/support. Granted, not all of them ended up
  with the same balance, but it is the goal nevertheless.
- <Independence>. Modules are independent of each other and can be run without
  external dependencies. Although some of them may need dependencies for full
  experience.
- <Structure>. Each module is a submodule for a placeholder "mini" module. So, 
  for example, "surround" module should be referred to as "mini.surround". As
  later will be explained, this plugin can also be referred to as
  "MiniSurround".
- <Setup>:
    - Each module (if needed) should be setup separately with
      `require(<name of module>).setup({})` (possibly replace {} with your
      config table or omit to use defaults). You can supply only values which
      differ from defaults, which will be used for the rest ones.
    - Call to module's `setup()` always creates a global Lua object with 
      coherent camel-case name: `require('mini.surround').setup()` creates 
      `_G.MiniSurround`. This allows for a simpler usage of plugin 
      functionality: instead of `require('mini.surround')` use `MiniSurround`
      (or manually `:lua MiniSurround.*` in command line); available from
      `v:lua` like `v:lua.MiniSurround`. Considering this, "module" and "Lua
      object" names can be used interchangeably: 'mini.surround' and
      'MiniSurround' will mean the same thing.
    - Each supplied `config` table (after extending with default values) is 
      stored in `config` field of global object. Like `MiniSurround.config`.
    - Values of `config`, which affect runtime activity, can be changed on the
      fly to have effect. For example, `MiniSurround.config.n_lines` can be
      changed during runtime; but changing `MiniSurround.config.mappings` won't
      have any effect (as mappings are created once during `setup()`).
- <Disabling>. Each module's core functionality can be disabled globally or 
  buffer-locally by creating appropriate global or buffer-scoped variables with
  |v:true| value. For example:
    - To disable `MiniSurround` globally run `:let g:minisurround_disable=v:true`.
    - To disable `MiniSurround` for current buffer run `:let b:minisurround_disable=v:true`.
    - To toggle `MiniSurround` globally (disable if enabled, enable if
      disabled) use of Lua is more appropriate:
      `:lua vim.g.minisurround_disable = not vim.g.minisurround_disable`.
- <Highlight groups>. Appearance of module's output is controlled by certain
  highlight group (see |highlight-groups|). To customize them, use |highlight|
  command. Note: currently not many Neovim themes support this plugin's
  highlight groups; fixing this situation is highly appreciated. To see a more
  calibrated look, use |MiniBase16| or plugin's colorscheme `minischeme`.
- <Stability>. Each module upon release is considered to be relatively stable:
  both in terms of setup and functionality. Any non-bugfix
  backward-incompatible change will be released gradually as much as possible.

# List of modules

- |MiniBase16| - fast implementation of base16 theme for manually supplied 
  palette. Has unique palette generator which needs only background and 
  foreground colors.
- |MiniBufremove| - buffer removing (unshow, delete, wipeout) while saving 
  window layout.
- |MiniComment| - fast and familiar per-line code commenting.
- |MiniCompletion| - async (with customizable 'debounce' delay) 'two-stage 
  chain completion': first builtin LSP, then configurable fallback. Also has
  functionality for completion item info and function signature (both in
  floating window appearing after customizable delay).
- |MiniCursorword| - automatic highlighting of word under cursor (displayed 
  after customizable delay).
- |MiniFuzzy| - functions for fast and simple fuzzy matching. It has not only
  functions to perform fuzzy matching of one string to others, but also a
  sorter for |telescope.nvim|.
- |MiniJump| - minimal and fast module for smarter jumping to a single 
  character.
- |MiniMisc| - collection of miscellaneous useful functions. Like `put()` and
  `put_text()` which print Lua objects to command line and current buffer
  respectively.
- |MiniPairs| - autopairs plugin which has minimal defaults and functionality
  to do per-key expression mappings.
- |MiniSessions| - session management (read, write, delete) which works using
  |mksession|.
- |MiniStarter| - minimal, fast, and flexible start screen. Displayed items are
  fully customizable both in terms of what they do and how they look (with
  reasonable defaults). Item selection can be done using prefix query with
  instant visual feedback.
- |MiniStatusline| - minimal and fast statusline. Has ability to use custom 
  content supplied with concise function (using module's provided section 
  functions) along with builtin default. For full experience needs [Nerd 
  font](https://www.nerdfonts.com/), 
  [gitsigns.nvim](https://github.com/lewis6991/gitsigns.nvim) plugin, and 
  [nvim-web-devicons](https://github.com/kyazdani42/nvim-web-devicons) plugin
  (but works without any them).
- |MiniSurround| - fast surround plugin. Add, delete, replace, find, highlight
  surrounding (like pair of parenthesis, quotes, etc.). Has special "function
  call", "tag", and "interactive" surroundings. Supports dot-repeatability,
  textobject, motions.
- |MiniTabline| - minimal tabline which shows listed (see 'buflisted') buffers
  in case of one tab and falls back to default otherwise. For full experience
  needs [nvim-web-devicons](https://github.com/kyazdani42/nvim-web-devicons).
- |MiniTrailspace| - automatic highlighting of trailing whitespace with 
  functionality to remove it.

# Plugin colorscheme

This plugin comes with an official colorscheme named `minischeme`. This is a
|MiniBase16| theme created with faster version of the following Lua code:
`require('mini.base16').setup({palette = palette, name = 'minischeme',
use_cterm = true})` where `palette` is:
- For dark 'background': `require('mini.base16').mini_palette('#112641',
  '#e2e98f', 75)`
- For light 'background': `require('mini.base16').mini_palette('#e2e5ca',
  '#002a83', 75)`

Activate it as a regular |colorscheme|.


================================================================================
                                                      *MiniBase16* *mini.base16*

Custom minimal and fast Lua module which implements
[base16](http://chriskempson.com/projects/base16/) color scheme (with Copyright
(C) 2012 Chris Kempson) adapated for modern Neovim 0.5 Lua plugins. Extra
features:
- Configurable automatic support of cterm colors (see |highlight-cterm|).
- Opinionated palette generator based only on background and foreground colors.

# Setup

This module needs a setup with `require('mini.base16').setup({})` (replace `{}`
with your `config` table). It will create global Lua table `MiniBase16` which
you can use for scripting or manually (with `:lua MiniBase16.*`).

Default `config`:
>
  {
    -- Table with names from `base00` to `base0F` and values being strings of HEX
    -- colors with format "#RRGGBB". NOTE: this should be explicitly supplied in
    -- `setup()`.
    palette = nil,

   -- Whether to support cterm colors. Can be boolean, `nil` (same as `false`),
   -- or table with cterm colors. See `setup()` documentation for more
   -- information.
    use_cterm = nil,
  }
<
Example:
>
  require('mini.base16').setup({
    palette = {
      base00 = '#112641',
      base01 = '#3a475e',
      base02 = '#606b81',
      base03 = '#8691a7',
      base04 = '#d5dc81',
      base05 = '#e2e98f',
      base06 = '#eff69c',
      base07 = '#fcffaa',
      base08 = '#ffcfa0',
      base09 = '#cc7e46',
      base0A = '#46a436',
      base0B = '#9ff895',
      base0C = '#ca6ecf',
      base0D = '#42f7ff',
      base0E = '#ffc4ff',
      base0F = '#00a5c5',
    },
    use_cterm = true,
  })
<
# Notes
1. This module is used for creating plugin's official colorscheme named 
   `minischeme` (see |mini.nvim|).
2. Using `setup()` doesn't actually create a |colorscheme|. It basically 
   creates a coordinated set of |highlight|s. To create your own theme:
    - Put "myscheme.lua" file (name after your chosen theme name) inside any
      "colors" directory reachable from 'runtimepath' ("colors" inside your
      Neovim config directory is usually enough).
    - Inside "myscheme.lua" call `require('mini.base16').setup()` with your 
      palette and only after that set |g:colors_name| to "myscheme".


MiniBase16.setup({config})                                *MiniBase16.setup()*
    Module setup

    Setup is done by applying base16 palette to enable colorscheme. Highlight
    groups make an extended set from original
    [base16-vim](https://github.com/chriskempson/base16-vim/) plugin. It is a
    good idea to have `config.palette` respect the original [styling
    principles](https://github.com/chriskempson/base16/blob/master/styling.md).

    By default only 'gui highlighting' (see |highlight-gui| and
    |termguicolors|) is supported. To support 'cterm highlighting' (see
    |highlight-cterm|) supply `config.use_cterm` argument in one of the
    formats:
    - `true` to auto-generate from `palette` (as closest colors).
    - Table with similar structure to `palette` but having terminal colors 
      (integers from 0 to 255) instead of hex strings.



    Parameters: ~
        {config} (table)  Module config table.

    Usage: ~
        `require('mini.base16').setup({})` (replace `{}` with your `config`
        table; `config.palette` should be a table with colors)


MiniBase16.mini_palette({background}, {foreground}, {accent_chroma}) *MiniBase16.mini_palette()*
    Create 'mini' palette

    Create base16 palette based on the HEX (string '#RRGGBB') colors of main
    background and foreground with optional setting of accent chroma (see
    details).

    # Algorithm design
    - Main operating color space is 
      [CIELCh(uv)](https://en.wikipedia.org/wiki/CIELUV#Cylindrical_representation_(CIELCh))
      which is a cylindrical representation of a perceptually uniform CIELUV 
      color space. It defines color by three values: lightness L (values from 0
      to 100), chroma (positive values), and hue (circular values from 0 to 360
      degress). Useful converting tool: https://www.easyrgb.com/en/convert.php
    - There are four important lightness values: background, foreground, focus 
      (around the middle of background and foreground, leaning towards 
      foreground), and edge (extreme lightness closest to foreground).
    - First four colors have the same chroma and hue as `background` but 
      lightness progresses from background towards focus.
    - Second four colors have the same chroma and hue as `foreground` but 
      lightness progresses from foreground towards edge in such a way that 
      'base05' color is main foreground color.
    - The rest eight colors are accent colors which are created in pairs
        - Each pair has same hue from set of hues 'most different' to 
          background and foreground hues (if respective chorma is positive).
        - All colors have the same chroma equal to `accent_chroma` (if not 
          provided, chroma of foreground is used, as they will appear next to
          each other). Note: this means that in case of low foreground chroma,
          it is a good idea to set `accent_chroma` manually. Values from 30
          (low chorma) to 80 (high chroma) are common.
        - Within pair there is base lightness (equal to foreground lightness)
          and alternative (equal to focus lightness). Base lightness goes to
          colors which will be used more frequently in code: base08
          (variables), base0B (strings), base0D (functions), base0E (keywords).
          How exactly accent colors are mapped to base16 palette is a result of
          trial and error. One rule of thumb was: colors within one hue pair
          should be more often seen next to each other. This is because it is
          easier to distinguish them and seems to be more visually appealing.
          That is why `base0D` and `base0F` have same hues because they usually
          represent functions and delimiter (brackets included).



    Parameters: ~
        {background}    (string)  Background HEX color (formatted as
                                  `#RRGGBB`).
        {foreground}    (string)  Foreground HEX color (formatted as
                                  `#RRGGBB`).
        {accent_chroma} (number)  Optional positive number (usually between 0
                                  and 100). Default: chroma of foreground
                                  color.

    Return: ~
        table: Table with base16 palette.

    Usage: ~
        `local palette = require('mini.base16').mini_palette('#112641',
        '#e2e98f', 75)`
        `require('mini.base16').setup({palette = palette})`


MiniBase16.rgb_palette_to_cterm_palette({palette}) *MiniBase16.rgb_palette_to_cterm_palette()*
    Converts palette with RGB colors to terminal colors

    Useful for caching `use_cterm` variable to increase speed.



    Parameters: ~
        {palette} (table)  Table with base16 palette (same as in
                           `MiniBase16.config.palette`).

    Return: ~
        table: Table with base16 palette using |highlight-cterm|.



================================================================================
                                                *MiniBufremove* *mini.bufremove*

Lua module for minimal buffer removing (unshow, delete, wipeout), which saves
window layout (opposite to builtin Neovim's commands). This is mostly a Lua
implementation of
[bclose.vim](https://vim.fandom.com/wiki/Deleting_a_buffer_without_closing_the_window).
Other alternatives:
- [vim-bbye](https://github.com/moll/vim-bbye)
- [vim-sayonara](https://github.com/mhinz/vim-sayonara)

# Setup

This module doesn't need setup, but it can be done to improve usability. Setup
with `require('mini.bufremove').setup({})` (replace `{}` with your `config`
table). It will create global Lua table `MiniBufremove` which you can use for
scripting or manually (with `:lua MiniBufremove.*`).

Default `config`:
>
  {
    -- Whether to set Vim's settings for buffers (allow hidden buffers)
    set_vim_settings = true,
  }
<
# Notes
1. Which buffer to show in window(s) after its current buffer is removed is 
   decided by the algorithm:
   - If alternate buffer (see |CTRL-^|) is listed (see |buflisted()|), use it.
   - If previous listed buffer (see |bprevious|) is different, use it.
   - Otherwise create a scratch one with `nvim_create_buf(true, true)` and use 
     it.

# Disabling

To disable core functionality, set `g:minibufremove_disable` (globally) or
`b:minibufremove_disable` (for a buffer) to `v:true`.

MiniBufremove.setup({config})                          *MiniBufremove.setup()*
    Module setup



    Parameters: ~
        {config} (table)  Module config table.

    Usage: ~
        `require('mini.bufremove').setup({})` (replace `{}` with your `config`
        table)


MiniBufremove.delete({buf_id}, {force})               *MiniBufremove.delete()*
    Delete buffer `buf_id` with |:bdelete| after unshowing it.



    Parameters: ~
        {buf_id} (number)   Buffer identifier (see |bufnr()|) to use. Default:
                            0 for current.
        {force}  (boolean)  Whether to ignore unsaved changes (using `!`
                            version of command). Default: `false`.

    Return: ~
        boolean: Whether operation was successful.


MiniBufremove.wipeout({buf_id}, {force})             *MiniBufremove.wipeout()*
    Wipeout buffer `buf_id` with |:bwipeout| after unshowing it.



    Parameters: ~
        {buf_id} (number)   Buffer identifier (see |bufnr()|) to use. Default:
                            0 for current.
        {force}  (boolean)  Whether to ignore unsaved changes (using `!`
                            version of command). Default: `false`.

    Return: ~
        boolean: Whether operation was successful.


MiniBufremove.unshow({buf_id})                        *MiniBufremove.unshow()*
    Stop showing buffer `buf_id` in all windows



    Parameters: ~
        {buf_id} (number)  Buffer identifier (see |bufnr()|) to use. Default:
                           0 for current.

    Return: ~
        boolean: Whether operation was successful.


MiniBufremove.unshow_in_window({win_id})    *MiniBufremove.unshow_in_window()*
    Stop showing current buffer of window `win_id`


    Parameters: ~
        {win_id} (number)  Window identifier (see |win_getid()|) to use.
                           Default: 0 for current.

    Return: ~
        boolean: Whether operation was successful.



================================================================================
                                                    *MiniComment* *mini.comment*

Custom minimal and fast Lua module for code commenting. This is basically a
reimplementation of "tpope/vim-commentary". Commenting in Normal mode respects
|count| and is dot-repeatable. Comment structure is inferred from
'commentstring'.

What it doesn't do:
- Block and sub-line comments. This will only support per-line commenting.
- Configurable (from module) comment structure. Modify |commentstring| instead.

# Setup

This module needs a setup with `require('mini.comment').setup({})` (replace
`{}` with your `config` table). It will create global Lua table `MiniComment`
which you can use for scripting or manually (with `:lua MiniComment.*`).

Default `config`:
>
  {
    -- Module mappings. Use `''` (empty string) to disable one.
    mappings = {
      -- Toggle comment (like `gcip` - comment inner paragraph) for both
      -- Normal and Visual modes
      comment = 'gc',

      -- Toggle comment on current line
      comment_line = 'gcc',

      -- Define 'comment' textobject (like `dgc` - delete whole comment block)
      textobject = 'gc',
    }
  }
<
# Disabling

To disable core functionality, set `g:minicomment_disable` (globally) or
`b:minicomment_disable` (for a buffer) to `v:true`.

MiniComment.setup({config})                              *MiniComment.setup()*
    Module setup



    Parameters: ~
        {config} (table)  Module config table.

    Usage: ~
        `require('mini.comment').setup({})` (replace `{}` with your `config`
        table)


MiniComment.operator({mode})                          *MiniComment.operator()*
    Main function to be mapped

    It is meant to be used in expression mappings (see |map-<expr>|) to enable
    dot-repeatability and commenting on range. There is no need to do this
    manually, everything is done inside |MiniComment.setup()|.

    It has a somewhat unintuitive logic (because of how expression mapping with
    dot-repeatability works): it should be called without arguments inside
    expression mapping and with argument when action should be performed.



    Parameters: ~
        {mode} (string)  Optional string with 'operatorfunc' mode (see |g@|).

    Return: ~
        string: 'g@' if called without argument, '' otherwise (but after
        performing action).


MiniComment.toggle_lines({line_start}, {line_end}) *MiniComment.toggle_lines()*
    Toggle comments between two line numbers

    It uncomments if lines are comment (every line is a comment) and comments
    otherwise. It respects indentation and doesn't insert trailing whitespace.
    Toggle commenting not in visual mode is also dot-repeatable and respects
    |count|.

    # Notes
    1. Currently call to this function will remove marks inside written range. 
       Use |lockmarks| to preserve marks.



    Parameters: ~
        {line_start} (number)  Start line number.
        {line_end}   (number)  End line number.


MiniComment.textobject()                            *MiniComment.textobject()*
    Comment textobject This selects all commented lines adjacent to cursor line
    (if it itself is commented). Designed to be used with operator mode
    mappings (see |mapmode-o|).




================================================================================
                                              *MiniCompletion* *mini.completion*

Custom somewhat minimal autocompletion Lua plugin. Key design ideas:
- Have an async (with customizable 'debounce' delay) 'two-stage chain 
  completion': first try to get completion items from LSP client (if set up)
  and if no result, fallback to custom action.
- Managing completion is done as much with Neovim's built-in tools as possible.

Features:
- Two-stage chain completion:
    - First stage is an LSP completion implemented via 
      |MiniCompletion.completefunc_lsp()|. It should be set up as either 
      |completefunc| or |omnifunc|. It tries to get completion items from LSP
      client (via 'textDocument/completion' request). Custom preprocessing of 
      response items is possible (with 
      `MiniCompletion.config.lsp_completion.process_items`), for example with
      fuzzy matching. By default items which are not snippets and directly
      start with completed word are kept and sorted according to LSP
      specification.
    - If first stage is not set up or resulted into no candidates, fallback 
      action is executed. The most tested actions are Neovim's built-in insert
      completion (see |ins-completion|).
- Automatic display in floating window of completion item info and signature 
  help (with highlighting of active parameter if LSP server provides such 
  information). After opening, window for signature help is fixed and is closed
  when there is nothing to show, text is different or when leaving Insert mode.
- Automatic actions are done after some configurable amount of delay. This 
  reduces computational load and allows fast typing (completion and signature
  help) and item selection (item info)
- Autoactions are triggered on Neovim's built-in events.
- User can force two-stage completion via |MiniCompletion.complete_twostage()|
  (by default is mapped to `<C-Space>`) or fallback completion via 
  |MiniCompletion.complete_fallback()| (maped to `<M-Space>`).

What it doesn't do:
- Snippet expansion.
- Many configurable sources.

# Setup

This module needs a setup with `require('mini.completion').setup({})` (replace
`{}` with your `config` table). It will create global Lua table
`MiniCompletion` which you can use for scripting or manually (with `:lua
MiniCompletion.*`).

Default `config`:
>
  {
    -- Delay (debounce type, in ms) between certain Neovim event and action.
    -- This can be used to (virtually) disable certain automatic actions by
    -- setting very high delay time (like 10^7).
    delay = {completion = 100, info = 100, signature = 50},

    -- Maximum dimensions of floating windows for certain actions. Action entry
    -- should be a table with 'height' and 'width' fields.
    window_dimensions = {
      info = {height = 25, width = 80},
      signature = {height = 25, width = 80}
    },

    -- Way of how module does LSP completion:
    -- - `source_func` should be one of 'completefunc' or 'omnifunc'.
    -- - `auto_setup` should be boolean indicating if LSP completion is set up on
    --   every `BufEnter` event.
    -- - `process_items` should be a function which takes LSP
    --   'textDocument/completion' response items and word to complete. Its
    --   output should be a table of the same nature as input items. The most
    --   common use-cases are custom filtering and sorting. You can use
    --   default `process_items` as `MiniCompletion.default_process_items()`.
    lsp_completion = {
      source_func = 'completefunc',
      auto_setup = true,
      process_items = --<function: filters 'not snippets' by prefix and sorts by LSP specification>,
    },

    -- Fallback action. It will always be run in Insert mode. To use Neovim's
    -- built-in completion (see `:h ins-completion`), supply its mapping as
    -- string. For example, to use 'whole lines' completion, supply '<C-x><C-l>'.
    fallback_action = --<function equivalent to '<C-n>' completion>,

    -- Module mappings. Use `''` (empty string) to disable one. Some of them
    -- might conflict with system mappings.
    mappings = {
      force_twostep  = '<C-Space>', -- Force two-step completion
      force_fallback = '<A-Space>'  -- Force fallback completion
    }

    -- Whether to set Vim's settings for better experience (modifies
    -- `shortmess` and `completeopt`)
    set_vim_settings = true
  }
<
# Notes
- More appropriate, albeit slightly advanced, LSP completion setup is to set it
  not on every `BufEnter` event (default), but on every attach of LSP client.
  To do that:
    - Use in initial config: `lsp_completion = {source_func = 'omnifunc', 
      auto_setup = false}`.
    - In `on_attach()` of every LSP client set 'omnifunc' option to exactly 
      `v:lua.MiniCompletion.completefunc_lsp`.

# Comparisons

- 'nvim-cmp':
    - More complex design which allows multiple sources each in form of 
      separate plugin. `MiniCompletion` has two built in: LSP and fallback.
    - Supports snippet expansion.
    - Doesn't have customizable delays for basic actions.
    - Doesn't allow fallback action.
    - Doesn't provide signature help.

# Helpful key mappings

To use `<Tab>` and `<S-Tab>` for navigation through completion list, make these
key mappings:
`vim.api.nvim_set_keymap('i', [[<Tab>]],   [[pumvisible() ? "\<C-n>" : "\<Tab>"]],   { noremap = true, expr = true })`
`vim.api.nvim_set_keymap('i', [[<S-Tab>]], [[pumvisible() ? "\<C-p>" : "\<S-Tab>"]], { noremap = true, expr = true })`

# Highlight groups

1. `MiniCompletionActiveParameter` - highlighting of signature active
   parameter. Default: plain underline.

To change any highlight group, modify it directly with |:highlight|.

# Disabling

To disable, set `g:minicompletion_disable` (globally) or
`b:minicompletion_disable` (for a buffer) to `v:true`.

MiniCompletion.setup({config})                        *MiniCompletion.setup()*
    Module setup



    Parameters: ~
        {config} (table)  Module config table.

    Usage: ~
        `require('mini.completion').setup({})` (replace `{}` with your
        `config` table)


MiniCompletion.auto_completion()            *MiniCompletion.auto_completion()*
    Auto completion

    Designed to be used with |autocmd|. No need to use it directly, everything
    is setup in |MiniCompletion.setup|.



MiniCompletion.complete_twostage({fallback}, {force}) *MiniCompletion.complete_twostage()*
    Run two-stage completion



    Parameters: ~
        {fallback} (boolean)  Whether to use fallback completion.
        {force}    (boolean)  Whether to force update of completion popup.


MiniCompletion.complete_fallback()        *MiniCompletion.complete_fallback()*
    Run fallback completion



MiniCompletion.auto_info()                        *MiniCompletion.auto_info()*
    Auto completion entry information

    Designed to be used with |autocmd|. No need to use it directly, everything
    is setup in |MiniCompletion.setup|.



MiniCompletion.auto_signature()              *MiniCompletion.auto_signature()*
    Auto function signature

    Designed to be used with |autocmd|. No need to use it directly, everything
    is setup in |MiniCompletion.setup|.



MiniCompletion.stop({actions})                         *MiniCompletion.stop()*
    Stop actions

    This stops currently active (because of module delay or LSP answer delay)
    actions.

    Designed to be used with |autocmd|. No need to use it directly, everything
    is setup in |MiniCompletion.setup|.



    Parameters: ~
        {actions} (table)  Array containing any of 'completion', 'info', or
                           'signature' string.


MiniCompletion.on_text_changed_i()        *MiniCompletion.on_text_changed_i()*
    Act on every |TextChangedI|



MiniCompletion.on_text_changed_p()        *MiniCompletion.on_text_changed_p()*
    Act on every |TextChangedP|



MiniCompletion.completefunc_lsp()          *MiniCompletion.completefunc_lsp()*
    Module's |complete-function|

    This is the main function which enables two-stage completion. It should be
    set as one of |completefunc| or |omnifunc|.

    No need to use it directly, everything is setup in |MiniCompletion.setup|.



MiniCompletion.default_process_items() *MiniCompletion.default_process_items()*
    Default `MiniCompletion.config.lsp_completion.process_items`.




================================================================================
                                              *MiniCursorword* *mini.cursorword*

Custom minimal and fast module for autohighlighting word under cursor with
customizable delay. It is triggered only if current cursor character is a
|[:keyword:]|. "Word under cursor" is meant as in Vim's |<cword>|: something
user would get as 'iw' text object. Highlighting stops in insert and terminal
modes.

# Setup

This module needs a setup with `require('mini.cursorword').setup({})` (replace
`{}` with your `config` table). It will create global Lua table
`MiniCursorword` which you can use for scripting or manually (with `:lua
MiniCursorword.*`).

Default `config`:
>
  {
   -- Delay (in ms) between when cursor moved and when highlighting appeared
   delay = 100,
  }
<
# Highlight groups

1. `MiniCursorword` - highlight group of cursor word. Default: plain underline.

To change any highlight group, modify it directly with |:highlight|.

# Disabling

To disable core functionality, set `g:minicursorword_disable` (globally) or
`b:minicursorword_disable` (for a buffer) to `v:true`. Note: after disabling
there might be highlighting left; it will be removed after next highlighting
update.

MiniCursorword.setup({config})                        *MiniCursorword.setup()*
    Module setup



    Parameters: ~
        {config} (table)  Module config table.

    Usage: ~
        `require('mini.cursorword').setup({})` (replace `{}` with your
        `config` table)


MiniCursorword.auto_highlight()              *MiniCursorword.auto_highlight()*
    Auto highlight word under cursor

    Designed to be used with |autocmd|. No need to use it directly, everything
    is setup in |MiniCursorword.setup|.



MiniCursorword.auto_unhighlight()          *MiniCursorword.auto_unhighlight()*
    Auto unhighlight word under cursor

    Designed to be used with |autocmd|. No need to use it directly, everything
    is setup in |MiniCursorword.setup|.




================================================================================
                                                        *MiniFuzzy* *mini.fuzzy*

Lua module which implements minimal and fast fuzzy matching.

# Setup

This module doesn't need setup, but it can be done to improve usability. Setup
with `require('mini.fuzzy').setup({})` (replace `{}` with your `config` table).
It will create global Lua table `MiniFuzzy` which you can use for scripting or
manually (with `:lua MiniFuzzy.*`).

Default `config`:
>
  {
    -- Maximum allowed value of match features (width and first match). All
    -- feature values greater than cutoff can be considered "equally bad".
    cutoff = 100,
  }
<
# Notes
1. Currently there is no explicit design to work with multibyte symbols, but
   simple examples should work.
2. Smart case is used: case insensitive if input word (which is usually a user
   input) is all lower ase. Case sensitive otherwise.

# Algorithm design

General design uses only width of found match and index of first letter match.
No special characters or positions (like in fzy and fzf) are used.

Given input `word` and target `candidate`:
- The goal is to find matching between `word`'s letters and letters in 
  `candidate`, which minimizes certain score. It is assumed that order of 
  letters in `word` and those matched in `candidate` should be the same.
- Matching is represented by matched positions: an array `positions` of 
  integers with length equal to number of letter in `word`. The following 
  should be always true in case of a match: `candidate`'s letter at index 
  `positions[i]` is letters[i]` for all valid `i`.
- Matched positions are evaluated based only on two features: their width 
  (number of indexes between first and last positions) and first match (index
  of first letter match). There is a global setting `cutoff` for which all
  feature values greater than it can be considered "equally bad".
- Score of matched positions is computed with following explicit formula: 
  `cutoff * min(width, cutoff) + min(first, cutoff)`. It is designed to be 
  equivalent to first comparing widths (lower is better) and then comparing 
  first match (lower is better). For example, if `word = 'time'`:
    - '_time' (width 4) will have a better match than 't_ime' (width 5).
    - 'time_a' (width 4, first 1) will have a better match than 'a_time' (width
      4, first 3).
- Final matched positions are those which minimize score among all possible 
  matched positions of `word` and `candidate`.

MiniFuzzy.setup({config})                                  *MiniFuzzy.setup()*
    Module setup



    Parameters: ~
        {config} (table)  Module config table.

    Usage: ~
        `require('mini.fuzzy').setup({})` (replace `{}` with your `config`
        table)


MiniFuzzy.match({word}, {candidate})                       *MiniFuzzy.match()*
    Compute match data of input `word` and `candidate` strings

    It tries to find best match for input string `word` (usually user input)
    and string `candidate`. Returns table with elements:
    - `positions` - array with letter indexes inside `candidate` which matched
      to corresponding letters in `word`. Or `nil` if no match.
    - `score` - positive number representing how good the match is (lower is 
      better). Or `-1` if no match.



    Parameters: ~
        {word}      (string)  Input word (usually user input).
        {candidate} (string)  Target word (usually with which matching is
                              done).

    Return: ~
        table: Table with matching information (see function's description).


MiniFuzzy.filtersort({word}, {candidate_array})       *MiniFuzzy.filtersort()*
    Filter string array

    This leaves only those elements of input array which matched with `word`
    and sorts from best to worst matches (based on score and index in original
    array, both lower is better).



    Parameters: ~
        {word}            (string)  String which will be searched.
        {candidate_array} (table)   Lua array of strings inside which word
                                    will be searched.

    Return: ~
        tuple: Arrays of matched candidates and their indexes in original
        input.


MiniFuzzy.process_lsp_items({items}, {base})   *MiniFuzzy.process_lsp_items()*
    Fuzzy matching for |MiniCompletion.lsp_completion.process_items|



    Parameters: ~
        {items} (table)   Lua array with LSP 'textDocument/completion'
                          response items.
        {base}  (string)  Word to complete.


MiniFuzzy.get_telescope_sorter({opts})      *MiniFuzzy.get_telescope_sorter()*
    Custom getter for `telescope.nvim` sorter

    Designed to be used as value for |telescope.defaults.file_sorter| and
    |telescope.defaults.generic_sorter| inside `setup()` call.



    Parameters: ~
        {opts} (table)  Options (currently not used).

    Usage: ~
        `require('telescope').setup({default = {generic_sorter =
        require('mini.fuzzy').get_telescope_sorter}})`



================================================================================
                                                          *MiniJump* *mini.jump*

Minimal and fast module for smarter jumping to a single character. Inspired by
'rhysd/clever-f.vim'.

Features:
- Extend f, F, t, T to work on multiple lines.
- Repeat jump by pressing f, F, t, T again. It is reset when cursor moved as a
  result of not jumping.
- Highlight (after customizable delay) of all possible target characters.
- Normal, Visual, and Operator-pending (with full dot-repeat) modes are 
  supported.

# Setup

This module needs a setup with `require('mini.jump').setup({})` (replace `{}`
with your `config` table). It will create global Lua table `MiniJump` which you
can use for scripting or manually (with `:lua MiniJump.*`).

Default `config`:
>
  {
    -- Mappings. Use `''` (empty string) to disable one.
    mappings = {
      forward = 'f',
      backward = 'F',
      forward_till = 't',
      backward_till = 'T',
      repeat_jump = ';',
    },

    -- Delay (in ms) between jump and highlighting all possible jumps. Set to a
    -- very big number (like 10^7) to virtually disable highlighting.
    highlight_delay = 250,
  }
<
#Highlight groups

- `MiniJump` - all possible cursor positions.

# Disabling

To disable core functionality, set `g:minijump_disable` (globally) or
`b:minijump_disable` (for a buffer) to `v:true`.

MiniJump.setup({config})                                    *MiniJump.setup()*
    Module setup



    Parameters: ~
        {config} (table)  Module config table.

    Usage: ~
        `require('mini.jump').setup({})` (replace `{}` with your `config`
        table)


MiniJump.jump({target}, {backward}, {till}, {n_times})       *MiniJump.jump()*
    Jump to target

    Takes a string and jumps to its first occurrence in desrired direction.



    Parameters: ~
        {target}   (string)   The string to jump to.
        {backward} (boolean)  Whether to jump backward. Default: latest used
                              value or `false`.
        {till}     (boolean)  Whether to jump just before/after the match
                              instead of exactly on target. Also ignore
                              matches that don't have anything before/after
                              them. Default: latest used value or `false`.
        {n_times}  (number)   Number of times to perform a jump. Default:
                              latest used value or 1.


MiniJump.smart_jump({backward}, {till})                *MiniJump.smart_jump()*
    Make smart jump

    If the last movement was a jump, perform another jump with the same target.
    Otherwise, wait for a target input (via |getchar()|). Respects |v:count|.



    Parameters: ~
        {backward} (boolean)  Whether to jump backward. Default: latest used
                              value or `false`.
        {till}     (boolean)  Whether to jump just before/after the match
                              instead of exactly on target. Also ignore
                              matches that don't have anything before/after
                              them. Default: latest used value or `false`.


MiniJump.expr_jump({backward}, {till})                  *MiniJump.expr_jump()*
    Make expression jump

    Cache information about the jump and return string with command to perform
    jump. Designed to be used inside Operator-pending mapping (see
    |omap-info|). Always asks for target (via |getchar()|). Respects |v:count|.



    Parameters: ~
        {backward} (boolean)  Whether to jump backward. Default: latest used
                              value or `false`.
        {till}     (boolean)  Whether to jump just before/after the match
                              instead of exactly on target. Also ignore
                              matches that don't have anything before/after
                              them. Default: latest used value or `false`.


MiniJump.stop_jumping()                              *MiniJump.stop_jumping()*
    Stop jumping

    Removes highlights (if any) and forces the next smart jump to prompt for
    the target. Automatically called on appropriate Neovim |events|.



MiniJump.on_cursormoved()                          *MiniJump.on_cursormoved()*
    Act on |CursorMoved|.




================================================================================
                                                          *MiniMisc* *mini.misc*

Lua module with miscellaneous useful functions (can be used independently).

# Setup

This module doesn't need setup, but it can be done to improve usability. Setup
with `require('mini.misc').setup({})` (replace `{}` with your `config` table).
It will create global Lua table `MiniMisc` which you can use for scripting or
manually (with `:lua MiniMisc.*`).

Default `config`:
>
  {
    -- Array of fields to make global (to be used as independent variables)
    make_global = { 'put', 'put_text' },
  }
<

MiniMisc.setup({config})                                    *MiniMisc.setup()*
    Module setup



    Parameters: ~
        {config} (table)  Module config table.

    Usage: ~
        `require('mini.misc').setup({})` (replace `{}` with your `config`
        table)


MiniMisc.bench_time({f}, {n}, {...})                   *MiniMisc.bench_time()*
    Execute `f` several times and time how long it took



    Parameters: ~
        {f}   (function)  Function which execution to benchmark.
        {n}   (number)    Number of times to execute `f(...)`. Default: 1.
        {...} (vararg)    Arguments when calling `f`.

    Return: ~
        tuple: Table with durations (in seconds; up to microseconds) and
        output of (last) function execution.


MiniMisc.get_gutter_width({win_id})              *MiniMisc.get_gutter_width()*
    Compute width of gutter (info column on the left of the window)



    Parameters: ~
        {win_id} (number)  Window identifier (see |win_getid()|) for which
                           gutter width is computed. Default: 0 for current.


MiniMisc.put({...})                                           *MiniMisc.put()*
    Print Lua objects in command line



    Parameters: ~
        {...} (vararg)  Any number of objects to be printed each on separate
                        line.


MiniMisc.put_text({...})                                 *MiniMisc.put_text()*
    Print Lua objects in current buffer



    Parameters: ~
        {...} (vararg)  Any number of objects to be printed each on separate
                        line.


MiniMisc.resize_window({win_id}, {text_width})      *MiniMisc.resize_window()*
    Resize window to have exact number of editable columns



    Parameters: ~
        {win_id}     (number)  Window identifier (see |win_getid()|) to be
                               resized. Default: 0 for current.
        {text_width} (number)  Number of editable columns resized window will
                               display. Default: first element of
                               'colorcolumn' or otherwise 'textwidth' (using
                               screen width as its default but not more than
                               79).


MiniMisc.stat_summary({t})                           *MiniMisc.stat_summary()*
    Compute summary statistics of numerical array

    This might be useful to compute summary of time benchmarking with
    |MiniMisc.bench_time|.



    Parameters: ~
        {t} (table)  Array (table suitable for `ipairs`) of numbers.

    Return: ~
        table: Table with summary values under following keys (may be extended
        in the future): `maximum`, `mean`, `median`, `minimum`, `n` (number of
        elements), `sd` (sample standard deviation).


MiniMisc.tbl_head({t}, {n})                              *MiniMisc.tbl_head()*
    Return "first" elements of table as decided by `pairs`

    Note: order of elements might vary.



    Parameters: ~
        {t} (table)
        {n} (number)  Maximum number of first elements. Default: 5.

    Return: ~
        table: Table with at most `n` first elements of `t` (with same keys).


MiniMisc.tbl_tail({t}, {n})                              *MiniMisc.tbl_tail()*
    Return "last" elements of table as decided by `pairs`

    This function makes two passes through elements of `t`:
    - First to count number of elements.
    - Second to construct result.

    Note: order of elements might vary.



    Parameters: ~
        {t} (table)
        {n} (number)  Maximum number of last elements. Default: 5.

    Return: ~
        table: Table with at most `n` last elements of `t` (with same keys).


MiniMisc.use_nested_comments({buf_id})        *MiniMisc.use_nested_comments()*
    Add possibility of nested comment leader.

    This works by parsing 'commentstring' buffer option, extracting
    non-whitespace comment leader (symbols on the left of commented line), and
    locally modifying 'comments' option (by prepending `n:<leader>`). Does
    nothing if 'commentstring' is empty or has comment symbols both in front
    and back (like "/*%s*/").

    Nested comment leader added with this function is useful for formatting
    nested comments. For example, have in Lua "first-level" comments with '--'
    and "second-level" comments with '----'. With nested comment leader second
    type can be formatted with `gq` in the same way as first one.

    Recommended usage is with |autocmd|:
    `autocmd BufEnter * lua pcall(require('mini.misc').use_nested_comments)`

    Note: for most filetypes 'commentstring' option is added only when buffer
    with this filetype is entered, so using non-current `buf_id` can not lead
    to desired effect.



    Parameters: ~
        {buf_id} (number)  Buffer identifier (see |bufnr()|) in which function
                           will operate. Default: 0 for current.


MiniMisc.zoom({buf_id}, {config})                            *MiniMisc.zoom()*
    Zoom in and out of a buffer, making it full screen in a floating window

    This function is useful when working with multiple windows but temporarily
    needing to zoom into one to see more of the code from that buffer. Call it
    again (without arguments) to zoom out.



    Parameters: ~
        {buf_id} (number)  Buffer identifier (see |bufnr()|) to be zoomed.
                           Default: 0 for current.
        {config} (table)   Optional config for window (as for
                           |nvim_open_win()|).



================================================================================
                                                        *MiniPairs* *mini.pairs*

Custom minimal and fast autopairs Lua module. It provides functionality to work
with 'paired' characters conditional on cursor's neighborhood (two characters
to its left and right). Its usage should be through making appropriate mappings
using |MiniPairs.map| or in |MiniPairs.setup| (for global mapping),
|MiniPairs.map_buf| (for buffer mapping). Pairs get automatically registered to
be recognized by `<BS>` and `<CR>`.

What it doesn't do:
- It doesn't support multiple characters as "open" and "close" symbols. Use 
  snippets for that.
- It doesn't support dependency on filetype. Use |i_CTRL-V| to insert single
  symbol or `autocmd` command or 'after/ftplugin' approach to:
    - `lua MiniPairs.map_buf(0, 'i', <*>, <pair_info>)` : make new mapping for
      '<*>' in current buffer.
    - `lua MiniPairs.unmap_buf(0, 'i', <*>, <pair>)`: unmap key `<*>` while 
      unregistering `<pair>` pair in current buffer.
    - Disable module for buffer (see 'Disabling' section).

# Setup

This module needs a setup with `require('mini.pairs').setup({})` (replace `{}`
with your `config` table). It will create global Lua table `MiniPairs` which
you can use for scripting or manually (with `:lua MiniPairs.*`).

Default `config`:
>
  {
    -- In which modes mappings from this `config` should be created
    modes = {insert = true, command = false, terminal = false}

    -- Global mappings. Each right hand side should be a pair information, a
    -- table with at least these fields (see more in |MiniPairs.map|):
    -- - `action` - one of 'open', 'close', 'closeopen'.
    -- - `pair` - two character string for pair to be used.
    -- By default pair is not inserted after `\`, quotes are not recognized by
    -- `<CR>`, `'` does not insert pair after a letter.
    -- Only parts of the tables can be tweaked (others will use these defaults).
    mappings = {
      ['('] = { action = 'open', pair = '()', neigh_pattern = '[^\\].' },
      ['['] = { action = 'open', pair = '[]', neigh_pattern = '[^\\].' },
      ['{'] = { action = 'open', pair = '{}', neigh_pattern = '[^\\].' },

      [')'] = { action = 'close', pair = '()', neigh_pattern = '[^\\].' },
      [']'] = { action = 'close', pair = '[]', neigh_pattern = '[^\\].' },
      ['}'] = { action = 'close', pair = '{}', neigh_pattern = '[^\\].' },

      ['"'] = { action = 'closeopen', pair = '""', neigh_pattern = '[^\\].', register = { cr = false } },
      ["'"] = { action = 'closeopen', pair = "''", neigh_pattern = '[^%a\\].', register = { cr = false } },
      ['`'] = { action = 'closeopen', pair = '``', neigh_pattern = '[^\\].', register = { cr = false } },
    },
  }
<

# Example mappings

- Register quotes inside `config` of |MiniPairs.setup|:
  `mappings = {`
  `  ['"'] = { register = { cr = true } },`
  `  ["'"] = { register = { cr = true } },`
  `}`
- Insert `<>` pair if `<` is typed as first character in line, don't register for `<CR>`:
  `lua MiniPairs.map('i', '<', { action = 'open', pair = '<>', neigh_pattern = '\r.', register = { cr = false } })`
  `lua MiniPairs.map('i', '>', { action = 'close', pair = '<>', register = { cr = false } })`
- Create symmetrical `$$` pair only in Tex files:
  `au FileType tex lua MiniPairs.map_buf(0, 'i', '$', {action = 'closeopen', pair = '$$'})`

# Notes
- Make sure to make proper mapping of `<CR>` in order to support completion 
  plugin of your choice.
- Having mapping in terminal mode can conflict with:
    - Autopairing capabilities of interpretators (`ipython`, `radian`).
    - Vim mode of terminal itself.

# Disabling

To disable, set `g:minipairs_disable` (globally) or `b:minipairs_disable` (for
a buffer) to `v:true`.

MiniPairs.setup({config})                                  *MiniPairs.setup()*
    Module setup



    Parameters: ~
        {config} (table)  Module config table.

    Usage: ~
        `require('mini.completion').setup({})` (replace `{}` with your
        `config` table)


MiniPairs.map({mode}, {lhs}, {pair_info}, {opts})            *MiniPairs.map()*
    Make global mapping

    This is similar to |nvim_set_keymap()| but instead of right hand side of
    mapping (as string) it expects table with pair information:
    - `action` - one of 'open' (for |MiniPairs.open|), 'close' (for 
      |MiniPairs.close|), or 'closeopen' (for |MiniPairs.closeopen|).
    - `pair` - two character string to be used as argument for action function.
    - `neigh_pattern` - optional 'two character' neighborhood pattern to be 
      used as argument for action function. Default: '..' (no restriction from 
      neighborhood).
    - `register` - optional table with information about whether this pair 
      should be recognized by `<BS>` (in |MiniPairs.bs|) and/or `<CR>` (in 
      |MiniPairs.cr|). Should have boolean elements `bs` and `cr` which are 
      both `true` by default (if not overriden explicitly).

    Using this function instead of |nvim_set_keymap()| allows automatic
    registration of pairs which will be recognized by `<BS>` and `<CR>`.



    Parameters: ~
        {mode}      (string)  `mode` for |nvim_set_keymap()|.
        {lhs}       (string)  `lhs` for |nvim_set_keymap()|.
        {pair_info} (table)   Table with pair information.
        {opts}      (table)   Optional table `opts` for |nvim_set_keymap()|.
                              Elements `expr` and `noremap` won't be
                              recognized (`true` by default).


MiniPairs.map_buf({mode}, {lhs}, {pair_info}, {opts})    *MiniPairs.map_buf()*
    Make buffer mapping

    This is similar to |nvim_buf_set_keymap()| but instead of string right hand
    side of mapping it expects table with pair information similar to one in
    |MiniPairs.map|.

    Using this function instead of |nvim_buf_set_keymap()| allows automatic
    registration of pairs which will be recognized by `<BS>` and `<CR>`.



    Parameters: ~
        {mode}      (string)  `mode` for |nvim_buf_set_keymap()|.
        {lhs}       (string)  `lhs` for |nvim_buf_set_keymap()|.
        {pair_info} (table)   Table with pair information.
        {opts}      (table)   Optional table `opts` for
                              |nvim_buf_set_keymap()|. Elements `expr` and
                              `noremap` won't be recognized (`true` by
                              default).


MiniPairs.unmap({mode}, {lhs}, {pair})                     *MiniPairs.unmap()*
    Remove global mapping

    Uses |nvim_del_keymap()| together with unregistering supplied `pair`.



    Parameters: ~
        {mode} (string)  `mode` for |nvim_del_keymap()|.
        {lhs}  (string)  `lhs` for |nvim_del_keymap()|.
        {pair} (string)  pair which should be unregistered. Supply `''` to not
                         unregister pair.


MiniPairs.unmap_buf({mode}, {lhs}, {pair})             *MiniPairs.unmap_buf()*
    Remove buffer mapping

    Uses |nvim_buf_del_keymap()| together with unregistering supplied `pair`.



    Parameters: ~
        {mode} (string)  `mode` for |nvim_buf_del_keymap()|.
        {lhs}  (string)  `lhs` for |nvim_buf_del_keymap()|.
        {pair} (string)  pair which should be unregistered. Supply `''` to not
                         unregister pair.


MiniPairs.open({pair}, {neigh_pattern})                     *MiniPairs.open()*
    Process 'open' symbols

    Used as |map-expr| mapping for 'open' symbols in asymmetric pair ('(', '[',
    etc.). If neighborhood doesn't match supplied pattern, function results
    into 'open' symbol. Otherwise, it pastes whole pair and moves inside pair
    with |<Left>|.

    Used inside |MiniPairs.map| and |MiniPairs.map_buf| for an actual mapping.



    Parameters: ~
        {pair}          (string)  String with two characters representing
                                  pair.
        {neigh_pattern} (string)  Pattern for two neighborhood characters
                                  ("\r" line start, "\n" - line end).


MiniPairs.close({pair}, {neigh_pattern})                   *MiniPairs.close()*
    Process 'close' symbols

    Used as |map-expr| mapping for 'close' symbols in asymmetric pair (')',
    ']', etc.). If neighborhood doesn't match supplied pattern, function
    results into 'close' symbol. Otherwise it jumps over symbol to the right of
    cursor (with |<Right>|) if it is equal to 'close' one and inserts it
    otherwise.

    Used inside |MiniPairs.map| and |MiniPairs.map_buf| for an actual mapping.



    Parameters: ~
        {pair}          (string)  String with two characters representing
                                  pair.
        {neigh_pattern} (string)  Pattern for two neighborhood characters
                                  ("\r" line start, "\n" - line end).


MiniPairs.closeopen({pair}, {neigh_pattern})           *MiniPairs.closeopen()*
    Process 'closeopen' symbols

    Used as |map-expr| mapping for 'symmetrical' symbols (from pairs '""',
    '\'\'', '``'). It tries to perform 'closeopen action': move over right
    character (with |<Right>|) if it is equal to second character from pair or
    conditionally paste pair otherwise (with |MiniPairs.open()|).

    Used inside |MiniPairs.map| and |MiniPairs.map_buf| for an actual mapping.



    Parameters: ~
        {pair}          (string)  String with two characters representing
                                  pair.
        {neigh_pattern} (string)  Pattern for two neighborhood characters
                                  ("\r" line start, "\n" - line end).


MiniPairs.bs()                                                *MiniPairs.bs()*
    Process |<BS>|

    Used as |map-expr| mapping for `<BS>`. It removes whole pair (via
    `<BS><Del>`) if neighborhood is equal to a whole pair recognized for
    current buffer. Pair is recognized for current buffer if it is registered
    for global or current buffer mapping. Pair is registered as a result of
    calling |MiniPairs.map| or |MiniPairs.map_buf|.

    Mapped by default inside |MiniPairs.setup|.



MiniPairs.cr()                                                *MiniPairs.cr()*
    Process |i_<CR>|

    Used as |map-expr| mapping for `<CR>` in insert mode. It puts "close"
    symbol on next line (via `<CR><C-o>O`) if neighborhood is equal to a whole
    pair recognized for current buffer. Pair is recognized for current buffer
    if it is registered for global or current buffer mapping. Pair is
    registered as a result of calling |MiniPairs.map| or |MiniPairs.map_buf|.

    Mapped by default inside |MiniPairs.setup|.




================================================================================
                                                  *MiniSessions* *mini.sessions*

Lua module for minimal session management (read, write, delete), which works
using |mksession| (meaning 'sessionoptions' is fully respected). This is
intended as a drop-in Lua replacement for session management part of
[mhinz/vim-startify](https://github.com/mhinz/vim-startify) (works out of the
box with sessions created by it).

Key design ideas:
- There is a (configurable) directory. Its readable files (searched with 
  |globpath|) represent sessions (result of applying |mksession|). All these
  session files are detected during `MiniSessions.setup()` with session names
  being file names (including their possible extension).
- Store information about detected sessions in separate table 
  (|MiniSessions.detected|) and operate only on it. Meaning if this information
  changes, there will be no effect until next detection.

Features:
- Autoread latest session if Neovim was called without intention anything to
  show something else.
- Autowrite current session before quitting Neovim.
- Configurable severity level of all actions.

# Setup

This module needs a setup with `require('mini.sessions').setup({})` (replace
`{}` with your `config` table). It will create global Lua table `MiniSessions`
which you can use for scripting or manually (with `:lua MiniSessions.*`).

Default `config`:
>
  {
    -- Whether to autoread latest session if Neovim was called without file arguments
    autoread = false,

    -- Whether to write current session before quitting Neovim
    autowrite = true,

    -- Directory where sessions are stored
    directory = --<"session" subdirectory of user data directory from |stdpath()|>,

    -- Whether to force possibly harmful actions (meaning depends on function)
    force = { read = false, write = true, delete = false },
  }
<
# Disabling

To disable core functionality, set `g:minisessions_disable` (globally) or
`b:minisessions_disable` (for a buffer) to `v:true`.

MiniSessions.detected                                  *MiniSessions.detected*
    Table of detected sessions Keys represent session name. Values are tables
    with session information that currently has these fields (but subject to
    change):

    Fields: ~
        {modify_time} (number)  modification time (see |getftime|) of session
                                file.
        {path}        (string)  full path to session file.


MiniSessions.setup({config})                            *MiniSessions.setup()*
    Module setup



    Parameters: ~
        {config} (table)  Module config table.

    Usage: ~
        `require('mini.sessions').setup({})` (replace `{}` with your `config`
        table)


MiniSessions.read({session_name}, {force})               *MiniSessions.read()*
    Read detected session

    What it does:
    - Delete all current buffers with |bwipeout|. This is needed to correctly 
      restore buffers from target session. If `force` is not `true`, checks 
      beforehand for unsaved buffers and stops if there is any.
    - Source session with supplied name.



    Parameters: ~
        {session_name} (string)   Name of detected session file to read.
                                  Default: `nil` for latest session (see
                                  |MiniSessions.get_latest|).
        {force}        (boolean)  Whether to delete unsaved buffers. Default:
                                  `MiniSessions.config.force.read`.


MiniSessions.write({session_name}, {force})             *MiniSessions.write()*
    Write session

    What it does:
    - Check if file for supplied session name already exists. If it does and 
      `force` is not `true`, then stop.
    - Write session with |mksession| to a file named `session_name` inside 
      `MiniSessions.config.directory`.



    Parameters: ~
        {session_name} (string)   Name of session file to write. Default:
                                  `nil` for current session.
        {force}        (boolean)  Whether to ignore existence of session file.
                                  Default: `MiniSessions.config.force.write`.


MiniSessions.delete({session_name}, {force})           *MiniSessions.delete()*
    Delete detected session

    What it does:
    - Check if session name is a current one. If yes and `force` is not `true`,
      then stop.
    - Delete session.



    Parameters: ~
        {session_name} (string)   Name of session file to delete. Default:
                                  `nil` for current session.
        {force}        (boolean)  Whether to ignore deletion of current
                                  session. Default:
                                  `MiniSessions.config.force.delete`.


MiniSessions.get_latest()                          *MiniSessions.get_latest()*
    Get name of latest detected session

    Latest session is the session with the latest modification time determined
    by |getftime|.



    Return: ~
        string|nil: Name of latest session or `nil` if there is no sessions.


MiniSessions.on_vimenter()                        *MiniSessions.on_vimenter()*
    Act on |VimEnter|




================================================================================
                                                    *MiniStarter* *mini.starter*

Lua module for minimal, fast, and flexible start screen. Displayed items are
fully customizable both in terms of what they do and how they look (with
reasonable defaults). Item selection can be done using prefix query with
instant visual feedback.This is mostly inspired by
[mhinz/vim-startify](https://github.com/mhinz/vim-startify).

Key design ideas:
- All available actions are defined inside items. Each item should have the 
  following info:
    - `action` - function or string for |vim.cmd| which is executed when item
      is chosen. Empty string result in placeholder "inactive" item.
    - `name` - string which will be displayed and used for choosing.
    - `section` - string representing to which section item belongs. There are
      pre-configured whole sections in |MiniStarter.sections|.
- Configure what items are displayed by supplying an array which can be 
  normalized to an array of items. Read about how supplied items are normalized
  in |MiniStarter.refresh|.
- Modify the final look by supplying content hooks: functions which take buffer
  content as input (see |MiniStarter.content| for more information) and return
  buffer content as output. There are pre-configured content hook generators in
  |MiniStarter.gen_hook|.
- Choosing an item can be done in two ways:
    - Type prefix query to filter item by matching its name (ignoring case).
      Displayed information is updated after every typed character. For every
      item its unique prefix is highlighted.
    - Use Up/Down arrows and hit Enter.

What is doesn't do:
- It doesn't support fuzzy query for items. And probably will never do.

# Setup

This module needs a setup with `require('mini.starter').setup({})` (replace
`{}` with your `config` table). It will create global Lua table `MiniStarter`
which you can use for scripting or manually (with `:lua MiniStarter.*`).

Default `config`:
>
  {
    -- Whether to open starter buffer on VimEnter. Not opened if Neovim was
    -- started with intent to show something else.
    autoopen = true,

    -- Whether to evaluate action of single active item
    evaluate_single = false,

    -- Items to be displayed. Should be an array with the following elements:
    -- - Item: table with `action`, `name`, and `section` keys.
    -- - Function: should return one of these three categories.
    -- - Array: elements of these three types (i.e. item, array, function).
    -- If `nil`, default items will be used (see |mini.starter|).
    items = nil,

    -- Header to be displayed before items. Should be a string or function
    -- evaluating to single string (use `\n` for new lines). If `nil` (default),
    -- polite greeting will be used.
    header = nil,

    -- Footer to be displayed after items. Should be a string or function
    -- evaluating to string. If `nil`, default usage instructions will be used.
    footer = nil,

    -- Array  of functions to be applied consecutively to initial content. Each
    -- function should take and return content for "Starter" buffer (see
    -- |mini.starter| for more details).
    content_hooks = nil,

    -- Characters to update query. Each character will have special buffer
    -- mapping overriding your global ones. Be careful to not add `:` as it
    -- allows you to go into command mode.
    query_updaters = [[abcdefghijklmnopqrstuvwxyz0123456789_-.]],
  }
<
# Lifecycle of Starter buffer

- Open with |MiniStarter.open()|. It includes creating buffer with appropriate
  options, mappings, behavior; call to |MiniStarter.refresh()|; issue
  `MiniStarterOpened` |User| event.
- Wait for user to choose an item. This is done using following logic:
    - Typing any character from `MiniStarter.config.query_updaters` leads to
      updating query. Read more in |MiniStarter.add_to_query|.
    - <BS> deletes latest character from query.
    - <Down>/<Up> and <M-j>/<M-k> move current item.
    - <CR> executes action of current item.
    - <C-c> closes Starter buffer.
- Evaluate current item when appropriate (after `<CR>` or when there is a 
  single item and `MiniStarter.config.evaluate_single` is `true`). This 
  executes item's `action`.

# Example configurations

Configuration similar to 'mhinz/vim-startify':
>
  local starter = require('mini.starter')
  starter.setup({
    evaluate_single = true,
    items = {
      starter.sections.builtin_actions(),
      starter.sections.recent_files(10, false),
      starter.sections.recent_files(10, true),
      -- Use this if you set up 'mini.sessions'
      starter.sections.sessions(5, true)
    },
    content_hooks = {
      starter.gen_hook.adding_bullet(),
      starter.gen_hook.indexing('all', { 'Builtin actions' }),
      starter.gen_hook.padding(3, 2),
    },
  })
<
Configuration similar to 'glepnir/dashboard-nvim':
>
  local starter = require('mini.starter')
  starter.setup({
    items = {
      starter.sections.telescope(),
    },
    content_hooks = {
      starter.gen_hook.adding_bullet(),
      starter.gen_hook.aligning('center', 'center'),
    },
  })
<
Elaborated configuration showing capabilities of custom items, header/footer,
and content hooks:
>
  local my_items = {
    { name = 'Echo random number', action = [[lua print(math.random())]], section = 'Section 1' },
    function()
      return {
        { name = 'Item #1 from function', action = [[echo 'Item #1']], section = 'From function' },
        { name = 'Placeholder (always incative) item', action = '', section = 'From function' },
        function()
          return {
            name = 'Item #1 from double function',
            action = [[echo 'Double function']],
            section = 'From double function',
          }
        end,
      }
    end,
    { name = [[Another item in 'Section 1']], action = [[lua print(math.random() + 10)]], section = 'Section 1' },
  }

  local footer_n_seconds = (function()
    local timer = vim.loop.new_timer()
    local n_seconds = 0
    timer:start(0, 1000, vim.schedule_wrap(function()
      if vim.api.nvim_buf_get_option(0, 'filetype') ~= 'starter' then
        timer:stop()
        return
      end
      n_seconds = n_seconds + 1
      MiniStarter.refresh()
    end))

    return function()
      return 'Number of seconds since opening: ' .. n_seconds
    end
  end)()

  local hook_top_pad_10 = function(content)
    -- Pad from top
    for _ = 1, 10 do
      -- Insert at start a line with single content unit
      table.insert(content, 1, { { type = 'empty', string = '' } })
    end
    return content
  end

  local starter = require('mini.starter')
  starter.setup({
    items = my_items,
    footer = footer_n_seconds,
    content_hooks = { hook_top_pad_10 },
  })
<

# Definition of buffer content

Generally, buffer content is a table in the form of "2d array" (or rather "2d
list" because number of elements can differ):
- Each element represents content line: an array with content units to be 
  displayed in one buffer line.
- Each content unit is a table with at least the following elements:
    - "type" - string with type of content. Something like "item", "section",
      "header", "footer", "empty", etc.
    - "string" - which string should be displayed. May be an empty string.
    - "hl" - which highlighting should be applied to content string. May be 
      `nil` for no highlighting.

See |MiniStarter.content_to_lines| for converting content to buffer lines and
|MiniStarter.content_to_items| - to list of parsed items.

Notes:
- Content units with type "item" also have `item` element with all information
  about an item it represents. Those elements are used directly to create an
  array of items used for query.

# Highlight groups

- `MiniStarterCurrent` - current item.
- `MiniStarterFooter` - footer units.
- `MiniStarterHeader` - header units.
- `MiniStarterInactive` - inactive item.
- `MiniStarterItem` - item name.
- `MiniStarterItemBullet` - units from |MiniStarter.gen_hook.adding_bullet|.
- `MiniStarterItemPrefix` - unique query for item.
- `MiniStarterSection` - section units.
- `MiniStarterQuery` - current query in active items.

# Disabling

To disable core functionality, set `g:ministarter_disable` (globally) or
`b:ministarter_disable` (for a buffer) to `v:true`.

MiniStarter.content                                      *MiniStarter.content*
    Final content of Starter buffer. For more information see "Definition of
    buffer content" section in |mini.starter|.


MiniStarter.sections                                    *MiniStarter.sections*
    Table of pre-configured sections


MiniStarter.gen_hook                                    *MiniStarter.gen_hook*
    Table with pre-configured content hook generators. Each element is a
    function which returns content hook. So to use them inside
    |MiniStarter.setup|, call them.


MiniStarter.setup({config})                              *MiniStarter.setup()*
    Module setup



    Parameters: ~
        {config} (table)  Module config table.

    Usage: ~
        `require('mini.starter').setup({})` (replace `{}` with your `config`
        table)


MiniStarter.on_vimenter()                          *MiniStarter.on_vimenter()*
    Act on |VimEnter|.



MiniStarter.open()                                        *MiniStarter.open()*
    Open Starter buffer

    - Create and move into buffer.
    - Set buffer options. Note that settings are done with |noautocmd| to 
      achieve a massive speedup.
    - Set buffer mappings. Besides basic mappings (described inside "Lifecycle 
      of Starter buffer" of |mini.starter|), map every character from 
      `MiniStarter.config.query_updaters` to add itself to query with 
      |MiniStarter.add_to_query|.
    - Populate buffer with |MiniStarter.refresh|.
    - Issue custom `MiniStarterOpened` event to allow acting upon opening 
      Starter buffer. Use it with `autocmd User MiniStarterOpened <your
      command>`.



MiniStarter.refresh()                                  *MiniStarter.refresh()*
    Refresh Starter buffer

    - Normalize `MiniStarter.config.items`:
        - Flatten: recursively (in depth-first fashion) parse its elements. If 
          function is found, execute it and continue with parsing its output 
          (this allows deferring item collection up until it is actually 
          needed). If proper item is found (table with fields `action`, `name`,
          `section`), add it to output.
        - Sort: order first by section and then by item id (both in order of 
          appearance).
    - Normalize `MiniStarter.config.header` and `MiniStarter.config.footer` to 
      be a table of strings (per line). If function - evaluate it first.
    - Make initial buffer content (see |MiniStarter.content| for a description 
      of what a buffer content is). It consist from content lines with single 
      content unit:
        - First lines contain strings of normalized header.
        - Body is for normalized items. Section names have own lines preceded 
          by empty line.
        - Last lines contain separate strings of normalized footer.
    - Sequentially apply hooks from `MiniStarter.config.content_hooks` to 
      content. Output of one hook serves as input to the next.
    - Gather final items from content with |MiniStarter.content_to_items|.
    - Convert content to buffer lines with |MiniStarter.content_to_lines| and 
      add them to buffer.
    - Add highlighting of content units.
    - Position cursor.
    - Make current query. This results into some items being marked as 
      "inactive" and updating highlighting of current query on "active" items.

    Note: this function is executed on every |VimResized| to allow more
    responsive behavior.



MiniStarter.close()                                      *MiniStarter.close()*
    Close Starter buffer



MiniStarter.sections.builtin_actions() *MiniStarter.sections.builtin_actions()*
    Section with builtin actions



    Return: ~
        table: Array of items.


MiniStarter.sections.sessions({n}, {recent}) *MiniStarter.sections.sessions()*
    Section with |MiniSessions| sessions

    Sessions are taken from |MiniSessions.detected|. Notes:
    - If it shows "'mini.sessions' is not set up", it means that you didn't 
      call `require('mini.sessions').setup()`.
    - If it shows "There are no detected sessions in 'mini.sessions'", it means
      that there are no sessions at the current sessions directory. Either 
      create session or supply different directory where session files are 
      stored (see |MiniSessions.setup|).



    Parameters: ~
        {n}      (number)   Number of returned items. Default: 5.
        {recent} (boolean)  Whether to use recent sessions (instead of
                            alphabetically by name). Default: true.

    Return: ~
        function: Function which returns array of items.


MiniStarter.sections.recent_files({n}, {current_dir}, {show_path}) *MiniStarter.sections.recent_files()*
    Section with most recently used files

    Files are taken from |vim.v.oldfiles|.



    Parameters: ~
        {n}           (number)   Number of returned items. Default: 5.
        {current_dir} (boolean)  Whether to return files only from current
                                 working directory. Default: false.
        {show_path}   (boolean)  Whether to append file name with its full
                                 path. Default: true.

    Return: ~
        function: Function which returns array of items.


MiniStarter.sections.telescope()            *MiniStarter.sections.telescope()*
    Section with basic Telescope pickers relevant to start screen



    Return: ~
        function: Function which returns array of items.


MiniStarter.gen_hook.padding({left}, {top})   *MiniStarter.gen_hook.padding()*
    Hook generator for padding

    Output is a content hook which adds constant padding from left and top.
    This allows tweaking the screen position of buffer content.



    Parameters: ~
        {left} (number)  Number of empty spaces to add to start of each
                         content line. Default: 0.
        {top}  (number)  Number of empty lines to add to start of content.
                         Default: 0.

    Return: ~
        function: Content hook.


MiniStarter.gen_hook.adding_bullet({bullet}, {place_cursor}) *MiniStarter.gen_hook.adding_bullet()*
    Hook generator for adding bullet to items

    Output is a content hook which adds supplied string to be displayed to the
    left of item.



    Parameters: ~
        {bullet}       (string)   String to be placed to the left of item
                                  name. Default: " ".
        {place_cursor} (boolean)  Whether to place cursor on the first
                                  character of bullet when corresponding item
                                  becomes current. Default: true.

    Return: ~
        function: Content hook.


MiniStarter.gen_hook.indexing({grouping}, {exclude_sections}) *MiniStarter.gen_hook.indexing()*
    Hook generator for indexing items

    Output is a content hook which adds unique index to the start of item's
    name. It results into shortening queries required to choose an item (at
    expense of clarity).



    Parameters: ~
        {grouping}         (string)  One of "all" (number indexing across all
                                     sections) or "section" (letter-number
                                     indexing within each section). Default:
                                     "all".
        {exclude_sections} (table)   Array of section names (values of
                                     `section` element of item) for which
                                     index won't be added. Default: `{}`.

    Return: ~
        function: Content hook.


MiniStarter.gen_hook.aligning({horizontal}, {vertical}) *MiniStarter.gen_hook.aligning()*
    Hook generator for aligning content

    Output is a content hook which independently aligns content horizontally
    and vertically. Basically, this computes left and top pads for
    |MiniStarter.gen_hook.padding| such that output lines would appear aligned
    in certain way.



    Parameters: ~
        {horizontal} (string)  One of "left", "center", "right". Default:
                               "left".
        {vertical}   (string)  One of "top", "center", "bottom". Default:
                               "top".

    Return: ~
        function: Content hook.


MiniStarter.content_coords({content}, {predicate}) *MiniStarter.content_coords()*
    Helper to iterate through content

    Basically, this traverses content "2d array" (in depth-first fashion; top
    to bottom, left to right) and returns "coordinates" of units for which
    `predicate` is true-ish.



    Parameters: ~
        {content}   (table)            Content "2d array".
        {predicate} (function|string)  Predictate to filter units. If
                                       function, evaluated with unit as input.
                                       If string, checks unit to have this
                                       type (allows easy getting of units with
                                       some type). If `nil`, all units are
                                       kept.

    Return: ~
        table: Array of resulting units' coordinates. Each coordinate is a
        table with `line` and `unit` keys. To retrieve actual unit from
        coordinate `c`, use `content[c.line][c.unit]`.


MiniStarter.content_to_lines({content})       *MiniStarter.content_to_lines()*
    Convert content to buffer lines

    One buffer line is made by concatenating `string` element of units within
    same content line.



    Parameters: ~
        {content} (table)  Content "2d array".

    Return: ~
        table: Array of strings for each buffer line.


MiniStarter.content_to_items({content})       *MiniStarter.content_to_items()*
    Convert content to items

    Parse content (in depth-first fashion) and retrieve each item from `item`
    element of content units with type "item". This also:
    - Computes some helper information about how item will be actually 
      displayed (after |MiniStarter.content_to_lines|) and minimum number of 
      prefix characters needed for a particular item to be queried single.
    - Modifies item's `name` element taking it from corresponing `string` 
      element of content unit. This allows modifying item's `name` at the stage
      of content hooks (like, for example, in |MiniStarter.gen_hook.indexing|).



    Parameters: ~
        {content} (table)  Content "2d array".

    Return: ~
        table: Array of items.


MiniStarter.eval_current_item()              *MiniStarter.eval_current_item()*
    Evaluate current item



MiniStarter.update_current_item({direction}) *MiniStarter.update_current_item()*
    Update current item

    This makes next (with respect to `direction`) active item to be current.



    Parameters: ~
        {direction} (string)  One of "next" or "previous".


MiniStarter.add_to_query({char})                  *MiniStarter.add_to_query()*
    Add character to current query

    - Update current query by appending `char` to its end or delete latest 
      character if `char` is `nil`.
    - Recompute status of items: "active" if its name starts with new query, 
      "inactive" otherwise.
    - Update highlighting: whole strings for "inactive" items, current query 
      for "active" items.



    Parameters: ~
        {char} (string)  Single character to be added to query. If `nil`,
                         deletes latest character from query.


MiniStarter.on_cursormoved()                    *MiniStarter.on_cursormoved()*
    Act on |CursorMoved| by repositioning cursor in fixed place.




================================================================================
                                              *MiniStatusline* *mini.statusline*

Custom minimal and fast statusline module with opinionated default look.
Special features: change color depending on current mode and compact version of
sections activated when window width is small enough.

Features:
- Built-in active mode indicator with colors.
- Sections can hide information when window is too narrow (specific window 
  width is configurable per section).
- Define own custom statusline structure for active and inactive windows. This
  is done with a function which should return string appropriate for 
  |statusline|. Its code should be similar to default one with structure:
    - Compute string data for every section you want to be displayed.
    - Combine them in groups with |MiniStatusline.combine_groups()|.

# Dependencies

Suggested dependencies (provide extra functionality, statusline will work
without them):
- Nerd font (to support extra icons).
- Plugin 'lewis6991/gitsigns.nvim' for Git information in 
  |MiniStatusline.section_git|. If missing, no section will be shown.
- Plugin 'kyazdani42/nvim-web-devicons' for filetype icons in 
  `MiniStatusline.section_fileinfo`. If missing, no icons will be shown.

# Setup

This module needs a setup with `require('mini.statusline').setup({})` (replace
`{}` with your `config` table). It will create global Lua table
`MiniStatusline` which you can use for scripting or manually (with `:lua
MiniStatusline.*`).

Default `config`:
>
  {
    -- Content of statusline as functions which return statusline string. See `:h
    -- statusline` and code of default contents (used when `nil` is supplied).
    content = {
      -- Content for active window
      active = nil,

      -- Content for inactive window(s)
      inactive = nil,
    },

    -- Whether to set Vim's settings for statusline (make it always shown)
    set_vim_settings = true,
  }
<
# Example content

## Default content

This function is used as default value for active content:
>
  function()
    local mode, mode_hl = MiniStatusline.section_mode({ trunc_width = 120 })
    local git           = MiniStatusline.section_git({ trunc_width = 75 })
    local diagnostics   = MiniStatusline.section_diagnostics({ trunc_width = 75 })
    local filename      = MiniStatusline.section_filename({ trunc_width = 140 })
    local fileinfo      = MiniStatusline.section_fileinfo({ trunc_width = 120 })
    local location      = MiniStatusline.section_location({ trunc_width = 75 })

    return MiniStatusline.combine_groups({
      { hl = mode_hl,                  strings = { mode } },
      { hl = 'MiniStatuslineDevinfo',  strings = { git, diagnostics } },
      '%<', -- Mark general truncate point
      { hl = 'MiniStatuslineFilename', strings = { filename } },
      '%=', -- End left alignment
      { hl = 'MiniStatuslineFileinfo', strings = { fileinfo } },
      { hl = mode_hl,                  strings = { location } },
    })
  end
<
## Show boolean options

To compute section string for boolean option use variation of this code snippet
inside content function (you can modify option itself, truncation width, short
and long displayed names):
>
  local spell = vim.wo.spell and (MiniStatusline.is_truncated(120) and 'S' or 'SPELL') or ''
<
Here `x and y or z` is a common Lua way of doing ternary operator: if `x` is
`true`-ish then return `y`, if not - return `z`.

# Highlight groups

1. Highlighting depending on mode (returned as second value from 
   |MiniStatusline.section_mode|):
    - `MiniStatuslineModeNormal` - normal mode.
    - `MiniStatuslineModeInsert` - insert mode.
    - `MiniStatuslineModeVisual` - visual mode.
    - `MiniStatuslineModeReplace` - replace mode.
    - `MiniStatuslineModeCommand` - command mode.
    - `MiniStatuslineModeOther` - other mode (like terminal, etc.).
2. Highlight groups used in default statusline:
    - `MiniStatuslineDevinfo` - highlighting of "dev info" group 
      (|MiniStatusline.section_git| and |MiniStatusline.section_diagnostics|).
    - `MiniStatuslineFilename` - highliting of 
      |MiniStatusline.section_filename| section.
    - `MiniStatuslineFileinfo` - highliting of 
      |MiniStatusline.section_fileinfo| section.
3. `MiniStatuslineInactive` - highliting in not focused window.

To change any highlight group, modify it directly with |:highlight|.

# Disabling

To disable (show empty statusline), set `g:ministatusline_disable` (globally)
or `b:ministatusline_disable` (for a buffer) to `v:true`.

MiniStatusline.setup({config})                        *MiniStatusline.setup()*
    Module setup



    Parameters: ~
        {config} (table)  Module config table.

    Usage: ~
        `require('mini.statusline').setup({})` (replace `{}` with your
        `config` table)


MiniStatusline.active()                              *MiniStatusline.active()*
    Compute content for active window



MiniStatusline.inactive()                          *MiniStatusline.inactive()*
    Compute content for inactive window



MiniStatusline.combine_groups({groups})      *MiniStatusline.combine_groups()*
    Combine groups of sections

    Each group can be either a string or a table with fields `hl` (group's
    highlight group) and `strings` (strings representing sections).

    General idea of this function is as follows. String group is used as is
    (useful for special strings like `%<` or `%=`). Each group defined by table
    has own highlighting (if not supplied explicitly, the previous one is
    used). Non-empty strings inside group are separated by one space. Non-empty
    groups are separated by two spaces (one for each highlighting).



    Parameters: ~
        {groups} (table)  Array of groups

    Return: ~
        string: String suitable for 'statusline'.


MiniStatusline.is_truncated({trunc_width})     *MiniStatusline.is_truncated()*
    Decide whether to truncate

    This basically computes window width and compares it to `trunc_width`: if
    window is smaller then truncate; otherwise don't. Don't truncate by
    default.

    Use this to manually decide if section needs truncation or not.



    Parameters: ~
        {trunc_width} (number)  Truncation width. If `nil`, output is `false`.

    Return: ~
        boolean: Whether to truncate.


MiniStatusline.section_mode({args})            *MiniStatusline.section_mode()*
    Section for Vim |mode()|

    Short output is returned if window width is lower than `args.trunc_width`.



    Parameters: ~
        {args} (table)  Section arguments.

    Return: ~
        tuple: Section string and mode's highlight group.


MiniStatusline.section_git({args})              *MiniStatusline.section_git()*
    Section for Git information

    Normal output contains name of `HEAD` (via |b:gitsigns_head|) and chunk
    information (via |b:gitsigns_status|). Short output - only name of `HEAD`.
    Note: requires 'lewis6991/gitsigns' plugin.

    Short output is returned if window width is lower than `args.trunc_width`.



    Parameters: ~
        {args} (table)  Section arguments.

    Return: ~
        string: Section string.


MiniStatusline.section_diagnostics({args}) *MiniStatusline.section_diagnostics()*
    Section for Neovim's builtin diagnostics

    Shows nothing if there is no attached LSP clients or for short output.
    Otherwise uses |vim.lsp.diagnostic.get_count()| to show number of errors
    ('E'), warnings ('W'), information ('I'), and hints ('H').

    Short output is returned if window width is lower than `args.trunc_width`.



    Parameters: ~
        {args} (table)  Section arguments.

    Return: ~
        string: Section string.


MiniStatusline.section_filename({args})    *MiniStatusline.section_filename()*
    Section for file name

    Show full file name or relative in short output.

    Short output is returned if window width is lower than `args.trunc_width`.



    Parameters: ~
        {args} (table)  Section arguments.

    Return: ~
        string: Section string.


MiniStatusline.section_fileinfo({args})    *MiniStatusline.section_fileinfo()*
    Section for file information

    Short output contains only extension and is returned if window width is
    lower than `args.trunc_width`.



    Parameters: ~
        {args} (table)  Section arguments.

    Return: ~
        string: Section string.


MiniStatusline.section_location({args})    *MiniStatusline.section_location()*
    Section for location inside buffer

    Show location inside buffer in the form:
    - Normal: '<cursor line>|<total lines><cursor column>|<total columns>'.
    - Short: '<cursor line><cursor column>'.

    Short output is returned if window width is lower than `args.trunc_width`.



    Parameters: ~
        {args} (table)  Section arguments.

    Return: ~
        string: Section string.


MiniStatusline.section_searchcount({args}) *MiniStatusline.section_searchcount()*
    Section for current search count

    Show the current status of |searchcount()|. Empty output is returned if
    window width is lower than `args.trunc_width`, search highlighting is not
    on (see |v:hlsearch|), or if number of search result is 0.

    `args.options` is forwarded to |searchcount()|. By default it recomputes
    data on every call which can be computationally expensive (although still
    usually same order of magnitude as 0.1 ms). To prevent this, supply
    `args.options = {recompute = false}`.



    Parameters: ~
        {args} (table)  Section arguments.

    Return: ~
        string: Section string.



================================================================================
                                                  *MiniSurround* *mini.surround*

Custom somewhat minimal and fast surrounding Lua plugin. This is mostly a
reimplementation of the core features of 'machakann/vim-sandwich' with a couple
more on top (find surrounding, highlight surrounding).

Features:
- Actions (all of them are dot-repeatable out of the box):
    - Add surrounding with `sa` (in visual mode or on motion).
    - Delete surrounding with `sd`.
    - Replace surrounding with `sr`.
    - Find surrounding with `sf` or `sF` (move cursor right or left).
    - Highlight surrounding with `sh`.
    - Change number of neighbor lines with `sn` (see algorithm details).
- Surrounding is identified by a single character as both 'input' (in `delete`
  and `replace` start) and 'output' (in `add` and `replace` end):
    - 'f' - function call (string of letters or '_' or '.' followed by balanced
      '()'). In 'input' finds function call, in 'output' prompts user to enter
      function name.
    - 'i' - interactive. Prompts user to enter left and right parts.
    - 't' - tag. In 'input' finds tab with same identifier, in 'output' prompts
      user to enter tag name.
    - All symbols in brackets '()', '[]', '{}', '<>'. In 'input' represents 
      balanced brackets, in 'output' - left and right parts of brackets.
    - All other alphanumeric, punctuation, or space characters represent 
      surrounding with identical left and right parts.

Known issues which won't be resolved:
- Search for surrounding is done using Lua patterns (regex-like approach). So
  certain amount of false positives should be expected.
- When searching for 'input' surrounding, there is no distinction if it is 
  inside string or comment. So in this case there will be not proper match for
  a function call: 'f(a = ")", b = 1)'.
- Tags are searched using regex-like methods, so issues are inevitable. Overall
  it is pretty good, but certain cases won't work. Like self-nested tags won't
  match correctly on both ends: '<a><a></a></a>'.

# Setup

This module needs a setup with `require('mini.surround').setup({})` (replace
`{}` with your `config` table). It will create global Lua table `MiniSurround`
which you can use for scripting or manually (with `:lua MiniSurround.*`).

Default `config`:
>
  {
    -- Number of lines within which surrounding is searched
    n_lines = 20,

    -- Duration (in ms) of highlight when calling `MiniSurround.highlight()`
    highlight_duration = 500,

    -- Pattern to match function name in 'function call' surrounding
    -- By default it is a string of letters, '_' or '.'
    funname_pattern = '[%w_%.]+',

    -- Mappings. Use `''` (empty string) to disable one.
    mappings = {
      add = 'sa',           -- Add surrounding
      delete = 'sd',        -- Delete surrounding
      find = 'sf',          -- Find surrounding (to the right)
      find_left = 'sF',     -- Find surrounding (to the left)
      highlight = 'sh',     -- Highlight surrounding
      replace = 'sr',       -- Replace surrounding
      update_n_lines = 'sn' -- Update `n_lines`
    }
  }
<
# Example usage

- `saiw)` - add (`sa`) for inner word (`iw`) parenthesis (`)`).
- `saiwi[[<CR>]]<CR>` - add (`sa`) for inner word (`iw`) interactive 
  surrounding (`i`): `[[` for left and `]]` for right.
- `sdf` - delete (`sd`) surrounding function call (`f`).
- `sr)tdiv<CR>` - replace (`sr`) surrounding parenthesis (`)`) with tag (`t`)
  with identifier 'div' (`div<CR>` in command line prompt).
- `sff` - find right (`sf`) part of surrounding function call (`f`).
- `sh}` - highlight (`sh`) for a brief period of time surrounding curly 
  brackets (`}`)

# Algorithm design

- Adding 'output' surrounding has a fairly straightforward algorithm:
    - Determine places for left and right parts (via `<>` or `[]` marks).
    - Determine left and right parts of surrounding.
    - Properly add.
- Finding 'input' surrounding is a lot more complicated and is a reason why 
  this implementation is only somewhat minimal. In a nutshell, current 
  algorithm `searches in the neighborhood lines based on a certain pattern a
  _smallest_ match that covers cursor`. More detailed:
    - Extract neighborhood of cursor line: no more than 
      `MiniSurround.config.n_lines` before, cursor line itself, no more than 
      `MiniSurround.config.n_lines` after.
    - Convert it to '1d neighborhood' by concatenating with '\n' delimiter. 
      Compute location of current cursor position in this line.
    - Given Lua pattern for a 'input' surrounding, search for a smallest (with
      minimal width) match that covers cursor position. This is an iterative
      procedure, duration of which heavily depends on the length of '1d
      neighborhood' and frequency of pattern matching. If no match is found,
      there is no surrounding.
    - Compute parts of '1d neighborhood' that represent left and right part of
      found surrounding. This is done by using 'extract' pattern computed for
      every type of surrounding.
    - Convert '1d offsets' of found parts to their positions in buffer. Actual
      search is done firstly on cursor line (as it is the most frequent usage)
      and only then searches in neighborhood.

# Highlight groups

1. `MiniSurround` - highlighting of requested surrounding.

To change any highlight group, modify it directly with |:highlight|.

# Disabling

To disable, set `g:minisurround_disable` (globally) or `b:minisurround_disable`
(for a buffer) to `v:true`.

MiniSurround.setup({config})                            *MiniSurround.setup()*
    Module setup



    Parameters: ~
        {config} (table)  Module config table.

    Usage: ~
        `require('mini.surround').setup({})` (replace `{}` with your `config`
        table)


MiniSurround.operator({task}, {cache})               *MiniSurround.operator()*
    Surround operator

    Main function to be used in expression mappings. No need to use it
    directly, everything is setup in |MiniSurround.setup|.



    Parameters: ~
        {task}  (string)  Name of surround task.
        {cache} (table)   Task cache.


MiniSurround.add({mode})                                  *MiniSurround.add()*
    Add surrounding

    No need to use it directly, everything is setup in |MiniSurround.setup|.



    Parameters: ~
        {mode} (string)  Mapping mode (normal by default).


MiniSurround.delete()                                  *MiniSurround.delete()*
    Delete surrounding

    No need to use it directly, everything is setup in |MiniSurround.setup|.



MiniSurround.replace()                                *MiniSurround.replace()*
    Replace surrounding

    No need to use it directly, everything is setup in |MiniSurround.setup|.



MiniSurround.find()                                      *MiniSurround.find()*
    Find surrounding

    No need to use it directly, everything is setup in |MiniSurround.setup|.



MiniSurround.highlight()                            *MiniSurround.highlight()*
    Highlight surrounding

    No need to use it directly, everything is setup in |MiniSurround.setup|.



MiniSurround.update_n_lines()                  *MiniSurround.update_n_lines()*
    Update `MiniSurround.config.n_lines`

    Convenient wrapper for updating `MiniSurround.config.n_lines` in case the
    default one is not appropriate.




================================================================================
                                                    *MiniTabline* *mini.tabline*

Custom minimal and fast tabline module. General idea: show all listed buffers
in readable way with minimal total width in case of one vim tab, fall back for
deafult otherwise. Inspired by
[ap/vim-buftabline](https://github.com/ap/vim-buftabline).

Features:
- Buffers are listed by their identifier (see |bufnr()|).
- Different highlight groups for "states" of buffer affecting 'buffer tabs':
- Buffer names are made unique by extending paths to files or appending unique
  identifier to buffers without name.
- Current buffer is displayed "optimally centered" (in center of screen while
  maximizing the total number of buffers shown) when there are many buffers
  open.
- 'Buffer tabs' are clickable if Neovim allows it.

What it doesn't do:
- Custom buffer order is not supported.

# Dependencies

Suggested dependencies (provide extra functionality, tabline will work without
them):
- Plugin 'kyazdani42/nvim-web-devicons' for filetype icons near the buffer 
  name. If missing, no icons will be shown.

# Setup

This module needs a setup with `require('mini.tabline').setup({})` (replace
`{}` with your `config` table). It will create global Lua table `MiniTabline`
which you can use for scripting or manually (with `:lua MiniTabline.*`).

Default `config`:
>
  {
    -- Whether to show file icons (requires 'kyazdani42/nvim-web-devicons')
    show_icons = true,

    -- Whether to set Vim's settings for tabline (make it always shown and
    -- allow hidden buffers)
    set_vim_settings = true
  }
<
# Highlight groups

1. `MiniTablineCurrent` - buffer is current (has cursor in it).
2. `MiniTablineVisible` - buffer is visible (displayed in some window).
3. `MiniTablineHidden` - buffer is hidden (not displayed).
4. `MiniTablineModifiedCurrent` - buffer is modified and current.
5. `MiniTablineModifiedVisible` - buffer is modified and visible.
6. `MiniTablineModifiedHidden` - buffer is modified and hidden.
7. `MiniTablineFill` - unused right space of tabline.

To change any highlight group, modify it directly with |:highlight|.

# Disabling

To disable (show empty tabline), set `g:minitabline_disable` (globally) or
`b:minitabline_disable` (for a buffer) to `v:true`. Note: after disabling
tabline is not updated right away, but rather after dedicated event (see
|events| and `MiniTabline` |augroup|).

MiniTabline.setup({config})                              *MiniTabline.setup()*
    Module setup



    Parameters: ~
        {config} (table)  Module config table.

    Usage: ~
        `require('mini.tabline').setup({})` (replace `{}` with your `config`
        table)


MiniTabline.update_tabline()                    *MiniTabline.update_tabline()*
    Update |tabline|

    Designed to be used with |autocmd|. No need to use it directly,



MiniTabline.make_tabline_string()          *MiniTabline.make_tabline_string()*
    Make string for |tabline| in case of single tab




================================================================================
                                              *MiniTrailspace* *mini.trailspace*

Custom minimal and fast module for working with trailing whitespace.

Features:
- Highlighting is done only in modifiable buffer by default; only in Normal 
  mode; stops in Insert mode and when leaving window.
- Trim all trailing whitespace with |MiniTrailspace.trim()| function.

# Setup

This module needs a setup with `require('mini.trailspace').setup({})` (replace
`{}` with your `config` table). It will create global Lua table
`MiniTrailspace` which you can use for scripting or manually (with `:lua
MiniTrailspace.*`).

Default `config`:
>
  {
    -- Highlight only in normal buffers (ones with empty 'buftype'). This is
    -- useful to not show trailing whitespace where it usually doesn't matter.
    only_in_normal_buffers = true,
  }
<
# Highlight groups

1. `MiniTrailspace` - highlight group for trailing space.

To change any highlight group, modify it directly with |:highlight|.

# Disabling

To disable, set `g:minitrailspace_disable` (globally) or
`b:minitrailspace_disable` (for a buffer) to `v:true`. Note: after disabling
there might be highlighting left; it will be removed after next highlighting
update (see |events| and `MiniTrailspace` |augroup|).

MiniTrailspace.setup({config})                        *MiniTrailspace.setup()*
    Module setup



    Parameters: ~
        {config} (table)  Module config table.

    Usage: ~
        `require('mini.trailspace').setup({})` (replace `{}` with your
        `config` table)


MiniTrailspace.highlight()                        *MiniTrailspace.highlight()*
    Highlight trailing whitespace



MiniTrailspace.unhighlight()                    *MiniTrailspace.unhighlight()*
    Unhighlight trailing whitespace



MiniTrailspace.trim()                                  *MiniTrailspace.trim()*
    Trim trailing whitespace



MiniTrailspace.track_normal_buffer()    *MiniTrailspace.track_normal_buffer()*
    Track normal buffer

    Designed to be used with |autocmd|. No need to use it directly.




 vim:tw=78:ts=8:ft=help:norl:
